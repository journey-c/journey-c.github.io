<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>sync.pool源码阅读</title>
    <url>/2020/10/29/sync.pool%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<p>阅读项目代码的时候发现很多地方用到了golang的sync.pool，所以好奇golang的sync.pool底层实现是什么样的，有哪些优化。<br>本文是基于go1.13.8，做讲解。</p>
<a id="more"></a>

<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Pool翻译过来就是池子，主要功能就是: 需要使用某个Object的时候可以从Pool获取，使用完毕再归还，从而减少创建和销毁Object的开销。而本文讲的就是golang中的Pool源码实现。</p>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p><strong>千万不要想当然的认为put进去的Object和get出来的Object有什么关系，Pool存的Object在GC时会都清理掉</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Book struct &#123;</span><br><span class="line">	Name string</span><br><span class="line">	Info map[string]string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewBook() interface&#123;&#125; &#123;</span><br><span class="line">	return &amp;Book&#123;</span><br><span class="line">		Name: &quot;&quot;,</span><br><span class="line">		Info: make(map[string]string),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	&#x2F;&#x2F; 创建pool并定义创建object的函数</span><br><span class="line">	bookPool :&#x3D; sync.Pool&#123;New:NewBook&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 从pool获取object</span><br><span class="line">	a :&#x3D; bookPool.Get().(*Book)</span><br><span class="line">	a.Name &#x3D; &quot;go&quot;</span><br><span class="line">	a.Info[&quot;a&quot;] &#x3D; &quot;b&quot;</span><br><span class="line"></span><br><span class="line">	fmt.Println(a)</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 放回pool</span><br><span class="line">	bookPool.Put(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h1><p><img src="/images/pool.png"></p>
<h1 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h1><ul>
<li>Pool实现源码是这两个文件go/src/sync/pool.go, go/src/sync/poolqueue.go</li>
</ul>
<h2 id="数据结构——从下往上讲一下Pool底层存储是如何实现"><a href="#数据结构——从下往上讲一下Pool底层存储是如何实现" class="headerlink" title="数据结构——从下往上讲一下Pool底层存储是如何实现"></a>数据结构——从下往上讲一下Pool底层存储是如何实现</h2><h3 id="eface"><a href="#eface" class="headerlink" title="eface"></a>eface</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存储元素的结构体，类型指针和值指针</span></span><br><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">        typ, val unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Pool底层用eface来存储单个Object, 包括typ指针: Object的类型，val指针: Object的值</p>
<h3 id="poolDequeue"><a href="#poolDequeue" class="headerlink" title="poolDequeue"></a>poolDequeue</h3><p>poolDequeue是一个无锁、固定大小的单生产端多消费端的环形队列，单一producer可以在头部push和pop(可能和传统队列头部只能push的定义不同)，多consumer可以在尾部pop</p>
<ol>
<li>headTail:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[hhhhhhhh hhhhhhhh hhhhhhhh hhhhhhhh tttttttt tttttttt tttttttt tttttttt] </span><br><span class="line">1. headTail表示下标，高32位表示头下标，低32位表示尾下标，poolDequeue定义了，head tail的pack和unpack函数方便转化，</span><br><span class="line">	实际用的时候都会mod ( len(vals) - 1 ) 来防止溢出</span><br><span class="line">2. head和tail永远只用32位表示，溢出后会从0开始，这也满足循环队列的设计</span><br><span class="line">3. 队列为空的条件  tail &#x3D;&#x3D; head</span><br><span class="line">4. 队列满的条件    (tail+uint32(len(d.vals)))&amp;(1&lt;&lt;dequeueBits-1) &#x3D;&#x3D; head tail加上队列长度和head相等(实际上就是队列已有的空间都有值了,满了)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>vals:</li>
</ol>
<ol>
<li><p>poolDequeue是被poolChain使用，poolChain使用poolDequeue时<br> a) 初始化vals长度为8，vals长度必须是2的幂<br> b) 当队列满时，vals长度*2，最大扩展到 dequeueLimit = (1 &lt;&lt; 32) / 4 = (1 &lt;&lt; 30)，之后就不会扩展了</p>
</li>
<li><p>为什么vals长度必须是2的幂<br> 这是因为go的内存管理策略是将内存分为2的幂大小的链表，申请2的幂大小的内存可以有效减小分配内存的开销</p>
</li>
<li><p>为什么dequeueLimit是(1 &lt;&lt; 32) / 4 = 1 &lt;&lt; 30<br> a) dequeueLimit 必须是2的幂(上边解释过)<br> b) head和tail都是32位，最大是1 &lt;&lt; 31，如果都用的话，head和tail就是无符号整型，无符号整型使用的时候会有很多上溢的错误，这类错误是不容易检测的，所以相比之下还不如用31位有符号整型，有错就报出来，结论参考<a href="https://stackoverrun.com/cn/q/10770747">https://stackoverrun.com/cn/q/10770747</a></p>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> poolDequeue <span class="keyword">struct</span> &#123;</span><br><span class="line">	headTail <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">	vals []eface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// poolDequeue成员函数</span></span><br><span class="line"><span class="comment">// 这里的删除操作，是将指针置空，然后让GC来回收内存空间</span></span><br><span class="line">unpack     将headTail分解为head和tail</span><br><span class="line">pack       将head和tail组合成headTail</span><br><span class="line">pushHead   添加元素到队首</span><br><span class="line">popHead    获取并删除队首元素</span><br><span class="line">popTail    获取并删除队尾元素</span><br><span class="line">PushHead   添加元素到队首</span><br><span class="line">PopHead    获取并删除队首元素</span><br><span class="line">PopTail    获取并删除队尾元素</span><br></pre></td></tr></table></figure>

<h3 id="poolChainElt"><a href="#poolChainElt" class="headerlink" title="poolChainElt"></a>poolChainElt</h3><p>链表的一个节点 Node</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type poolChainElt struct &#123;</span><br><span class="line">	poolDequeue</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; next and prev link to the adjacent poolChainElts in this</span><br><span class="line">	&#x2F;&#x2F; poolChain.</span><br><span class="line">	&#x2F;&#x2F;</span><br><span class="line">	&#x2F;&#x2F; next is written atomically by the producer and read</span><br><span class="line">	&#x2F;&#x2F; atomically by the consumer. It only transitions from nil to</span><br><span class="line">	&#x2F;&#x2F; non-nil.</span><br><span class="line">	&#x2F;&#x2F;</span><br><span class="line">	&#x2F;&#x2F; prev is written atomically by the consumer and read</span><br><span class="line">	&#x2F;&#x2F; atomically by the producer. It only transitions from</span><br><span class="line">	&#x2F;&#x2F; non-nil to nil.</span><br><span class="line">	next, prev *poolChainElt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="poolChain"><a href="#poolChain" class="headerlink" title="poolChain"></a>poolChain</h3><p>poolChain 是动态版的poolDequeue<br>head(poolDequeue)[prev] –&gt; &lt;— <a href="...">next</a>[prev] —&gt; &lt;—[next]tail(poolDequeue)<br>动态的队列，队列每个节点又是一个环形队列(poolDequeue)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type poolChain struct &#123;</span><br><span class="line">	&#x2F;&#x2F; 头指针，只能单一producer操作(push, pop)</span><br><span class="line">	head *poolChainElt</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 尾指针，可以被多个consumer pop，必须是原子操作</span><br><span class="line">	tail *poolChainElt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; poolChain成员函数</span><br><span class="line">func (c *poolChain) pushHead(val interface&#123;&#125;)</span><br><span class="line">	1. 如果head为nil，说明队列现在是空的，那么新建一个节点，将head和tail都指向这个节点</span><br><span class="line">	2. 将val push到head的环形队列中，如果push成功了，可以返回了</span><br><span class="line">	3. 如果没push成功，则说明head的环形队列满了，就再创建一个两倍head大小的节点[最大(1 &lt;&lt; 32) &#x2F; 4]，</span><br><span class="line">		将新节点作为head，并且处理好新head和旧head的next，prev关系</span><br><span class="line">	4. 将val push到head的环形队列中</span><br><span class="line"></span><br><span class="line">func (c *poolChain) popHead()</span><br><span class="line">	1. 先在head环形队列中popHead试试，如果空了，当前节点就没用了，就删掉当前节点，去prev节点并且把prev节点作为新head再取一值递归下去，</span><br><span class="line">		能取到就返回，取不到说明队列空了</span><br><span class="line">func (c *poolChain) popTail()</span><br><span class="line">	1. 如果tail为nil，说明队列是空的，直接返回</span><br><span class="line">	2. 如果tail非nil，就取取试试，有东西就返回</span><br><span class="line">	3. 如果没取出来东西，那么说明tail节点没存东西了，递归去prev节点环形队列中popTail，并且把prev节点作为tail，能取到就返回，取不到就是空了</span><br></pre></td></tr></table></figure>

<h3 id="poolLocal"><a href="#poolLocal" class="headerlink" title="poolLocal"></a>poolLocal</h3><ol>
<li>poolLocal是每个调度器(P)存Object的结构体</li>
<li>private是每个调度器私有的，shared是所有调度器公有的，每个调度器pop时的逻辑是: 先看private，没有在看自己的shared，再没有就去其他调度器的shared偷，再没有才是空</li>
<li>pad是防止伪共享，参考<a href="https://www.cnblogs.com/cyfonly/p/5800758.html">https://www.cnblogs.com/cyfonly/p/5800758.html</a><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> poolLocal <span class="keyword">struct</span> &#123;</span><br><span class="line">	poolLocalInternal</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Prevents false sharing on widespread platforms with</span></span><br><span class="line">	<span class="comment">// 128 mod (cache line size) = 0 .</span></span><br><span class="line">	pad [<span class="number">128</span> - unsafe.Sizeof(poolLocalInternal&#123;&#125;)%<span class="number">128</span>]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Local per-P Pool appendix.</span></span><br><span class="line"><span class="comment">// 当前调度器的内部资源</span></span><br><span class="line"><span class="keyword">type</span> poolLocalInternal <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 当前调度器的私有资源</span></span><br><span class="line">	private <span class="keyword">interface</span>&#123;&#125; <span class="comment">// Can be used only by the respective P.</span></span><br><span class="line">	<span class="comment">// 所有调度器的公有资源</span></span><br><span class="line">	shared  poolChain   <span class="comment">// Local P can pushHead/popHead; any P can popTail.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="主要函数"><a href="#主要函数" class="headerlink" title="主要函数"></a>主要函数</h2><h3 id="Put"><a href="#Put" class="headerlink" title="Put"></a>Put</h3><p>Put adds x to the pool.</p>
<ol>
<li>首先关闭竞争检测，然后会将当前goroutine固定到一个调度器(P)上，且不允许抢占</li>
<li>从Pool的local中取出来当前goroutine固定到那个调度器(P)对应的poolLocal, 没有就新建</li>
<li>先判断这个当前调度器(P)专属poolLocal，私有空间是不是空的，如果是把x放到私有空间，并把x置nil</li>
<li>判断x是否为nil，如果不为空说明私有空间满了，就push到该调度器专属poolLocal的shared head</li>
<li>允许抢占，开启竞争检测</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Put</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 如果put进来的值为空直接返回</span></span><br><span class="line">	<span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 关闭竞争检测</span></span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		<span class="keyword">if</span> fastrand()%<span class="number">4</span> == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// Randomly drop x on floor.</span></span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		race.ReleaseMerge(poolRaceAddr(x))</span><br><span class="line">		race.Disable()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	l, _ := p.pin()</span><br><span class="line">	<span class="keyword">if</span> l.private == <span class="literal">nil</span> &#123;</span><br><span class="line">		l.private = x</span><br><span class="line">		x = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> x != <span class="literal">nil</span> &#123;</span><br><span class="line">		l.shared.pushHead(x)</span><br><span class="line">	&#125;</span><br><span class="line">	runtime_procUnpin()</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把当前的goroutine固定到调度器(P)，不允许抢占, 返回该调度器(P)对应的poolLocal和调度器(P)ID<br>运行时调度器的三个重要组成部分 — 线程 M、Goroutine G 和调度器 P(负责调度)</p>
<p>判断pid是否小于[]poolLocal的长度，小于的话就在取出poolLocal[P]返回，否则就去执行pinSlow函数<br>Caller must call runtime_procUnpin() when done with the pool.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">pin</span><span class="params">()</span> <span class="params">(*poolLocal, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 关闭抢占，等这个goroutine工作完，其他goroutine才能获得时间片工作</span></span><br><span class="line">	pid := runtime_procPin()</span><br><span class="line">	<span class="comment">// In pinSlow we store to local and then to localSize, here we load in opposite order.</span></span><br><span class="line">	<span class="comment">// Since we&#x27;ve disabled preemption, GC cannot happen in between.</span></span><br><span class="line">	<span class="comment">// Thus here we must observe local at least as large localSize.</span></span><br><span class="line">	<span class="comment">// We can observe a newer/larger local, it is fine (we must observe its zero-initialized-ness).</span></span><br><span class="line"></span><br><span class="line">	s := atomic.LoadUintptr(&amp;p.localSize) <span class="comment">// load-acquire</span></span><br><span class="line">	l := p.local                          <span class="comment">// load-consume</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">uintptr</span>(pid) &lt; s &#123;</span><br><span class="line">		<span class="keyword">return</span> indexLocal(l, pid), pid</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p.pinSlow()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当goroutine固定到的调度器(P)没有poolLocal时，pins() 函数就会调用pinSlow() 来重新固定到其他调度器(P)，<br>如果新固定到的调度器(P)还是没有poolLocal，就给该调度器创建一个poolLocal放到Pool的local中</p>
<ol>
<li>打开抢占并且pool加锁然后关闭抢占，这里如果不先打开抢占的话，其他goroutine如果之前获得锁了，但不能运行，当前goroutine在获取锁，就会死锁</li>
<li>如果判断pid和len([]poolLocal)的关系，小于就返回[PID]poolLocal</li>
<li>如果此Pool的[]poolLocal是空的，就把Pool加到allPools中</li>
<li>获得当前cpu的数量，创建一个cpu数量大小的[]poolLocal</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">pinSlow</span><span class="params">()</span> <span class="params">(*poolLocal, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	runtime_procUnpin()</span><br><span class="line">	allPoolsMu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> allPoolsMu.Unlock()</span><br><span class="line">	pid := runtime_procPin()</span><br><span class="line">	<span class="comment">// poolCleanup won&#x27;t be called while we are pinned.</span></span><br><span class="line">	s := p.localSize</span><br><span class="line">	l := p.local</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">uintptr</span>(pid) &lt; s &#123;</span><br><span class="line">		<span class="keyword">return</span> indexLocal(l, pid), pid</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> p.local == <span class="literal">nil</span> &#123;</span><br><span class="line">		allPools = <span class="built_in">append</span>(allPools, p)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// If GOMAXPROCS changes between GCs, we re-allocate the array and lose the old one.</span></span><br><span class="line">	size := runtime.GOMAXPROCS(<span class="number">0</span>)</span><br><span class="line">	local := <span class="built_in">make</span>([]poolLocal, size)</span><br><span class="line">	atomic.StorePointer(&amp;p.local, unsafe.Pointer(&amp;local[<span class="number">0</span>])) <span class="comment">// store-release</span></span><br><span class="line">	atomic.StoreUintptr(&amp;p.localSize, <span class="keyword">uintptr</span>(size))         <span class="comment">// store-release</span></span><br><span class="line">	<span class="keyword">return</span> &amp;local[pid], pid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h3><p>从Pool中获取对象，然后返回，如果Pool为空的就用New来创建<br>不要假设Put进来的对象和Get得到的对象有什么关系</p>
<ol>
<li>关掉竞争检测</li>
<li>将goroutine固定到一个调度器(P), 并获取他的poolLocal和PID</li>
<li>判断该调度器(P)的poolLocal的私有空间是不是空的，如果是空的，就从该调度器(P)的poolLocal shared空间头<br> pop一下看有没有</li>
<li>如果没有，就说明该调度器(P)自己的poolLocal没有对象了，就调用getSlow</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Get</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Disable()</span><br><span class="line">	&#125;</span><br><span class="line">	l, pid := p.pin()</span><br><span class="line">	x := l.private</span><br><span class="line">	l.private = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Try to pop the head of the local shard. We prefer</span></span><br><span class="line">		<span class="comment">// the head over the tail for temporal locality of</span></span><br><span class="line">		<span class="comment">// reuse.</span></span><br><span class="line">		x, _ = l.shared.popHead()</span><br><span class="line">		<span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">			x = p.getSlow(pid)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	runtime_procUnpin()</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		race.Enable()</span><br><span class="line">		<span class="keyword">if</span> x != <span class="literal">nil</span> &#123;</span><br><span class="line">			race.Acquire(poolRaceAddr(x))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> x == <span class="literal">nil</span> &amp;&amp; p.New != <span class="literal">nil</span> &#123;</span><br><span class="line">		x = p.New()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒获取函数</p>
<ol>
<li>取到Pool的localSize和local</li>
<li>然后遍历其他调度器(P)对应的poolLocal，看看能不能从对应poolLocal中的shared tail中取出对象, 如果能取到，直接返回</li>
<li>如果取不到就到victim中查询，有就返回，没有调用New创建一个新的Object返回</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">getSlow</span><span class="params">(pid <span class="keyword">int</span>)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="comment">// See the comment in pin regarding ordering of the loads.</span></span><br><span class="line">	size := atomic.LoadUintptr(&amp;p.localSize) <span class="comment">// load-acquire</span></span><br><span class="line">	locals := p.local                        <span class="comment">// load-consume</span></span><br><span class="line">	<span class="comment">// Try to steal one element from other procs.</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(size); i++ &#123;</span><br><span class="line">		l := indexLocal(locals, (pid+i+<span class="number">1</span>)%<span class="keyword">int</span>(size))</span><br><span class="line">		<span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> x</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Try the victim cache. We do this after attempting to steal</span></span><br><span class="line">	<span class="comment">// from all primary caches because we want objects in the</span></span><br><span class="line">	<span class="comment">// victim cache to age out if at all possible.</span></span><br><span class="line">	size = atomic.LoadUintptr(&amp;p.victimSize)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">uintptr</span>(pid) &gt;= size &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	locals = p.victim</span><br><span class="line">	l := indexLocal(locals, pid)</span><br><span class="line">	<span class="keyword">if</span> x := l.private; x != <span class="literal">nil</span> &#123;</span><br><span class="line">		l.private = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">return</span> x</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(size); i++ &#123;</span><br><span class="line">		l := indexLocal(locals, (pid+i)%<span class="keyword">int</span>(size))</span><br><span class="line">		<span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> x</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Mark the victim cache as empty for future gets don&#x27;t bother</span></span><br><span class="line">	<span class="comment">// with it.</span></span><br><span class="line">	atomic.StoreUintptr(&amp;p.victimSize, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="pool-dot"><a href="#pool-dot" class="headerlink" title="pool.dot"></a>pool.dot</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">digraph &#123;</span><br><span class="line">    bgcolor&#x3D;&quot;#C6CFD532&quot;;</span><br><span class="line"></span><br><span class="line">    node [shape&#x3D;record, fontsize&#x3D;&quot;8&quot;, margin&#x3D;&quot;0.04&quot;, height&#x3D;0.2, color&#x3D;gray]</span><br><span class="line">    edge [fontname&#x3D;&quot;Inconsolata, Consolas&quot;, fontsize&#x3D;10, arrowhead&#x3D;normal]</span><br><span class="line"></span><br><span class="line">    pool [shape&#x3D;record,label&#x3D;&quot;&#123;noCopy|&lt;local&gt;local|localSize|&lt;victim&gt;victim|victimSize|New&#125;&quot;,xlabel&#x3D;&quot;Pool&quot;]</span><br><span class="line">    poolLocal[shape&#x3D;record,label&#x3D;&quot;&#123;&lt;poolLocalInternal&gt;poolLocalInternal|pad&#125;&quot;,xlabel&#x3D;&quot;poolLocal&quot;]</span><br><span class="line">    poolLocalInternal[shape&#x3D;record,label&#x3D;&quot;&#123;private|&lt;shared&gt;shared&#125;&quot;,xlabel&#x3D;&quot;poolLocalInternal&quot;]</span><br><span class="line">    poolChain[shape&#x3D;record,label&#x3D;&quot;&#123;&lt;head&gt;head|&lt;tail&gt;tail&#125;&quot;,xlabel&#x3D;&quot;poolChain&quot;]</span><br><span class="line">    poolChainElt[shape&#x3D;record,label&#x3D;&quot;&#123;&lt;poolDequeue&gt;poolDequeue|next|prev&#125;&quot;,xlabel&#x3D;&quot;poolChainElt&quot;]</span><br><span class="line">    poolDequeue[shape&#x3D;record,label&#x3D;&quot;&#123;headTail|&lt;vals&gt;vals&#125;&quot;,xlabel&#x3D;&quot;poolDequeue&quot;]</span><br><span class="line">    eface[shape&#x3D;record,label&#x3D;&quot;&#123;typ|val&#125;&quot;,xlabel&#x3D;&quot;eface&quot;]</span><br><span class="line">    victim[shape&#x3D;record,label&#x3D;&quot;GC的时候，首先把local中每个处理器(P)对应的poolLocal赋给victim，然后清空local，所以victim就是缓存GC前的local&quot;,xlabel&#x3D;&quot;victim&quot;]</span><br><span class="line"></span><br><span class="line">    pool:local -&gt; poolLocal [label&#x3D;&quot;local指针指向[]poolLocal首地址&quot;,rankdir&#x3D;LR]</span><br><span class="line">    poolLocal:poolLocalInternal -&gt; poolLocalInternal</span><br><span class="line">    poolLocalInternal:shared -&gt; poolChain[label&#x3D;&quot;shared是一个队列&quot;]</span><br><span class="line">    poolChain:head -&gt; poolChainElt[label&#x3D;&quot;head和tail是队列的收尾节点指针&quot;]</span><br><span class="line">    poolChain:tail -&gt; poolChainElt</span><br><span class="line">    poolChainElt:poolDequeue -&gt; poolDequeue[label&#x3D;&quot;poolDequeue是一个环形队列&quot;]</span><br><span class="line">    poolDequeue:vals -&gt; eface[label&#x3D;&quot;eface存储Object的结构体，typ和val是Object的类型和值指针&quot;]</span><br><span class="line">    pool:victim -&gt; victim</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>语言</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Timing wheel心跳机制</title>
    <url>/2020/10/29/timing_wheel%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>在web服务中，断开空闲连接是一种减少资源浪费的一种手段，由此就有了心跳机制来判断一个连接是否空闲。</p>
<a id="more"></a> 

<h1 id="一种简单粗暴的方式："><a href="#一种简单粗暴的方式：" class="headerlink" title="一种简单粗暴的方式："></a>一种简单粗暴的方式：</h1><ol>
<li><p>服务端每个连接保存一个最后一次操作的时间戳，每次这个连接对应fd可读时（客户端发来请求），就更新一下时间戳。</p>
</li>
<li><p>服务端会起一个定时任务: close掉在时间戳(now – heart_beat)时刻之前的fd。</p>
</li>
</ol>
<p>这种方式需要不断的遍历已有连接，检查是否过期。</p>
<p>本文介绍的是，George Varghese 和 Tony Lauck 1996 年的论文《Hashed and Hierarchical Timing Wheels: data structures to efficiently implement a timer facility》中提出了一种时间轮(Timing wheel)管理time out事件的方式。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>下图是一个时间轮模型，假设当前心跳间隔是4S，将时间轮分为4分，每个格子表示当前格子的剩余寿命(s)。<br><img src="/images/time_wheel_1.png"><br>每隔1S，pointer滚动一次，先清理掉0号格子存放的所有连接，然后当前时刻进来的连接放入(heart_beat – 1)号格子格子。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>当前时刻conn 1连入，此时conn1剩余寿命3S，放入3号格子<br><img src="/images/time_wheel_2.png"><br>1S后，此时conn1剩余寿命2S<br><img src="/images/time_wheel_3.png"><br>当conn1剩余寿命为0S时，此连接会被清理。如果恰好这一秒conn进行操作了，那么会放入3号格子另一个conn1，如果时间轮上所有的conn1都被清理，那么这个连接会被关闭。</p>
<h1 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h1><p>C++以及一些指针友好型语言实现比较简单，轮子转动一次格子的指针引用数-1即可，当某个格子指针引用数为0时，代表格子时间到了，会析构掉。<br>事例代码可见: <a href="https://github.com/lyuc0924/basket/tree/master/forward">journey-c(basket网络库)</a>中workthread的实现。</p>
]]></content>
      <categories>
        <category>工程</category>
      </categories>
      <tags>
        <tag>工程</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/2020/10/22/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<p>红黑树是一种自平衡二叉搜索树。二叉搜索树就是插入的时候，比当前节点小的放到左子树，大的放到右子树。这样查找的时候可以沿着树的一条路径找到想要的值，所以时间复杂度是树的深度，最坏$O(N)$，平均$O(lg^N)$。</p>
<p>正因为二叉搜索树由于数据的不确定性可能造成树建的不平衡，导致树过深，时间复杂度过高。所以出现了自平衡二叉搜索树像红黑树。</p>
<p>红黑树所有的性质和特点都是想让树尽可能的平衡。</p>
<a id="more"></a>

<p><img src="/images/rbtree.jpg" alt="rbtree"></p>
<h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><ol>
<li>每个节点或是红色，或是黑色</li>
<li>根结点是黑色</li>
<li>每个叶节点(NIL)是黑色</li>
<li>如果一个节点是红色，则它两个子节点必须是黑色</li>
<li>对每个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点</li>
</ol>
<p>另外其他二叉树叶子结点一般为nil，红黑树为了节省内存空间，将所有叶子节点指向一个哨兵节点，哨兵节点color为BLACK，其他属性p、left、right、key为任意值，根结点的父节点也指向哨兵节点。</p>
<h1 id="为什么红黑树可以平衡"><a href="#为什么红黑树可以平衡" class="headerlink" title="为什么红黑树可以平衡"></a>为什么红黑树可以平衡</h1><h2 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h2><blockquote>
<p>一棵有n个内部节点的红黑树的高度至多为$2lg^{(n+1)}$</p>
</blockquote>
<p>如果可以证明上述引理，那么红黑树的查找最坏的时间复杂度也是$O(2lg^{(n+1)})$，因为在一棵高度为h的树上操作时间复杂度是$O(h)$，就是咱们要的平衡。</p>
<h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>首先证明<font color=red>红黑树以任意一个节点x为根的子树中至少包含$2^{bh(x)}-1$个内部节点</font>(从节点x出发，不包含x到达一个叶子节点的任意一条简单路径上黑节点的个数成为x节点的黑高，记为$bh(x)$)。</p>
<p>下面用数学归纳法证明</p>
<ul>
<li><p>当高度为0时<br>即子树为空，满足内部节点不超过$2^{0}-1=0$的要求。</p>
</li>
<li><p>当高度为k时<br>假设以x为根的子树内部节点不超过$2^{bh(x)}-1$。</p>
</li>
<li><p>当高度为k-1时<br>即当前节点是x(这个x节点是高度为k时假设的那个)的儿子，黑高为$bh(x)$或$bh(x)-1$，取决于儿子是黑还是红。所以以儿子节点为根的子树至少有$2^{bh(x)-1}-1$内部节点。于是，<font color=red>由儿子节点推父节点x内部节点的个数不超过$(2^{bh(x)-1}-1)+(2^{bh(x)-1}-1)=(2^{bh(x)}-1)$</font>，由此假设成立。</p>
</li>
</ul>
<p>现在来证明引理。设h为树的高度，根据性质4得出从根节点到叶节点的任何一条简单路径上都至少有一半节点是黑色，所以根的黑高至少时h/2。于是有</p>
<center>$n \geq 2^{h/2}-1$</center>

<p>n为树的节点个数，这个公式上边证明过了。将1放到左边，然后取对数得到</p>
<center>$lg^{(n+1)} \geq h/2 $</center>

<p>由此得到结论，高度小于等于$2lg^{(n+1)}$，所以只要满足红黑树性质的n节点二叉树高度最大为$2lg^{(n+1)}$。</p>
<center>$h \leq 2lg^{(n+1)}$</center>

<h1 id="红黑树如何实现自平衡"><a href="#红黑树如何实现自平衡" class="headerlink" title="红黑树如何实现自平衡"></a>红黑树如何实现自平衡</h1><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>由于插入和删除操作会对红黑树修改，有可能会不符合红黑树的性质，所以必须通过调整节点的颜色和指针结构来重新满足性质，而调整指针结构的操作是旋转，有左旋、右旋。<br><strong>下图α,β,γ代表一棵子树(可能为空)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    |                            |                      </span><br><span class="line">    y                            x</span><br><span class="line">   &#x2F; \   &lt;--- left rotate ---   &#x2F; \</span><br><span class="line">  x   γ  --- right rotate ---&gt; α   y</span><br><span class="line"> &#x2F; \                              &#x2F; \</span><br><span class="line">α   β                            β   γ</span><br></pre></td></tr></table></figure>

<h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><p>上图为例，左旋就是从右边树结构变成左边树结构的操作。<br>当在某点例如x点做左旋时: </p>
<ol>
<li>以x-y这条路径当轴，逆时针旋转(左旋)，x变成y的左儿子，y到原来x的位置。</li>
<li>因为x变成了y的左儿子，所以要考虑y之前是否有左儿子，如果有的话就要将左儿子β在左子树中重新找位置了，之前β是在x的右边所以比x大，刚好x的右儿子旋转后是空的，所以β就放到x的右儿子的位置。就得到了左边树的结构。</li>
</ol>
<h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><p>和左旋步骤是一样的，方向相反。</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><ol>
<li>插入节点颜色设置为红色。</li>
<li>首先从根结点开始遍历，插入节点比当前节点小就去左子树，否则就去右子树，直到遍历到叶子结点，然后比较插入节点和父节点大小选择作为父节点的左儿子还是右儿子。</li>
<li>现在已经将节点插入了，由于插入节点颜色是红色，所以可能破坏红节点儿子只能是黑节点的性质。所以从插入节点向上遍历修复破坏性质的地方，直到完全符合性质。</li>
</ol>
<h3 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h3><p>回想一下插入新节点的过程，然后对比一下可能违反什么性质。</p>
<table>
<thead>
<tr>
<th>性质编号</th>
<th>描述</th>
<th>是否可能违反</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>每个节点或是红色，或是黑色</td>
<td>不会违反，除非插入第三种颜色</td>
</tr>
<tr>
<td>2</td>
<td>根结点是黑色</td>
<td>可能违反，只有树为空的时候，插入节点(红色)作为根结点</td>
</tr>
<tr>
<td>3</td>
<td>每个叶节点(NIL)是黑色</td>
<td>不会违反，插入节点不会改变叶节点的颜色，叶节点永远都是T.nil</td>
</tr>
<tr>
<td>4</td>
<td>如果一个节点是红色，则它两个子节点必须是黑色</td>
<td>可能违反，只有插入节点的父节点是红色时，会违反这条性质</td>
</tr>
<tr>
<td>5</td>
<td>对每个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点</td>
<td>不会违反，插入节点为红色，不会改变每条路径上黑色的数量</td>
</tr>
</tbody></table>
<p>对比过后发现，可能违反的性质有2、4。并且同一时间只可能违反其一，如果违反性质2，说明树为空插入节点为根结点，根结点的父节点是T.nil(黑色)不违反性质4。如果违反性质4，那么插入节点的父节点一定是红色，说明树一定不是空的(为空的话，插入节点的父节点应该是T.nil黑色)，并且只有树为空的情况插入才会影响根结点颜色，所以也不可能违反性质2。</p>
<p>现在可能破坏的地方分析清楚了，就可以开始梳理如何修复了，并且修复操作不能造成二次破坏导致不符合其他性质。 </p>
<h4 id="违反性质1"><a href="#违反性质1" class="headerlink" title="违反性质1"></a>违反性质1</h4><p>只需要把根结点直接设置为黑色即可。因为违反性质1的时候，树中只有插入节点一个节点，所以修复结束。</p>
<h4 id="违反性质4"><a href="#违反性质4" class="headerlink" title="违反性质4"></a>违反性质4</h4><p>违反性质4是因为插入节点和父节点都是红色，情况比较复杂，具体分6类。从插入节点往上遍历，针对不同的case采取不同的fix方式，直到父节点是黑色或者到根结点即停止遍历。<br><strong>指针指向的位置初始时在插入位置</strong></p>
<h5 id="case-1"><a href="#case-1" class="headerlink" title="case 1"></a>case 1</h5><blockquote>
<p>(1)插入节点是父节点是祖父节点的左儿子<br>(2)插入节点叔节点是红色<br><img src="/images/rbtree_fixup_case1.png" alt="case1"><br>这种情况将父节点和叔节点变为黑色，祖父节点变为红色，指针指向祖父节点(上移两层)。<br><img src="/images/rbtree_fixup_case1_fix.png" alt="case1"><br><strong>这一步祖父节点可能是根结点，所以在修复完违反性质4的情况之后，再把根结点设置为黑色，避免再违反性质1</strong></p>
</blockquote>
<h5 id="case-2"><a href="#case-2" class="headerlink" title="case 2"></a>case 2</h5><blockquote>
<p>(1)插入节点是父节点是祖父节点的左儿子<br>(2)插入节点叔节点是黑色<br>(3)插入节点是父节点右儿子<br><img src="/images/rbtree_fixup_case2.png" alt="case1"><br>以父节点到插入节点为轴做左旋，就可以变为case 3。</p>
</blockquote>
<h5 id="case-3"><a href="#case-3" class="headerlink" title="case 3"></a>case 3</h5><blockquote>
<p>(1)插入节点是父节点是祖父节点的左儿子<br>(2)插入节点叔节点是黑色<br>(3)插入节点是父节点左儿子<br><img src="/images/rbtree_fixup_case3.png" alt="case1"><br>将父节点变为黑色，祖父节点变为红色，然后以祖父节点到父节点为轴，左右旋。(关系还是按照旋转前定的)<br><img src="/images/rbtree_fixup_case3_fix.png" alt="case1"><br><strong><em>case 4,5,6是插入节点的父节点是父节点右儿子的情况，和前三种对称，这里就略过了。</em></strong></p>
</blockquote>
<h3 id="插入节点为什么设置为红色"><a href="#插入节点为什么设置为红色" class="headerlink" title="插入节点为什么设置为红色?"></a>插入节点为什么设置为红色?</h3><p>如果设置为黑色的话，会破坏每点到叶节点简单路径上黑色节点数量相同的性质了，修复起来情况就复杂了，相比之下就比如直接设置为红色。</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除和普通的搜索二叉树的删除差不多，唯一的不同就是要记录减少的颜色，因为可能破坏红黑树的性质。 </p>
<blockquote>
<p>y: 为要删除的节点或者是后继节点(提上来放到删除节点的位置)<br>x: 为不违反性质的最低节点(x往下就没操作过)</p>
</blockquote>
<ol>
<li>没有儿子<br>直接删除y，y的父节点的儿子指向T.nil，x为T.nil。</li>
<li>只有右儿子<br>将y的右子树(以x为根的子树)提到y的位置，x为y的右儿子。</li>
<li>只有左儿子<br>将y的左子树提到y的位置，x为y的左儿子。</li>
<li>有两个儿子<br>找到后继节点y(比删除大的最小的那个)，用y替换删除节点的位置，颜色设置为删除节点的颜色，这样y原来的位置就空了，将y的右子树(如果有)提到y原来的位置，x为y的右儿子。</li>
</ol>
<h3 id="修复解析"><a href="#修复解析" class="headerlink" title="修复解析"></a>修复解析</h3><p>只要y是黑色节点，不论y是要删除的节点还是后继节点，删除操作完成后，都相当于少了y节点的颜色，所以要记住y之前的颜色，如果y是黑色的话，就会产生三个问题。</p>
<ol>
<li>如果y是根结点，删除y后，如果提到y位置节点颜色是红色就违反了性质2。(性质1最好修复，所有修复操作完成后直接把根变为黑色就行)</li>
<li>如果x是红色，并且x的父节点也是红色，就违反性质4。</li>
<li>因为y是黑色节点，所以删掉后经过y的路径上黑色节点都少1就违反性质5了，解决这个问题的办法是假设x除了自身颜色外还有一层黑色，就是双重颜色，所以现在x违反性质1。</li>
</ol>
<table>
<thead>
<tr>
<th>性质编号</th>
<th>描述</th>
<th>是否可能违反</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>每个节点或是红色，或是黑色</td>
<td>可能违反，x有双重颜色时违反</td>
</tr>
<tr>
<td>2</td>
<td>根结点是黑色</td>
<td>可能违反，y是根结点，并且后续一个红色节点代替了上来，那么根节点就是红色</td>
</tr>
<tr>
<td>3</td>
<td>每个叶节点(NIL)是黑色</td>
<td>不会违反</td>
</tr>
<tr>
<td>4</td>
<td>如果一个节点是红色，则它两个子节点必须是黑色</td>
<td>可能违反，情况4(两个儿子)，后继节点的父亲是红色，右儿子是红色，那么右儿子提上来之后就父子都是红色</td>
</tr>
<tr>
<td>5</td>
<td>对每个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点</td>
<td>不会违反</td>
</tr>
</tbody></table>
<p><strong>现在可能违反的性质有1，2，4</strong></p>
<h3 id="修复策略"><a href="#修复策略" class="headerlink" title="修复策略"></a>修复策略</h3><p>修复是从x向上遍历，因为x为根的子树没有做过操作，所以不会违反性质。修复册落氛围4中情况:</p>
<h4 id="case-1-1"><a href="#case-1-1" class="headerlink" title="case 1"></a>case 1</h4><blockquote>
<p>x的兄弟节点w是红色<br>此时，因为w是红色，所以x的父节点是黑色，且w的子节点是黑色。将w变为黑色，x的父节点变为红色，且对x的父节点做左旋，就变成case 2</p>
</blockquote>
<h4 id="case-2-1"><a href="#case-2-1" class="headerlink" title="case 2"></a>case 2</h4><blockquote>
<p>x的兄弟节点w是黑色，且w的两个子节点是黑色<br>因为w是黑色且x本来就一层黑色，所以从x，w上去掉一层黑色。将这层黑色加到x的父节点身上，指针指向从x到x的父节点，继续循环。</p>
</blockquote>
<h4 id="case-3-1"><a href="#case-3-1" class="headerlink" title="case 3"></a>case 3</h4><blockquote>
<p>x的兄弟节点w是黑色，且w的左儿子是红色，右儿子是黑色<br>交换w和左儿子的颜色，然后做一次右旋，变成case 4。</p>
</blockquote>
<h4 id="case-4"><a href="#case-4" class="headerlink" title="case 4"></a>case 4</h4><blockquote>
<p>x的兄弟节点w是黑色，且w的右儿子是红色<br>w变成w父节点的颜色，w父节点变成黑色，w的右儿子变成黑色，做一次左旋，循环结束。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>长连接平滑重启</title>
    <url>/2020/10/21/%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%B9%B3%E6%BB%91%E9%87%8D%E5%90%AF%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<blockquote>
<p>最近小编一直在做长连接相关的事情，最大的感触就是发版太痛苦，一个个踢掉连接然后发版，导致发版时长过长，操作繁琐。所以在想能不能实现优雅重启, 发版时客户端无感知。</p>
</blockquote>
<a id="more"></a>

<h1 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h1><ul>
<li><p>如何做到不中断接收连接</p>
</li>
<li><p>如何做到已有连接不中断</p>
</li>
</ul>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="如何做到不中断接受连接"><a href="#如何做到不中断接受连接" class="headerlink" title="如何做到不中断接受连接"></a>如何做到不中断接受连接</h2><p>以下是linux源码中bind的实现(linux-1.0)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; linux-1.0&#x2F;net&#x2F;socket.c 536</span><br><span class="line">static int</span><br><span class="line">sock_bind(int fd, struct sockaddr *umyaddr, int addrlen)</span><br><span class="line">&#123;</span><br><span class="line">  struct socket *sock;</span><br><span class="line">  int i;</span><br><span class="line"></span><br><span class="line">  DPRINTF((net_debug, &quot;NET: sock_bind: fd &#x3D; %d\n&quot;, fd));</span><br><span class="line">  if (fd &lt; 0 || fd &gt;&#x3D; NR_OPEN || current-&gt;filp[fd] &#x3D;&#x3D; NULL)</span><br><span class="line">								return(-EBADF);</span><br><span class="line">  &#x2F;&#x2F;获取fd对应的socket结构</span><br><span class="line">  if (!(sock &#x3D; sockfd_lookup(fd, NULL))) return(-ENOTSOCK);</span><br><span class="line">  &#x2F;&#x2F; 转调用bind指向的函数，下层函数(inet_bind)</span><br><span class="line">  if ((i &#x3D; sock-&gt;ops-&gt;bind(sock, umyaddr, addrlen)) &lt; 0) &#123;</span><br><span class="line">	DPRINTF((net_debug, &quot;NET: sock_bind: bind failed\n&quot;));</span><br><span class="line">	return(i);</span><br><span class="line">  &#125;</span><br><span class="line">  return(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; linux-1.0&#x2F;net&#x2F;inet&#x2F;sock.c 1012</span><br><span class="line">static int</span><br><span class="line">inet_bind(struct socket *sock, struct sockaddr *uaddr,</span><br><span class="line">	       int addr_len)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">outside_loop:</span><br><span class="line">  for(sk2 &#x3D; sk-&gt;prot-&gt;sock_array[snum &amp; (SOCK_ARRAY_SIZE -1)];</span><br><span class="line">					sk2 !&#x3D; NULL; sk2 &#x3D; sk2-&gt;next) &#123;</span><br><span class="line">#if 	1	&#x2F;* should be below! *&#x2F;</span><br><span class="line">	if (sk2-&gt;num !&#x3D; snum) continue;</span><br><span class="line">&#x2F;*	if (sk2-&gt;saddr !&#x3D; sk-&gt;saddr) continue; *&#x2F;</span><br><span class="line">#endif</span><br><span class="line">	if (sk2-&gt;dead) &#123;</span><br><span class="line">		destroy_sock(sk2);</span><br><span class="line">		goto outside_loop;</span><br><span class="line">	&#125;</span><br><span class="line">	if (!sk-&gt;reuse) &#123;</span><br><span class="line">		sti();</span><br><span class="line">		return(-EADDRINUSE);</span><br><span class="line">	&#125;</span><br><span class="line">	if (sk2-&gt;num !&#x3D; snum) continue;		&#x2F;* more than one *&#x2F;</span><br><span class="line">	if (sk2-&gt;saddr !&#x3D; sk-&gt;saddr) continue;	&#x2F;* socket per slot ! -FB *&#x2F;</span><br><span class="line">	if (!sk2-&gt;reuse) &#123;</span><br><span class="line">		sti();</span><br><span class="line">		return(-EADDRINUSE);</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ... </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>sock_array是一个链式哈希表，保存着各端口号的sock结构  </li>
<li>通过源码可以看到，bind的时候会检测要绑定的地址和端口是否合法以及已被绑定, 如果发版时另一个进程和旧进程没有关系，则bind会返回错误Address already in use  </li>
<li>若旧进程fork出新进程，新进程和旧进程为父子关系，新进程继承旧进程的文件表，本身”本进程”就已经监听这个端口了，则不会出现上面的问题</li>
</ul>
<h2 id="如何做到已有连接不中断"><a href="#如何做到已有连接不中断" class="headerlink" title="如何做到已有连接不中断"></a>如何做到已有连接不中断</h2><ul>
<li><p>新进程继承旧进程的用于连接的fd，并且继续维持与客户端的心跳</p>
<p>linux提供了unix域套接字可用于socket的传输, 新进程起来后通过unix socket通信继承旧进程所维护的连接</p>
</li>
</ul>
<p>[^unix socket]: unix socket用于**<em>一台**</em>主机的进程间通信，不需要基于网络协议，主要是基于文件系统的。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;socket.h&gt;</span><br><span class="line"></span><br><span class="line">ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);</span><br><span class="line">ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);</span><br></pre></td></tr></table></figure>

<p>发送端调用sendmsg发送文件描述符，接收端调用revmsg接收文件描述符。  </p>
<p>两进程共享同一打开文件表，这与fork之后的父子进程共享打开文件表的情况完全相同。  </p>
<p><strong><em>由此解决了文章开头提出的两个问题</em></strong></p>
<h1 id="Demo实现"><a href="#Demo实现" class="headerlink" title="Demo实现"></a>Demo实现</h1><ul>
<li><p>进程每次启动时必须check有无继承socket(尝试连接本地的unix server，如果连接失败，说明是第一次启动，否则可能有继承的socket)，如果有，就将socket加入到自己的连接池中, 并初始化连接状态</p>
</li>
<li><p>旧进程监听USR2信号(通知进程需要重启，使用信号、http接口等都可)，监听后动作:</p>
<ol>
<li>监听Unix socket, 等待新进程初始化完成，发来开始继承连接的请求</li>
<li>使用旧进程启动的命令fork一个子进程(发布到线上的新二进制)。</li>
<li>accept到新进程的请求，关闭旧进程listener(保证旧进程不会再接收新请求，同时所有connector不在进行I/O操作。</li>
<li>旧进程将现有连接的socket，以及连接状态(读写buffer，connect session)通过 unix socket发送到新进程。</li>
<li>最后旧进程给新进程发送发送完毕信号，随后退出</li>
</ol>
</li>
<li><p>以下是简单实现的demo, demo中实现较为简单，只实现了文件描述符的传递，没有实现各连接状态的传递。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; server.go</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;flag&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;golang.org&#x2F;x&#x2F;sys&#x2F;unix&quot;</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;net&quot;</span><br><span class="line">	&quot;os&quot;</span><br><span class="line">	&quot;os&#x2F;signal&quot;</span><br><span class="line">	&quot;path&#x2F;filepath&quot;</span><br><span class="line">	&quot;sync&quot;</span><br><span class="line">	&quot;syscall&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">	workSpace string</span><br><span class="line"></span><br><span class="line">	logger *log.Logger</span><br><span class="line"></span><br><span class="line">	writeTimeout &#x3D; time.Second * 5</span><br><span class="line">	readTimeout  &#x3D; time.Second * 5</span><br><span class="line"></span><br><span class="line">	signalChan &#x3D; make(chan os.Signal)</span><br><span class="line"></span><br><span class="line">	connFiles sync.Map</span><br><span class="line"></span><br><span class="line">	serverListener net.Listener</span><br><span class="line"></span><br><span class="line">	isUpdate &#x3D; false</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">	flag.StringVar(&amp;workSpace, &quot;w&quot;, &quot;.&quot;, &quot;Usage:\n .&#x2F;server -w&#x3D;workspace&quot;)</span><br><span class="line">	flag.Parse()</span><br><span class="line"></span><br><span class="line">	file, err :&#x3D; os.OpenFile(filepath.Join(workSpace, &quot;server.log&quot;), os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0777)</span><br><span class="line">	if err !&#x3D; nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	logger &#x3D; log.New(file, &quot;&quot;, 11)</span><br><span class="line">	go beforeStart()</span><br><span class="line">	go signalHandler()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var err error</span><br><span class="line">	serverListener, err &#x3D; net.Listen(&quot;tcp&quot;, &quot;:7000&quot;)</span><br><span class="line">	if err !&#x3D; nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	for &#123;</span><br><span class="line">		if isUpdate &#x3D;&#x3D; true &#123;</span><br><span class="line">			continue</span><br><span class="line">		&#125;</span><br><span class="line">		conn, err :&#x3D; serverListener.Accept()</span><br><span class="line">		if err !&#x3D; nil &#123;</span><br><span class="line">			logger.Println(&quot;conn error&quot;)</span><br><span class="line">			continue</span><br><span class="line">		&#125;</span><br><span class="line">		c :&#x3D; conn.(*net.TCPConn)</span><br><span class="line">		go connectionHandler(c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func connectionHandler(conn *net.TCPConn) &#123;</span><br><span class="line">	file, _ :&#x3D; conn.File()</span><br><span class="line">	connFiles.Store(file, true)</span><br><span class="line">	logger.Printf(&quot;conn fd %d\n&quot;, file.Fd())</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		connFiles.Delete(file)</span><br><span class="line">		_ &#x3D; conn.Close()</span><br><span class="line">	&#125;()</span><br><span class="line">	for &#123;</span><br><span class="line">		if isUpdate &#x3D;&#x3D; true &#123;</span><br><span class="line">			continue</span><br><span class="line">		&#125;</span><br><span class="line">		err :&#x3D; conn.SetReadDeadline(time.Now().Add(readTimeout))</span><br><span class="line">		if err !&#x3D; nil &#123;</span><br><span class="line">			logger.Println(err.Error())</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">		rBuf :&#x3D; make([]byte, 4)</span><br><span class="line">		_, err &#x3D; conn.Read(rBuf)</span><br><span class="line">		if err !&#x3D; nil &#123;</span><br><span class="line">			logger.Println(err.Error())</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">		if string(rBuf) !&#x3D; &quot;ping&quot; &#123;</span><br><span class="line">			logger.Println(&quot;failed to parse the message &quot; + string(rBuf))</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">		err &#x3D; conn.SetWriteDeadline(time.Now().Add(writeTimeout))</span><br><span class="line">		if err !&#x3D; nil &#123;</span><br><span class="line">			logger.Println(err.Error())</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">		_, err &#x3D; conn.Write([]byte(&#96;pong&#96;))</span><br><span class="line">		if err !&#x3D; nil &#123;</span><br><span class="line">			logger.Println(err.Error())</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func beforeStart() &#123;</span><br><span class="line">	connInterface, err :&#x3D; net.Dial(&quot;unix&quot;, filepath.Join(workSpace, &quot;conn.sock&quot;))</span><br><span class="line">	if err !&#x3D; nil &#123;</span><br><span class="line">		logger.Println(err.Error())</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		_ &#x3D; connInterface.Close()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	unixConn :&#x3D; connInterface.(*net.UnixConn)</span><br><span class="line"></span><br><span class="line">	b :&#x3D; make([]byte, 1)</span><br><span class="line">	oob :&#x3D; make([]byte, 32)</span><br><span class="line">	for &#123;</span><br><span class="line">		err &#x3D; unixConn.SetWriteDeadline(time.Now().Add(time.Minute * 3))</span><br><span class="line">		if err !&#x3D; nil &#123;</span><br><span class="line">			fmt.Println(err.Error())</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">		n, oobn, _, _, err :&#x3D; unixConn.ReadMsgUnix(b, oob)</span><br><span class="line">		if err !&#x3D; nil &#123;</span><br><span class="line">			logger.Println(err.Error())</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">		if n !&#x3D; 1 || b[0] !&#x3D; 0 &#123;</span><br><span class="line">			if n !&#x3D; 1 &#123;</span><br><span class="line">				logger.Printf(&quot;recv fd type error: %d\n&quot;, n)</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				logger.Println(&quot;init finish&quot;)</span><br><span class="line">			&#125;</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">		scms, err :&#x3D; unix.ParseSocketControlMessage(oob[0:oobn])</span><br><span class="line">		if err !&#x3D; nil &#123;</span><br><span class="line">			logger.Println(err.Error())</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">		if len(scms) !&#x3D; 1 &#123;</span><br><span class="line">			logger.Printf(&quot;recv fd num !&#x3D; 1 : %d\n&quot;, len(scms))</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">		fds, err :&#x3D; unix.ParseUnixRights(&amp;scms[0])</span><br><span class="line">		if err !&#x3D; nil &#123;</span><br><span class="line">			logger.Println(err.Error())</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">		if len(fds) !&#x3D; 1 &#123;</span><br><span class="line">			logger.Printf(&quot;recv fd num !&#x3D; 1 : %d\n&quot;, len(fds))</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">		logger.Printf(&quot;recv fd %d\n&quot;, fds[0])</span><br><span class="line">		file :&#x3D; os.NewFile(uintptr(fds[0]), &quot;fd-from-old&quot;)</span><br><span class="line">		conn, err :&#x3D; net.FileConn(file)</span><br><span class="line">		if err !&#x3D; nil &#123;</span><br><span class="line">			logger.Println(err.Error())</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">		go connectionHandler(conn.(*net.TCPConn))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func signalHandler() &#123;</span><br><span class="line">	signal.Notify(</span><br><span class="line">		signalChan,</span><br><span class="line">		syscall.SIGUSR2,</span><br><span class="line">	)</span><br><span class="line">	for &#123;</span><br><span class="line">		sc :&#x3D; &lt;-signalChan</span><br><span class="line">		switch sc &#123;</span><br><span class="line">		case syscall.SIGUSR2:</span><br><span class="line">			gracefulExit()</span><br><span class="line">		default:</span><br><span class="line">			continue</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func gracefulExit() &#123;</span><br><span class="line">	var connWait sync.WaitGroup</span><br><span class="line">	_ &#x3D; syscall.Unlink(filepath.Join(workSpace, &quot;conn.sock&quot;))</span><br><span class="line">	listenerInterface, err :&#x3D; net.Listen(&quot;unix&quot;, filepath.Join(workSpace, &quot;conn.sock&quot;))</span><br><span class="line">	if err !&#x3D; nil &#123;</span><br><span class="line">		logger.Println(err.Error())</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		_ &#x3D; listenerInterface.Close()</span><br><span class="line">	&#125;()</span><br><span class="line">	unixListener :&#x3D; listenerInterface.(*net.UnixListener)</span><br><span class="line">	connWait.Add(1)</span><br><span class="line">	go func() &#123;</span><br><span class="line">		defer connWait.Done()</span><br><span class="line">		unixConn, err :&#x3D; unixListener.AcceptUnix()</span><br><span class="line">		if err !&#x3D; nil &#123;</span><br><span class="line">			logger.Println(err.Error())</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">		defer func() &#123;</span><br><span class="line">			_ &#x3D; unixConn.Close()</span><br><span class="line">		&#125;()</span><br><span class="line">		connFiles.Range(func(key, value interface&#123;&#125;) bool &#123;</span><br><span class="line">			if key &#x3D;&#x3D; nil || value &#x3D;&#x3D; nil &#123;</span><br><span class="line">				return false</span><br><span class="line">			&#125;</span><br><span class="line">			file :&#x3D; key.(*os.File)</span><br><span class="line">			defer func() &#123;</span><br><span class="line">				_ &#x3D; file.Close()</span><br><span class="line">			&#125;()</span><br><span class="line">			buf :&#x3D; make([]byte, 1)</span><br><span class="line">			buf[0] &#x3D; 0</span><br><span class="line">			rights :&#x3D; syscall.UnixRights(int(file.Fd()))</span><br><span class="line">			_, _, err :&#x3D; unixConn.WriteMsgUnix(buf, rights, nil)</span><br><span class="line">			if err !&#x3D; nil &#123;</span><br><span class="line">				logger.Println(err.Error())</span><br><span class="line">			&#125;</span><br><span class="line">			logger.Printf(&quot;send fd %d\n&quot;, file.Fd())</span><br><span class="line">			return true</span><br><span class="line">		&#125;)</span><br><span class="line">		finish :&#x3D; make([]byte, 1)</span><br><span class="line">		finish[0] &#x3D; 1</span><br><span class="line">		_, _, err &#x3D; unixConn.WriteMsgUnix(finish, nil, nil)</span><br><span class="line">		if err !&#x3D; nil &#123;</span><br><span class="line">			logger.Println(err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	isUpdate &#x3D; true</span><br><span class="line">	execSpec :&#x3D; &amp;syscall.ProcAttr&#123;</span><br><span class="line">		Env:   os.Environ(),</span><br><span class="line">		Files: append([]uintptr&#123;os.Stdin.Fd(), os.Stdout.Fd(), os.Stderr.Fd()&#125;),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pid, err :&#x3D; syscall.ForkExec(os.Args[0], os.Args, execSpec)</span><br><span class="line">	if err !&#x3D; nil &#123;</span><br><span class="line">		logger.Println(err.Error())</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	logger.Printf(&quot;old process %d new process %d\n&quot;, os.Getpid(), pid)</span><br><span class="line">	_ &#x3D; serverListener.Close()</span><br><span class="line"></span><br><span class="line">	connWait.Wait()</span><br><span class="line">	os.Exit(0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; client.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;net&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">	writeTimeout &#x3D; time.Second * 5</span><br><span class="line">	readTimeout  &#x3D; time.Second * 5</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	conn, err :&#x3D; net.Dial(&quot;tcp&quot;, &quot;127.0.0.1:7000&quot;)</span><br><span class="line">	if err !&#x3D; nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		conn.Close()</span><br><span class="line">	&#125;()</span><br><span class="line">	for &#123;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		err :&#x3D; conn.SetWriteDeadline(time.Now().Add(writeTimeout))</span><br><span class="line">		if err !&#x3D; nil &#123;</span><br><span class="line">			fmt.Println(err.Error())</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(&quot;send ping&quot;)</span><br><span class="line">		_, err &#x3D; conn.Write([]byte(&#96;ping&#96;))</span><br><span class="line">		if err !&#x3D; nil &#123;</span><br><span class="line">			fmt.Println(err.Error())</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">		err &#x3D; conn.SetReadDeadline(time.Now().Add(readTimeout))</span><br><span class="line">		if err !&#x3D; nil &#123;</span><br><span class="line">			fmt.Println(err.Error())</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">		rBuf :&#x3D; make([]byte, 4)</span><br><span class="line">		_, err &#x3D; conn.Read(rBuf)</span><br><span class="line">		if err !&#x3D; nil &#123;</span><br><span class="line">			fmt.Println(err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(&quot;recv &quot; + string(rBuf))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工程</category>
        <category>长连接</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>关于2的n次幂对齐</title>
    <url>/2020/10/29/%E5%85%B3%E4%BA%8E2%E7%9A%84n%E6%AC%A1%E5%B9%82%E5%AF%B9%E9%BD%90/</url>
    <content><![CDATA[<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>内存对齐时基本都会求关于n位对齐的向上取整</p>
<a id="more"></a>

<h1 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h1><p>go1.13.8 中channel源码中有这样一个变量<a href="https://github.com/golang/go/blob/885099d1550dad8387013c8f35ad3d4ad9f17c66/src/runtime/chan.go#L28">hchansize</a>用来表示hchan(channel对应的实际结构体)所需大小(申请内存空间时，是根据hchansize给hchan申请对应大小的内存空间)，这个变量的值大概就是hchan的size关于maxAlign向上取整下一个较大倍数，看到源码实现时，就感觉真是怪物。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hchanSize = unsafe.Sizeof(hchan&#123;&#125;) + <span class="keyword">uintptr</span>(-<span class="keyword">int</span>(unsafe.Sizeof(hchan&#123;&#125;))&amp;(maxAlign<span class="number">-1</span>))</span><br></pre></td></tr></table></figure>

<p>为了方便将上述表达式简化为 n + ( (-n) &amp; (a - 1))，n是unsafe.Sizeof(hchan{})，a是maxAlign。等价于 n + (a - (n % a))</p>
<p><strong>( (-n) &amp; (a - 1) ) 等价 a - (n % a) ?</strong></p>
<p>向上取整的问题实际可以转化为求出n距离下一个a的倍数差多少，然后n加上这个数就可以。</p>
<p>当a为2的n次幂时，n % a可以转化为 n &amp; (a - 1)，取模运算就变成了n与(a - 1) AND时能留下多少个1。</p>
<p>计算机实际计算时是以<a href="https://www.cnblogs.com/wuwangchuxin0924/p/5851067.html">补码</a>进行运算的，-n转化为补码，符号位不变其他位取反转化为反码，然后最低位+1转化为补码，下面分两步讲。</p>
<p>以n = 3, a = 8为例(实际计算时是8字节，下面用一字节举例):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原码: -n &#x3D; 1000 0011</span><br><span class="line">反码: -n &#x3D; 1111 1100</span><br><span class="line">此时(-n) &amp; (a - 1)实际为 (a - 1) - n % a，而咱们要求的是a - (n % a)</span><br><span class="line">补码：-n &#x3D; 1111 1101</span><br><span class="line">因为-n的反码变补码时最低位要+1，所以刚好(a - 1) - n % a + 1 &#x3D; a - (n % a)</span><br></pre></td></tr></table></figure>

<p>所以( (-n) &amp; (a - 1) ) 等价 a - (n % a)</p>
]]></content>
      <categories>
        <category>黑科技</category>
      </categories>
      <tags>
        <tag>黑科技</tag>
      </tags>
  </entry>
  <entry>
    <title>channel 源码阅读</title>
    <url>/2020/10/29/channel%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<p>(年初的时候go语言的学习提上了日程，前一篇sync.pool阅读之后，阅读代码进度本该更快些，奈何身体被掏空，所以这篇文章断断续续一个月终于攒起来了。)</p>
<a id="more"></a>

<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>channel是golang中用于goroutine之间通讯的数据结构，有以下特点：</p>
<ol>
<li>线程安全</li>
<li>创建channel时返回的是指针，不需要考虑拷贝的问题</li>
<li>顺序通讯，写入和读出的顺序一致</li>
</ol>
<h1 id="数据部分"><a href="#数据部分" class="headerlink" title="数据部分"></a>数据部分</h1><p><img src="/images/chan.png"></p>
<p><strong>源码位置go/src/runtime/chan.go</strong></p>
<h2 id="hchan"><a href="#hchan" class="headerlink" title="hchan"></a>hchan</h2><p>channel对应的数据结构</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">	qcount   <span class="keyword">uint</span></span><br><span class="line">	dataqsiz <span class="keyword">uint</span></span><br><span class="line">	buf      unsafe.Pointer</span><br><span class="line">	elemsize <span class="keyword">uint16</span></span><br><span class="line">	closed   <span class="keyword">uint32</span></span><br><span class="line">	elemtype *_type</span><br><span class="line">	sendx    <span class="keyword">uint</span></span><br><span class="line">	recvx    <span class="keyword">uint</span></span><br><span class="line">	recvq    waitq</span><br><span class="line">	sendq    waitq</span><br><span class="line"></span><br><span class="line">	<span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">	<span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Do not change another G&#x27;s status while holding this lock</span></span><br><span class="line">	<span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">	<span class="comment">// with stack shrinking.</span></span><br><span class="line">	lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参数意义"><a href="#参数意义" class="headerlink" title="参数意义"></a>参数意义</h3><p>qcount   uint // 表示channel中元素的个数<br>dataqsiz uint // 表示channel的大小长度<br>buf      unsafe.Pointer // 存储元素的环形队列头指针<br>elemsize uint16 // 表示此channel能存储元素的大小<br>closed   uint32 // channel是否关闭了<br>elemtype *_type // 表示此channel能存储元素的类型<br>sendx    uint // 表示发送操作对应buf的下标，超过dataqsiz之后清0（因为是循环队列嘛）<br>recvx    uint // 表示接收操作对应buf的下标<br>recvq    waitq // 等待接收操作的goroutine队列<br>sendq    waitq // 等待发送操作的goroutine队列</p>
<p>lock mutex // channel的锁</p>
<h2 id="waitq"><a href="#waitq" class="headerlink" title="waitq"></a>waitq</h2><p>用来表示等待发送或者接受的goroutine队列（用sudog表示队列一个节点）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type waitq struct &#123;</span><br><span class="line">	first *sudog</span><br><span class="line">	last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参数意义-1"><a href="#参数意义-1" class="headerlink" title="参数意义"></a>参数意义</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">first goroutine指针，队首指针</span><br><span class="line">last  goroutine指针，队尾指针</span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="enqueue"><a href="#enqueue" class="headerlink" title="enqueue"></a>enqueue</h4><p>两种情况：</p>
<ol>
<li>队列为空，将元素放入队尾将first指针和last指针赋好值</li>
<li>队列不为空，直接将元素放入队尾</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func (q *waitq) enqueue(sgp *sudog) &#123;</span><br><span class="line">	&#x2F;&#x2F; 将goroutine的next置为空</span><br><span class="line">	sgp.next &#x3D; nil</span><br><span class="line">	x :&#x3D; q.last</span><br><span class="line">	if x &#x3D;&#x3D; nil &#123; &#x2F;&#x2F; 如果尾指针为空，说明队列为空，就把这个goroutine放进去</span><br><span class="line">		sgp.prev &#x3D; nil</span><br><span class="line">		q.first &#x3D; sgp</span><br><span class="line">		q.last &#x3D; sgp</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; 直接入队列</span><br><span class="line">	sgp.prev &#x3D; x</span><br><span class="line">	x.next &#x3D; sgp</span><br><span class="line">	q.last &#x3D; sgp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dequeue"><a href="#dequeue" class="headerlink" title="dequeue"></a>dequeue</h4><p>从队列头开始遍历</p>
<ol>
<li>first指针为空，说明队列为空，则直接返回空</li>
<li>如果队列只有一个元素了，将元素取出，并且清空first指针和last指针</li>
<li>队列还有很多元素，直接将first指针对应的元素去除</li>
<li>最后判断如果这个元素(sudog——在channel中用来表示等待接收或者发送的goroutine的)在select结构中并且select结构有其他接口，就跳过，继续遍历下一个节点。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func (q *waitq) dequeue() *sudog &#123;</span><br><span class="line">	for &#123;</span><br><span class="line">		sgp :&#x3D; q.first</span><br><span class="line">		if sgp &#x3D;&#x3D; nil &#123; &#x2F;&#x2F; 头指针为空，说明队列为空，直接返回</span><br><span class="line">			return nil</span><br><span class="line">		&#125;</span><br><span class="line">		y :&#x3D; sgp.next</span><br><span class="line">		if y &#x3D;&#x3D; nil &#123; &#x2F;&#x2F; 如果next指针为空，说明队列就一个元素了，取出这个就空了，就将队列置空</span><br><span class="line">			q.first &#x3D; nil</span><br><span class="line">			q.last &#x3D; nil</span><br><span class="line">		&#125; else &#123; &#x2F;&#x2F; next不为空，就将next作为队首，将原来的队首返回</span><br><span class="line">			y.prev &#x3D; nil</span><br><span class="line">			q.first &#x3D; y</span><br><span class="line">			sgp.next &#x3D; nil &#x2F;&#x2F; mark as removed (see dequeueSudog)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; if a gogoroutine was put on this queue because of a</span><br><span class="line">		&#x2F;&#x2F; select, there is a small window between the gogoroutine</span><br><span class="line">		&#x2F;&#x2F; being woken up by a different case and it grabbing the</span><br><span class="line">		&#x2F;&#x2F; channel locks. Once it has the lock</span><br><span class="line">		&#x2F;&#x2F; it removes itself from the queue, so we won&#39;t see it after that.</span><br><span class="line">		&#x2F;&#x2F; We use a flag in the G struct to tell us when someone</span><br><span class="line">		&#x2F;&#x2F; else has won the race to signal this gogoroutine but the gogoroutine</span><br><span class="line">		&#x2F;&#x2F; hasn&#39;t removed itself from the queue yet.</span><br><span class="line">		&#x2F;&#x2F; 如果goroutine处于select结构中并且select有其他出口就跳过这个</span><br><span class="line">		if sgp.isSelect &amp;&amp; !atomic.Cas(&amp;sgp.g.selectDone, 0, 1) &#123;</span><br><span class="line">			continue</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return sgp</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sudog"><a href="#sudog" class="headerlink" title="sudog"></a>sudog</h2><p>sudog是在等待对channel发送或者接受的goroutine</p>
<p><strong>为什么有了goroutine还要有一个sudog？</strong></p>
<ol>
<li>因为goroutine和等待的channel是多对多的关系，一个goroutine可能在等待多个channel，一个channel也可能有很多goroutine在等待，所以用sudog表示这个等待中的goroutine</li>
<li>sudog是channel等待或者接发送链表的一个node</li>
</ol>
<p><strong>sudog通过acquireSudog创建，releaseSudog销毁</strong></p>
<ol>
<li>在go/src/runtime/proc.go中</li>
<li>go会维护一个全局的缓存（有锁），然后每个调度器（P）有自己的缓存</li>
<li>创建sudog时会先从P的缓存中找，没有就到全局缓存中找，在没有才new一个</li>
<li>销毁sudog的时候先判断P是不是满了，如果满了就将一半缓存放到全局缓存然后再把sudog放到自己缓存</li>
<li>全局缓存的生存周期时两次GC的间隔，go/src/runtime/mgc.go 中clearpools()函数中可以看到，每次GC都会清理全局缓存</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type sudog struct &#123;</span><br><span class="line">	&#x2F;&#x2F; sudog替哪个goroutine在等待</span><br><span class="line">	g *g</span><br><span class="line"></span><br><span class="line">	isSelect bool  &#x2F;&#x2F; 是否在select结构中(select可能取消阻塞发送或接收)</span><br><span class="line">	next     *sudog &#x2F;&#x2F; 下一个节点</span><br><span class="line">	prev     *sudog &#x2F;&#x2F; 上一个节点</span><br><span class="line">	elem     unsafe.Pointer &#x2F;&#x2F; data element (may point to stack)</span><br><span class="line"></span><br><span class="line">	acquiretime int64 &#x2F;&#x2F; 创建时间</span><br><span class="line">	releasetime int64 &#x2F;&#x2F; 释放时间</span><br><span class="line">	ticket      uint32</span><br><span class="line">	parent      *sudog &#x2F;&#x2F; semaRoot binary tree</span><br><span class="line">	waitlink    *sudog &#x2F;&#x2F; g.waiting list or semaRoot</span><br><span class="line">	waittail    *sudog &#x2F;&#x2F; semaRoot</span><br><span class="line">	c           *hchan &#x2F;&#x2F; channel 在等待哪个channel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建sudog——acquireSudog"><a href="#创建sudog——acquireSudog" class="headerlink" title="创建sudog——acquireSudog"></a>创建sudog——acquireSudog</h3><p>大概逻辑就是现在当前goroutine所在调度器(P)的缓存中找，如果没有就从全局缓存中找，如果还没有就new一个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func acquireSudog() *sudog &#123;</span><br><span class="line">	&#x2F;&#x2F; 获得当前goroutine所在的线程(M)</span><br><span class="line">	mp :&#x3D; acquirem()</span><br><span class="line">	&#x2F;&#x2F; 获得当前goroutine所在调度器(P)</span><br><span class="line">	pp :&#x3D; mp.p.ptr()</span><br><span class="line">	if len(pp.sudogcache) &#x3D;&#x3D; 0 &#123; &#x2F;&#x2F; 如果调度器的sudog缓存为空，就从中央缓存找，如果再为空就new一个</span><br><span class="line">		lock(&amp;sched.sudoglock)</span><br><span class="line">		&#x2F;&#x2F; First, try to grab a batch from central cache.</span><br><span class="line">		for len(pp.sudogcache) &lt; cap(pp.sudogcache)&#x2F;2 &amp;&amp; sched.sudogcache !&#x3D; nil &#123;</span><br><span class="line">			s :&#x3D; sched.sudogcache</span><br><span class="line">			sched.sudogcache &#x3D; s.next</span><br><span class="line">			s.next &#x3D; nil</span><br><span class="line">			pp.sudogcache &#x3D; append(pp.sudogcache, s)</span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;sched.sudoglock)</span><br><span class="line">		&#x2F;&#x2F; If the central cache is empty, allocate a new one.</span><br><span class="line">		if len(pp.sudogcache) &#x3D;&#x3D; 0 &#123;</span><br><span class="line">			pp.sudogcache &#x3D; append(pp.sudogcache, new(sudog))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	n :&#x3D; len(pp.sudogcache)</span><br><span class="line">	s :&#x3D; pp.sudogcache[n-1]</span><br><span class="line">	pp.sudogcache[n-1] &#x3D; nil</span><br><span class="line">	pp.sudogcache &#x3D; pp.sudogcache[:n-1]</span><br><span class="line">	if s.elem !&#x3D; nil &#123;</span><br><span class="line">		throw(&quot;acquireSudog: found s.elem !&#x3D; nil in cache&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	releasem(mp)</span><br><span class="line">	return s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="销毁sudog——releaseSudog"><a href="#销毁sudog——releaseSudog" class="headerlink" title="销毁sudog——releaseSudog"></a>销毁sudog——releaseSudog</h3><p>大概逻辑就是如果当前goroutine所在调度器(P)的缓存满了，就将调度器(P)的缓存一半放入全局缓存，然后在把sudog放入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func releaseSudog(s *sudog) &#123;</span><br><span class="line">	&#x2F;&#x2F; 这部分都是check sudog 是否合法</span><br><span class="line">	if s.elem !&#x3D; nil &#123;</span><br><span class="line">		throw(&quot;runtime: sudog with non-nil elem&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	if s.isSelect &#123;</span><br><span class="line">		throw(&quot;runtime: sudog with non-false isSelect&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	if s.next !&#x3D; nil &#123;</span><br><span class="line">		throw(&quot;runtime: sudog with non-nil next&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	if s.prev !&#x3D; nil &#123;</span><br><span class="line">		throw(&quot;runtime: sudog with non-nil prev&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	if s.waitlink !&#x3D; nil &#123;</span><br><span class="line">		throw(&quot;runtime: sudog with non-nil waitlink&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	if s.c !&#x3D; nil &#123;</span><br><span class="line">		throw(&quot;runtime: sudog with non-nil c&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	gp :&#x3D; getg()</span><br><span class="line">	if gp.param !&#x3D; nil &#123;</span><br><span class="line">		throw(&quot;runtime: releaseSudog with non-nil gp.param&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	mp :&#x3D; acquirem() &#x2F;&#x2F; avoid rescheduling to another P</span><br><span class="line">	pp :&#x3D; mp.p.ptr()</span><br><span class="line">	&#x2F;&#x2F; 如果当前调度器的缓存满了，就将一半放入中央缓存</span><br><span class="line">	if len(pp.sudogcache) &#x3D;&#x3D; cap(pp.sudogcache) &#123;</span><br><span class="line">		&#x2F;&#x2F; Transfer half of local cache to the central cache.</span><br><span class="line">		var first, last *sudog</span><br><span class="line">		for len(pp.sudogcache) &gt; cap(pp.sudogcache)&#x2F;2 &#123;</span><br><span class="line">			n :&#x3D; len(pp.sudogcache)</span><br><span class="line">			p :&#x3D; pp.sudogcache[n-1]</span><br><span class="line">			pp.sudogcache[n-1] &#x3D; nil</span><br><span class="line">			pp.sudogcache &#x3D; pp.sudogcache[:n-1]</span><br><span class="line">			if first &#x3D;&#x3D; nil &#123;</span><br><span class="line">				first &#x3D; p</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				last.next &#x3D; p</span><br><span class="line">			&#125;</span><br><span class="line">			last &#x3D; p</span><br><span class="line">		&#125;</span><br><span class="line">		lock(&amp;sched.sudoglock)</span><br><span class="line">		last.next &#x3D; sched.sudogcache</span><br><span class="line">		sched.sudogcache &#x3D; first</span><br><span class="line">		unlock(&amp;sched.sudoglock)</span><br><span class="line">	&#125;</span><br><span class="line">	pp.sudogcache &#x3D; append(pp.sudogcache, s)</span><br><span class="line">	releasem(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h1><h2 id="创建channel"><a href="#创建channel" class="headerlink" title="创建channel"></a>创建channel</h2><p><em>go中所有的channel的创建都会使用make关键字，make(arg1, arg2)函数最终会调用到runtime.makechan和runtime.makechan64，下面讲解go在编译时期是如何做这些事情的</em></p>
<p><a href="https://github.com/golang/go/blob/go1.13.8/src/cmd/compile/internal/gc/typecheck.go">typecheck.go</a><br>编译器会将make(arg1, arg2)转化成OMAKE类型的节点，并在类型检查阶段将OMAKE类型的节点按照arg1的类型转化为OMAKECHAN，OMAKEMAP，OMAKESLICE等类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func typecheck1(n *Node, top int) (res *Node) &#123;</span><br><span class="line">    ...</span><br><span class="line">    switch n.Op &#123;</span><br><span class="line">    ...</span><br><span class="line">    case OMAKE:</span><br><span class="line">        ... </span><br><span class="line">        switch t.Etype &#123;</span><br><span class="line">        ...</span><br><span class="line">        case TCHAN:</span><br><span class="line">            l &#x3D; nil</span><br><span class="line">            if i &lt; len(args) &#123;</span><br><span class="line">                ....</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                n.Left &#x3D; nodintconst(0)</span><br><span class="line">            &#125;</span><br><span class="line">            n.Op &#x3D; OMAKECHAN &#x2F;&#x2F; 节点类型转化为OMAKECHAN</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/golang/go/blob/go1.13.8/src/cmd/compile/internal/gc/walk.go">walk.go</a><br>OMAKECHAN类型的节点最终会在SSA中间代码生成之前被转化成runtime.makechan或者runtime.makechan64</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func walkexpr(n *Node, init *Nodes) *Node &#123;</span><br><span class="line">    ...</span><br><span class="line">    switch n.Op &#123;</span><br><span class="line">    ...</span><br><span class="line">    case OMAKECHAN:</span><br><span class="line">        &#x2F;&#x2F; When size fits into int, use makechan instead of</span><br><span class="line">        &#x2F;&#x2F; makechan64, which is faster and shorter on 32 bit platforms.</span><br><span class="line">        size :&#x3D; n.Left</span><br><span class="line">        fnname :&#x3D; &quot;makechan64&quot;</span><br><span class="line">        argtype :&#x3D; types.Types[TINT64]</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Type checking guarantees that TIDEAL size is positive and fits in an int.</span><br><span class="line">        &#x2F;&#x2F; The case of size overflow when converting TUINT or TUINTPTR to TINT</span><br><span class="line">        &#x2F;&#x2F; will be handled by the negative range checks in makechan during runtime.</span><br><span class="line">        if size.Type.IsKind(TIDEAL) || maxintval[size.Type.Etype].Cmp(maxintval[TUINT]) &lt;&#x3D; 0 &#123;</span><br><span class="line">            fnname &#x3D; &quot;makechan&quot;</span><br><span class="line">            argtype &#x3D; types.Types[TINT]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        n &#x3D; mkcall1(chanfn(fnname, 1, n.Type), n.Type, init, typename(n.Type), conv(size, argtype))</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="makechan64"><a href="#makechan64" class="headerlink" title="makechan64"></a>makechan64</h3><p>check一下size是否是int，然后就执行makechan了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func makechan64(t *chantype, size int64) *hchan &#123;</span><br><span class="line">	if int64(int(size)) !&#x3D; size &#123;</span><br><span class="line">		panic(plainError(&quot;makechan: size out of range&quot;))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return makechan(t, int(size))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="makechan"><a href="#makechan" class="headerlink" title="makechan"></a>makechan</h3><ol>
<li>安全检查: channel能存的元素类型大小是否超过2^16</li>
<li>判断<a href="https://www.cnblogs.com/wuwangchuxin0924/p/12735129.html">hchanSize</a>是否关于maxAlign对齐，判断元素对齐是否maxAlign小，如果大maxAlign就没用了，这里hchanSize设计十分巧妙，位运算神操作优化，可以看另一篇文章<a href="https://www.cnblogs.com/wuwangchuxin0924/p/12735129.html">关于2的n次幂对齐</a></li>
<li>判断申请的空间大小是否uint64大，判断所需空间是否超过最大可申请空间，判断size是否小于0(非法)</li>
<li>然后就是给hchan申请内存空间了<ol>
<li>无缓冲的size=0的，只需要给hchan申请hchansize大小的内存空间即可</li>
<li>有缓冲，但是元素是非指针类型的，就申请hchanSize+mem大小的连续内存空间, 并将hchanSize之后的首地址赋值给buf</li>
<li>有缓冲，并且元素类型是指针的，hchan和底层buf内存就可以分开申请不用连续</li>
</ol>
</li>
<li>给其他变量赋值</li>
<li>返回hchan指针，<strong>注意这里返回的是指针，所以channel在各函数之间传递时，就不是值传递了</strong></li>
</ol>
<p><strong>为什么元素类型是非指针hchan和buf要在一段地址连续的内存中，而指针类型的则可以分开</strong><br>这是源码注释的原话:<br>Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.<br>buf points into the same allocation, elemtype is persistent.<br>SudoG’s are referenced from their owning thread so they can’t be collected.<br>TODO(dvyukov,rlh): Rethink when collector can move allocated objects.<br><strong>猜想:</strong><br>大概意思是，当channel中元素类型不包含指针时，gc时需要回收这段空间的，当channel中元素类型包含指针时，这些指针被自己所在线程引用gc是不能回收，所以当元素不包含指针时申请一段连续的空间可以减小gc的压力</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func makechan(t *chantype, size int) *hchan &#123;</span><br><span class="line">	elem :&#x3D; t.elem</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; compiler checks this but be safe.</span><br><span class="line">	if elem.size &gt;&#x3D; 1&lt;&lt;16 &#123;</span><br><span class="line">		throw(&quot;makechan: invalid channel element type&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	if hchanSize%maxAlign !&#x3D; 0 || elem.align &gt; maxAlign &#123;</span><br><span class="line">		throw(&quot;makechan: bad alignment&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 计算大小需要多少空间，check是否</span><br><span class="line">	&#x2F;&#x2F; 	math.MulUintptr(a, b)函数返回a * b，以及结果是否超过uintptr的最大值</span><br><span class="line">	&#x2F;&#x2F; 判断所需空间是否比uint64大，判断所需空间是否超过最大可申请空间，判断size是否小于0(非法)</span><br><span class="line">	mem, overflow :&#x3D; math.MulUintptr(elem.size, uintptr(size))</span><br><span class="line">	if overflow || mem &gt; maxAlloc-hchanSize || size &lt; 0 &#123;</span><br><span class="line">		panic(plainError(&quot;makechan: size out of range&quot;))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	var c *hchan</span><br><span class="line">	switch &#123;</span><br><span class="line">	case mem &#x3D;&#x3D; 0:</span><br><span class="line">		&#x2F;&#x2F; 就是无缓冲channel，只需要申请hchan需要的大小就行</span><br><span class="line">		c &#x3D; (*hchan)(mallocgc(hchanSize, nil, true))</span><br><span class="line">		c.buf &#x3D; c.raceaddr()</span><br><span class="line">	case elem.ptrdata &#x3D;&#x3D; 0:</span><br><span class="line">		&#x2F;&#x2F; 有缓冲队列channel，但是存放元素不是指针类型的，就要申请hchanSize+这些元素大小的内存空间，然后把申请下来空间首地址赋给buf</span><br><span class="line">		c &#x3D; (*hchan)(mallocgc(hchanSize+mem, nil, true))</span><br><span class="line">		c.buf &#x3D; add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">	default:</span><br><span class="line">		&#x2F;&#x2F; 默认除了给hchan申请内存空间之外还需要申请size个元素大小的内存空间，并且把首地址赋给c.buf</span><br><span class="line">		c &#x3D; new(hchan)</span><br><span class="line">		c.buf &#x3D; mallocgc(mem, elem, true)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.elemsize &#x3D; uint16(elem.size)</span><br><span class="line">	c.elemtype &#x3D; elem</span><br><span class="line">	c.dataqsiz &#x3D; uint(size)</span><br><span class="line"></span><br><span class="line">	if debugChan &#123;</span><br><span class="line">		print(&quot;makechan: chan&#x3D;&quot;, c, &quot;; elemsize&#x3D;&quot;, elem.size, &quot;; elemalg&#x3D;&quot;, elem.alg, &quot;; dataqsiz&#x3D;&quot;, size, &quot;\n&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	return c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h2><p><strong>具体编译时做的转换可参考makechan，代码都在类似的地方</strong></p>
<h3 id="chansend"><a href="#chansend" class="headerlink" title="chansend"></a>chansend</h3><ol>
<li>首先检测channel是否为空, 如果为空直接报错</li>
<li>check是否开启了竞争检测，golang的竞争检测通过ThreadSanitizer库(C++)做的</li>
<li>然后kill掉一些不用加锁就可以判断的情况，如果是非阻塞并且channel未关闭，size = 0或者channel满了, 直接返回false(发送失败)</li>
<li>如果已经有goroutine在等待了，就直接调send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int)发给那个goroutine</li>
<li>如果没有goroutine在等待.</li>
<li>如果channel是非阻塞并且还地方，就放入buffer中，如果没地方了就直接返回false</li>
<li>如果channel是阻塞并且不在select中或者在select中且没有其他出口的，就将创建一个sudog，将sudog初始化并且放入待发送队列(sendq), 并且调用goparkunlock(&amp;c.lock, waitReasonChanSend, traceEvGoBlockSend, 3)使当前goroutine陷入沉睡直到被唤醒(已经发出去了)</li>
<li>清理这个过程的垃圾数据</li>
</ol>
<p><strong>第四步中如果有goroutine在等待就直接发送，会影响非阻塞channel数据的顺序吗？</strong><br>不会，channel的数据由唯一全局锁保护，读写互斥，假设一个goroutine来读channel，只有两种情况:</p>
<ol>
<li>channel buffer中有数据，这时goroutine会直接读取数据，不会被阻塞。</li>
<li>channel buffer中没有数据，这时goroutine会被阻塞。</li>
</ol>
<p>只有当buffer中有数据且有goroutine被阻塞时，顺序才会被打乱，但这两个条件是互斥的，有数据就不可能阻塞，阻塞就不可能有数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; entry point for c &lt;- x from compiled code</span><br><span class="line">&#x2F;&#x2F;go:nosplit</span><br><span class="line">func chansend1(c *hchan, elem unsafe.Pointer) &#123;</span><br><span class="line">	chansend(c, elem, true, getcallerpc())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool &#123;</span><br><span class="line">	&#x2F;&#x2F; 如果c为空</span><br><span class="line">	if c &#x3D;&#x3D; nil &#123;</span><br><span class="line">		&#x2F;&#x2F; 如果是非阻塞的，就是那种有容量的，就返回false写channel失败</span><br><span class="line">		if !block &#123;</span><br><span class="line">			return false</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; 如果是非阻塞的就让当前goroutine停止(这里写个小程序就能看效果，这个goroutine的defer不会执行)</span><br><span class="line">		gopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2)</span><br><span class="line">		throw(&quot;unreachable&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if debugChan &#123;</span><br><span class="line">		print(&quot;chansend: chan&#x3D;&quot;, c, &quot;\n&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if raceenabled &#123; &#x2F;&#x2F; 开启竞争检测</span><br><span class="line">		racereadpc(c.raceaddr(), callerpc, funcPC(chansend))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 先不加锁判断非阻塞channel且没关闭</span><br><span class="line">	&#x2F;&#x2F; 如果size &#x3D; 0或者channel满了, 直接返回false(发送失败)</span><br><span class="line">	if !block &amp;&amp; c.closed &#x3D;&#x3D; 0 &amp;&amp; ((c.dataqsiz &#x3D;&#x3D; 0 &amp;&amp; c.recvq.first &#x3D;&#x3D; nil) ||</span><br><span class="line">		(c.dataqsiz &gt; 0 &amp;&amp; c.qcount &#x3D;&#x3D; c.dataqsiz)) &#123;</span><br><span class="line">		return false</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	var t0 int64</span><br><span class="line">	if blockprofilerate &gt; 0 &#123;</span><br><span class="line">		t0 &#x3D; cputicks()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; channel加锁</span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 如果channel关闭了，就返回panic</span><br><span class="line">	if c.closed !&#x3D; 0 &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		panic(plainError(&quot;send on closed channel&quot;))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 等receive队列的队首中取出一个接收者，如果这个接收者不是nil就绕过buffer直接把ep发给他，并且释放锁</span><br><span class="line">	if sg :&#x3D; c.recvq.dequeue(); sg !&#x3D; nil &#123;</span><br><span class="line">		&#x2F;&#x2F; Found a waiting receiver. We pass the value we want to send</span><br><span class="line">		&#x2F;&#x2F; directly to the receiver, bypassing the channel buffer (if any).</span><br><span class="line">		send(c, sg, ep, func() &#123; unlock(&amp;c.lock) &#125;, 3)</span><br><span class="line">		return true</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; channel还没满就将元素放入buffer</span><br><span class="line">	if c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">		&#x2F;&#x2F; Space is available in the channel buffer. Enqueue the element to send.</span><br><span class="line">		&#x2F;&#x2F; 获取一下发送数据的位置</span><br><span class="line">		qp :&#x3D; chanbuf(c, c.sendx)</span><br><span class="line">		if raceenabled &#123;</span><br><span class="line">			raceacquire(qp)</span><br><span class="line">			racerelease(qp)</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; 将元素拷贝进buffer</span><br><span class="line">		typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">		c.sendx++</span><br><span class="line">		if c.sendx &#x3D;&#x3D; c.dataqsiz &#123; &#x2F;&#x2F; 循环一下</span><br><span class="line">			c.sendx &#x3D; 0</span><br><span class="line">		&#125;</span><br><span class="line">		c.qcount++</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		return true</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 如果是非阻塞channel满了就返回false</span><br><span class="line">	if !block &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		return false</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Block on the channel. Some receiver will complete our operation for us.</span><br><span class="line">	&#x2F;&#x2F; 获取当前goroutine</span><br><span class="line">	gp :&#x3D; getg()</span><br><span class="line">	&#x2F;&#x2F; 创建sudog</span><br><span class="line">	mysg :&#x3D; acquireSudog()</span><br><span class="line">	mysg.releasetime &#x3D; 0</span><br><span class="line">	if t0 !&#x3D; 0 &#123;</span><br><span class="line">		mysg.releasetime &#x3D; -1</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; No stack splits between assigning elem and enqueuing mysg</span><br><span class="line">	&#x2F;&#x2F; on gp.waiting where copystack can find it.</span><br><span class="line">	&#x2F;&#x2F; 完善sudog的信息</span><br><span class="line">	mysg.elem &#x3D; ep</span><br><span class="line">	mysg.waitlink &#x3D; nil</span><br><span class="line">	mysg.g &#x3D; gp</span><br><span class="line">	mysg.isSelect &#x3D; false</span><br><span class="line">	mysg.c &#x3D; c</span><br><span class="line">	gp.waiting &#x3D; mysg</span><br><span class="line">	gp.param &#x3D; nil</span><br><span class="line">	&#x2F;&#x2F; 放入发送列表中</span><br><span class="line">	c.sendq.enqueue(mysg)</span><br><span class="line">	&#x2F;&#x2F; 将当前goroutine陷入沉睡</span><br><span class="line">	goparkunlock(&amp;c.lock, waitReasonChanSend, traceEvGoBlockSend, 3)</span><br><span class="line">	KeepAlive(ep)</span><br><span class="line">	&#x2F;&#x2F; 再次唤醒的时候说明元素已经发送完毕了</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; someone woke us up.</span><br><span class="line">	if mysg !&#x3D; gp.waiting &#123;</span><br><span class="line">		throw(&quot;G waiting list is corrupted&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	gp.waiting &#x3D; nil</span><br><span class="line">	if gp.param &#x3D;&#x3D; nil &#123;</span><br><span class="line">		if c.closed &#x3D;&#x3D; 0 &#123;</span><br><span class="line">			throw(&quot;chansend: spurious wakeup&quot;)</span><br><span class="line">		&#125;</span><br><span class="line">		panic(plainError(&quot;send on closed channel&quot;))</span><br><span class="line">	&#125;</span><br><span class="line">	gp.param &#x3D; nil</span><br><span class="line">	if mysg.releasetime &gt; 0 &#123;</span><br><span class="line">		blockevent(mysg.releasetime-t0, 2)</span><br><span class="line">	&#125;</span><br><span class="line">	mysg.c &#x3D; nil</span><br><span class="line">	releaseSudog(mysg)</span><br><span class="line">	return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="racereadpc"><a href="#racereadpc" class="headerlink" title="racereadpc"></a>racereadpc</h4><p>go/src/runtime/race_amd64.s</p>
<p>PC: 指令计数器寄存器<br>FP: 函数的帧指针，引用函数的参数。使用形如 symbol+offset(FP) 的方式，引用函数的输入参数。例如 arg0+0(FP)，arg1+8(FP)，使用 FP 不加 symbol 时，无法通过编译，在汇编层面来讲，symbol 并没有什么用，加 symbol 主要是为了提升代码可读性。<br>SP: 当前函数栈帧的底部<br>SB: 全局静态基指针，一般用来声明函数或全局变量<br>参数0放在DI通用寄存器<br>参数1放在SI通用寄存器<br>参数2放在DX通用寄存器<br>参数3放在CX通用寄存器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define RARG0 DI</span><br><span class="line">#define RARG1 SI</span><br><span class="line">#define RARG2 DX</span><br><span class="line">#define RARG3 CX</span><br><span class="line">&#x2F;&#x2F; void runtime·racereadpc(void *addr, void *callpc, void *pc)</span><br><span class="line">TEXT    runtime·racereadpc(SB), NOSPLIT, $0-24</span><br><span class="line">        MOVQ    addr+0(FP), RARG1</span><br><span class="line">        MOVQ    callpc+8(FP), RARG2</span><br><span class="line">        MOVQ    pc+16(FP), RARG3</span><br><span class="line">        ADDQ    $1, RARG3 &#x2F;&#x2F; pc is function start, tsan wants return address</span><br><span class="line">        &#x2F;&#x2F; void __tsan_read_pc(ThreadState *thr, void *addr, void *callpc, void *pc);</span><br><span class="line"></span><br><span class="line">        MOVQ    $__tsan_read_pc(SB), AX</span><br><span class="line">        JMP     racecalladdr&lt;&gt;(SB)</span><br></pre></td></tr></table></figure>

<h4 id="send"><a href="#send" class="headerlink" title="send"></a>send</h4><p>用于给goroutine直接发送数据</p>
<ol>
<li>如果数据没问题就直接将数据拷贝到x := &lt;- c表达式x的内存地址上</li>
<li>然后将该goroutine放到处理器(P)的runnext上面等待执行，这里不是直接让goroutine执行，而是等下一次调度的时候直接调这个goroutine</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) &#123;</span><br><span class="line">	if raceenabled &#123;</span><br><span class="line">		if c.dataqsiz &#x3D;&#x3D; 0 &#123;</span><br><span class="line">			racesync(c, sg)</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			qp :&#x3D; chanbuf(c, c.recvx)</span><br><span class="line">			raceacquire(qp)</span><br><span class="line">			racerelease(qp)</span><br><span class="line">			raceacquireg(sg.g, qp)</span><br><span class="line">			racereleaseg(sg.g, qp)</span><br><span class="line">			c.recvx++</span><br><span class="line">			if c.recvx &#x3D;&#x3D; c.dataqsiz &#123;</span><br><span class="line">				c.recvx &#x3D; 0</span><br><span class="line">			&#125;</span><br><span class="line">			c.sendx &#x3D; c.recvx &#x2F;&#x2F; c.sendx &#x3D; (c.sendx+1) % c.dataqsiz</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if sg.elem !&#x3D; nil &#123; &#x2F;&#x2F; 如果元素没问题就将发送的数据拷贝到x :&#x3D; &lt;- c表达式x所在内存地址上</span><br><span class="line">		sendDirect(c.elemtype, sg, ep)</span><br><span class="line">		sg.elem &#x3D; nil</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; 然后将将该goroutine放到处理器(P)的runnext上面等待执行，这里不是直接让goroutine执行，而是等下一次调度的时候直接调这个goroutine</span><br><span class="line">	gp :&#x3D; sg.g</span><br><span class="line">	unlockf()</span><br><span class="line">	gp.param &#x3D; unsafe.Pointer(sg)</span><br><span class="line">	if sg.releasetime !&#x3D; 0 &#123;</span><br><span class="line">		sg.releasetime &#x3D; cputicks()</span><br><span class="line">	&#125;</span><br><span class="line">	goready(gp, skip+1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h2><p><strong>具体编译时做的转换可参考makechan，代码都在类似的地方</strong></p>
<h3 id="chanrecv"><a href="#chanrecv" class="headerlink" title="chanrecv"></a>chanrecv</h3><p>两种接收方式：<br>chanrecv1是丢弃channel出来的元素，类似 &lt;- c这中表达式<br>chanrecv2是使用channel出来的元素，类似 elem := &lt;- c<br>最终都会调用到chanrecv</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; entry points for &lt;- c from compiled code</span><br><span class="line">&#x2F;&#x2F;go:nosplit</span><br><span class="line">func chanrecv1(c *hchan, elem unsafe.Pointer) &#123;</span><br><span class="line">	chanrecv(c, elem, true)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;go:nosplit</span><br><span class="line">func chanrecv2(c *hchan, elem unsafe.Pointer) (received bool) &#123;</span><br><span class="line">	_, received &#x3D; chanrecv(c, elem, true)</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>判断chan是否为nil，如果是直接报错</li>
<li>kill掉一些不用枷锁就可以判断的情况，如果是非阻塞并且队列为空并且channel未关闭就返回false</li>
<li>如果channel已经关闭了，就清空ep中的数据，立即返回</li>
<li>如果已经有sendq在等待了(发送端提到过，如果没有goroutine等待接受，就加入sendq), 就直接接收这个元素</li>
<li>如果此时没有goroutine等待发送</li>
<li>如果是非阻塞且buffer中有数据直接从buffer中取出，如果没有数据直接返回false</li>
<li>如果是阻塞的且当前goroutine没在select中或者在select中但没有其他出口，就把自己加入recvq，然后调用goparkunlock(&amp;c.lock, waitReasonChanReceive, traceEvGoBlockRecv, 3)，等待被唤醒（如果被唤醒说明有有数据来了)</li>
<li>清理这个过程中的垃圾数据</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) &#123;</span><br><span class="line">	if debugChan &#123;</span><br><span class="line">		print(&quot;chanrecv: chan&#x3D;&quot;, c, &quot;\n&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; channel为空就使goroutine 停止并报错</span><br><span class="line">	if c &#x3D;&#x3D; nil &#123;</span><br><span class="line">		if !block &#123;</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">		gopark(nil, nil, waitReasonChanReceiveNilChan, traceEvGoStop, 2)</span><br><span class="line">		throw(&quot;unreachable&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 如果是非阻塞并且队列为空并且channel未关闭就返回false</span><br><span class="line">	if !block &amp;&amp; (c.dataqsiz &#x3D;&#x3D; 0 &amp;&amp; c.sendq.first &#x3D;&#x3D; nil ||</span><br><span class="line">		c.dataqsiz &gt; 0 &amp;&amp; atomic.Loaduint(&amp;c.qcount) &#x3D;&#x3D; 0) &amp;&amp;</span><br><span class="line">		atomic.Load(&amp;c.closed) &#x3D;&#x3D; 0 &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	var t0 int64</span><br><span class="line">	if blockprofilerate &gt; 0 &#123;</span><br><span class="line">		t0 &#x3D; cputicks()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 如果channel已关闭, 并且没有数据了就清除ep中的数据立刻返回</span><br><span class="line">	if c.closed !&#x3D; 0 &amp;&amp; c.qcount &#x3D;&#x3D; 0 &#123;</span><br><span class="line">		if raceenabled &#123;</span><br><span class="line">			raceacquire(c.raceaddr())</span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		if ep !&#x3D; nil &#123;</span><br><span class="line">			typedmemclr(c.elemtype, ep)</span><br><span class="line">		&#125;</span><br><span class="line">		return true, false</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 如果已经有goroutine等着了，就直接让这个goroutine recive</span><br><span class="line">	if sg :&#x3D; c.sendq.dequeue(); sg !&#x3D; nil &#123;</span><br><span class="line">		recv(c, sg, ep, func() &#123; unlock(&amp;c.lock) &#125;, 3)</span><br><span class="line">		return true, true</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; channel不为空将元素复制到ep中(ep :&#x3D; &lt;- c)</span><br><span class="line">	if c.qcount &gt; 0 &#123;</span><br><span class="line">		&#x2F;&#x2F; Receive directly from queue</span><br><span class="line">		qp :&#x3D; chanbuf(c, c.recvx)</span><br><span class="line">		if raceenabled &#123;</span><br><span class="line">			raceacquire(qp)</span><br><span class="line">			racerelease(qp)</span><br><span class="line">		&#125;</span><br><span class="line">		if ep !&#x3D; nil &#123;</span><br><span class="line">			typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">		&#125;</span><br><span class="line">		typedmemclr(c.elemtype, qp)</span><br><span class="line">		c.recvx++</span><br><span class="line">		if c.recvx &#x3D;&#x3D; c.dataqsiz &#123;</span><br><span class="line">			c.recvx &#x3D; 0</span><br><span class="line">		&#125;</span><br><span class="line">		c.qcount--</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		return true, true</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 如果是非阻塞直接返回false</span><br><span class="line">	if !block &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		return false, false</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 获取当前goroutine</span><br><span class="line">	gp :&#x3D; getg()</span><br><span class="line">	&#x2F;&#x2F; 创建sudog</span><br><span class="line">	mysg :&#x3D; acquireSudog()</span><br><span class="line">	mysg.releasetime &#x3D; 0</span><br><span class="line">	if t0 !&#x3D; 0 &#123;</span><br><span class="line">		mysg.releasetime &#x3D; -1</span><br><span class="line">	&#125;</span><br><span class="line">	mysg.elem &#x3D; ep</span><br><span class="line">	mysg.waitlink &#x3D; nil</span><br><span class="line">	gp.waiting &#x3D; mysg</span><br><span class="line">	mysg.g &#x3D; gp</span><br><span class="line">	mysg.isSelect &#x3D; false</span><br><span class="line">	mysg.c &#x3D; c</span><br><span class="line">	gp.param &#x3D; nil</span><br><span class="line">	c.recvq.enqueue(mysg)</span><br><span class="line">	goparkunlock(&amp;c.lock, waitReasonChanReceive, traceEvGoBlockRecv, 3)</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; someone woke us up</span><br><span class="line">	if mysg !&#x3D; gp.waiting &#123;</span><br><span class="line">		throw(&quot;G waiting list is corrupted&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	gp.waiting &#x3D; nil</span><br><span class="line">	if mysg.releasetime &gt; 0 &#123;</span><br><span class="line">		blockevent(mysg.releasetime-t0, 2)</span><br><span class="line">	&#125;</span><br><span class="line">	closed :&#x3D; gp.param &#x3D;&#x3D; nil</span><br><span class="line">	gp.param &#x3D; nil</span><br><span class="line">	mysg.c &#x3D; nil</span><br><span class="line">	releaseSudog(mysg)</span><br><span class="line">	return true, !closed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关闭channel"><a href="#关闭channel" class="headerlink" title="关闭channel"></a>关闭channel</h2><p>关闭channel大概逻辑就是，将buffer中的数据都释放掉，然后close设置为0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func closechan(c *hchan) &#123;</span><br><span class="line">	&#x2F;&#x2F; 如果为空抛出异常</span><br><span class="line">	if c &#x3D;&#x3D; nil &#123;</span><br><span class="line">		panic(plainError(&quot;close of nil channel&quot;))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line">	&#x2F;&#x2F; 如果channel已经关闭就抛出异常</span><br><span class="line">	if c.closed !&#x3D; 0 &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		panic(plainError(&quot;close of closed channel&quot;))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if raceenabled &#123;</span><br><span class="line">		callerpc :&#x3D; getcallerpc()</span><br><span class="line">		racewritepc(c.raceaddr(), callerpc, funcPC(closechan))</span><br><span class="line">		racerelease(c.raceaddr())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.closed &#x3D; 1</span><br><span class="line"></span><br><span class="line">	var glist gList</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 清理所有的数据</span><br><span class="line">	&#x2F;&#x2F; release all readers</span><br><span class="line">	for &#123;</span><br><span class="line">		sg :&#x3D; c.recvq.dequeue()</span><br><span class="line">		if sg &#x3D;&#x3D; nil &#123;</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">		if sg.elem !&#x3D; nil &#123;</span><br><span class="line">			typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">			sg.elem &#x3D; nil</span><br><span class="line">		&#125;</span><br><span class="line">		if sg.releasetime !&#x3D; 0 &#123;</span><br><span class="line">			sg.releasetime &#x3D; cputicks()</span><br><span class="line">		&#125;</span><br><span class="line">		gp :&#x3D; sg.g</span><br><span class="line">		gp.param &#x3D; nil</span><br><span class="line">		if raceenabled &#123;</span><br><span class="line">			raceacquireg(gp, c.raceaddr())</span><br><span class="line">		&#125;</span><br><span class="line">		glist.push(gp)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; release all writers (they will panic)</span><br><span class="line">	for &#123;</span><br><span class="line">		sg :&#x3D; c.sendq.dequeue()</span><br><span class="line">		if sg &#x3D;&#x3D; nil &#123;</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">		sg.elem &#x3D; nil</span><br><span class="line">		if sg.releasetime !&#x3D; 0 &#123;</span><br><span class="line">			sg.releasetime &#x3D; cputicks()</span><br><span class="line">		&#125;</span><br><span class="line">		gp :&#x3D; sg.g</span><br><span class="line">		gp.param &#x3D; nil</span><br><span class="line">		if raceenabled &#123;</span><br><span class="line">			raceacquireg(gp, c.raceaddr())</span><br><span class="line">		&#125;</span><br><span class="line">		glist.push(gp)</span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Ready all Gs now that we&#39;ve dropped the channel lock.</span><br><span class="line">	for !glist.empty() &#123;</span><br><span class="line">		gp :&#x3D; glist.pop()</span><br><span class="line">		gp.schedlink &#x3D; 0</span><br><span class="line">		goready(gp, 3)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="chan-dot"><a href="#chan-dot" class="headerlink" title="chan.dot"></a>chan.dot</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">digraph &#123;</span><br><span class="line">    bgcolor&#x3D;&quot;#C6CFD532&quot;; </span><br><span class="line"></span><br><span class="line">    node [shape&#x3D;record, fontsize&#x3D;&quot;8&quot;, margin&#x3D;&quot;0.04&quot;, height&#x3D;0.2, color&#x3D;gray] </span><br><span class="line">	edge [fontname&#x3D;&quot;Inconsolata, Consolas&quot;, fontsize&#x3D;10, arrowhead&#x3D;normal]</span><br><span class="line"></span><br><span class="line">    hchan [shape&#x3D;record,label&#x3D;&quot;&#123;qcount|dataqsiz|buf|elemsize|closed|elemtype|&lt;sendx&gt;sendx|&lt;recvx&gt;recvx|recvq|sendq|lock&#125;&quot;,xlabel&#x3D;&quot;hchan&quot;]</span><br><span class="line">    waitq[shape&#x3D;record,label&#x3D;&quot;&#123;&lt;first&gt;first|&lt;last&gt;last&#125;&quot;,xlabel&#x3D;&quot;waitq&quot;]</span><br><span class="line">    sudog[shape&#x3D;record,label&#x3D;&quot;&#123;g|isSelect|next|prev|elem|acquiretime|releasetime|ticket|parent|waitlink|waittail|c&#125;&quot;,xlabel&#x3D;&quot;sudog&quot;]</span><br><span class="line"></span><br><span class="line">    hchan:sendx -&gt; waitq [label&#x3D;&quot;发送队列&quot;]</span><br><span class="line">    hchan:recvx -&gt; waitq [label&#x3D;&quot;接收队列&quot;]</span><br><span class="line">    waitq:first -&gt; sudog</span><br><span class="line">    waitq:last -&gt; sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>语言</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>goroutine 源码阅读</title>
    <url>/2020/10/21/goroutine%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>调度相关的数据结构有三个，M(线程)，P(调度器)，G(goroutine)<br>M表示线程，P作为调度器用来帮助每个线程管理自己的goroutine，G就是golang的协程。我们可以通过runtime.GOMAXPROCS(n int)函数设置P的个数，<strong>注意</strong>P的个数并不代表M的个数，例如程序启动时runtime代码会出实话procs个P，但开始的时候只会启动一个M，就是M0和一个栈为64K(其他goroutine默认初始栈大小2K)来执行runtime代码。</p>
<a id="more"></a>

<p><strong>那其他线程是什么时候创建的呐?</strong><br>当goroutine被唤醒时，要在M上运行(恢复goroutine的上下文)，P是帮助M管理goroutine的，恢复上下文的操作也由P来完成。如果被唤醒时发现还有空闲的P，并且没有其他M在窃取goroutine(M发现本地goroutine队列和全局goroutine队列都没有goroutine的时候，会去其他线程窃取goroutine)，说明其他M都在忙，就会创建一个M让这个空闲的P帮他来管理goroutine。<br>总之一句话，开始的时候创建一个M，当发现调度不过来且还有空闲P没有工作就在创建新的，直到创建procs个M(procs通过runtime.GOMAXPROCS设置)</p>
<p><img src="/images/model.png" alt="model"></p>
<h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><p>golang 用结构体g表示goroutine</p>
<h3 id="g"><a href="#g" class="headerlink" title="g"></a>g</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">	stack       stack   <span class="comment">// 当前栈的范围[stack.lo, stack.hi)</span></span><br><span class="line">	stackguard0 <span class="keyword">uintptr</span> <span class="comment">// 用于抢占的，一般情况值为stack.lo + StackGuard</span></span><br><span class="line">	stackguard1 <span class="keyword">uintptr</span> <span class="comment">// 用于C语言的抢占</span></span><br><span class="line">	_panic         *_panic <span class="comment">// 最内侧的panic函数</span></span><br><span class="line">	_defer         *_defer <span class="comment">// 最外侧的defer函数</span></span><br><span class="line">	m              *m      <span class="comment">// 当前goroutine属于哪个m</span></span><br><span class="line">	sched          gobuf <span class="comment">// 调度相关信息</span></span><br><span class="line">	...</span><br><span class="line">	schedlink      guintptr <span class="comment">// sched是全局的goroutine链表，schedlink表示这个goroutine在链表中的下一个goroutine的指针</span></span><br><span class="line">	...</span><br><span class="line">	preempt        <span class="keyword">bool</span>       <span class="comment">// 抢占标志，如果需要抢占就将preempt设置为true</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gobuf"><a href="#gobuf" class="headerlink" title="gobuf"></a>gobuf</h3><p>gobuf保存goroutine的调度信息，当一个goroutine被调度的时，本质上就是把这个goroutine放到cpu，恢复各个寄存器的值，然后运行</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> gobuf <span class="keyword">struct</span> &#123;</span><br><span class="line">	sp   <span class="keyword">uintptr</span> <span class="comment">// 栈指针</span></span><br><span class="line">	pc   <span class="keyword">uintptr</span> <span class="comment">// 程序计数器</span></span><br><span class="line">	g    guintptr <span class="comment">// 当前被哪个goroutine持有</span></span><br><span class="line">	ctxt unsafe.Pointer</span><br><span class="line">	ret  sys.Uintreg <span class="comment">// 系统调用返回值，防止系统调用后被其他goroutine抢占，所以有个地方保存返回值</span></span><br><span class="line">	lr   <span class="keyword">uintptr</span></span><br><span class="line">	bp   <span class="keyword">uintptr</span> <span class="comment">// 保存CPU的rip寄存器的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="M"><a href="#M" class="headerlink" title="M"></a>M</h2><p>golang中M表示实际操作系统的线程</p>
<h3 id="m"><a href="#m" class="headerlink" title="m"></a>m</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;</span><br><span class="line">	g0      *g     <span class="comment">// g0帮M处理大小事务的goroutine，他是m中的第一个goroutine</span></span><br><span class="line">	...</span><br><span class="line">	gsignal       *g           <span class="comment">// 用于信号处理的goroutine</span></span><br><span class="line">	tls           [<span class="number">6</span>]<span class="keyword">uintptr</span>   <span class="comment">// 线程私有空间</span></span><br><span class="line">	mstartfn      <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">	curg          *g       <span class="comment">// current running goroutine</span></span><br><span class="line">	...</span><br><span class="line">	p             puintptr <span class="comment">// 当前正在运行的p(处理器)</span></span><br><span class="line">	nextp         puintptr <span class="comment">// 暂存的p</span></span><br><span class="line">	oldp          puintptr <span class="comment">// 执行系统调用之前的p</span></span><br><span class="line">	...</span><br><span class="line">	spinning      <span class="keyword">bool</span> <span class="comment">// 表示当前m没有goroutine了，正在从其他m偷取goroutine</span></span><br><span class="line">	blocked       <span class="keyword">bool</span> <span class="comment">// m is blocked on a note</span></span><br><span class="line">	...</span><br><span class="line">	park          note <span class="comment">// m没有goroutine的时候会在park上sleep，需要其他m在park中wake up这个m</span></span><br><span class="line">	alllink       *m <span class="comment">// on allm // 所有m的链表</span></span><br><span class="line">	...</span><br><span class="line">	thread        <span class="keyword">uintptr</span> <span class="comment">// thread handle</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P"><a href="#P" class="headerlink" title="P"></a>P</h2><p>golang中P表示一个调度器，为M提供上下文环境，使得M可以执行多个goroutine</p>
<h3 id="p"><a href="#p" class="headerlink" title="p"></a>p</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">	m           muintptr   <span class="comment">// 与哪个M关联(可能为空的)</span></span><br><span class="line">	...</span><br><span class="line">	runqhead <span class="keyword">uint32</span> <span class="comment">// p本地goroutine队列的头</span></span><br><span class="line">	runqtail <span class="keyword">uint32</span> <span class="comment">// p本地goroutine队列的尾</span></span><br><span class="line">	runq     [<span class="number">256</span>]guintptr <span class="comment">// 队列指针，和sync.pool中数据结构一样也是循环队列</span></span><br><span class="line">	...</span><br><span class="line">	sudogcache []*sudog <span class="comment">// sudog缓存，channel用的</span></span><br><span class="line">	sudogbuf   [<span class="number">128</span>]*sudog <span class="comment">// 也是防止false sharing</span></span><br><span class="line">	...</span><br><span class="line">	pad cpu.CacheLinePad <span class="comment">// 防止false sharing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="schedt"><a href="#schedt" class="headerlink" title="schedt"></a>schedt</h2><p>schedt结构体用来保存P的状态信息和goroutine的全局运行队列</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> schedt <span class="keyword">struct</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	lock mutex <span class="comment">// 全局锁</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 维护空闲的M</span></span><br><span class="line">	midle        muintptr <span class="comment">// 等待中的M链表</span></span><br><span class="line">	nmidle       <span class="keyword">int32</span>    <span class="comment">// 等待中的M的数量</span></span><br><span class="line">	nmidlelocked <span class="keyword">int32</span>    <span class="comment">// number of locked m&#x27;s waiting for work</span></span><br><span class="line">	mnext        <span class="keyword">int64</span>    <span class="comment">// number of m&#x27;s that have been created and next M ID</span></span><br><span class="line">	maxmcount    <span class="keyword">int32</span>    <span class="comment">// 最多创建多少个M(10000)</span></span><br><span class="line">	nmsys        <span class="keyword">int32</span>    <span class="comment">// number of system m&#x27;s not counted for deadlock</span></span><br><span class="line">	nmfreed      <span class="keyword">int64</span>    <span class="comment">// cumulative number of freed m&#x27;s</span></span><br><span class="line"></span><br><span class="line">	ngsys <span class="keyword">uint32</span> <span class="comment">// number of system goroutines; updated atomically</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 维护空闲的P</span></span><br><span class="line">	pidle      puintptr <span class="comment">// idle p&#x27;s</span></span><br><span class="line">	npidle     <span class="keyword">uint32</span></span><br><span class="line">	nmspinning <span class="keyword">uint32</span> <span class="comment">// See &quot;Worker thread parking/unparking&quot; comment in proc.go.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// goroutine的全局队列</span></span><br><span class="line">	runq     gQueue</span><br><span class="line">	runqsize <span class="keyword">int32</span></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 全局缓存已经退出的goroutine链表，下次再创建的时候直接用</span></span><br><span class="line">	<span class="comment">// Global cache of dead G&#x27;s.</span></span><br><span class="line">	gFree <span class="keyword">struct</span> &#123;</span><br><span class="line">		lock    mutex</span><br><span class="line">		stack   gList <span class="comment">// Gs with stacks</span></span><br><span class="line">		noStack gList <span class="comment">// Gs without stacks</span></span><br><span class="line">		n       <span class="keyword">int32</span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重要的全局变量"><a href="#重要的全局变量" class="headerlink" title="重要的全局变量"></a>重要的全局变量</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">allgs    []*g   <span class="comment">// 保存所有的g</span></span><br><span class="line">allm     *m     <span class="comment">// 所有的m构成的一个链表，包括下面的m0</span></span><br><span class="line">allp     []*p  <span class="comment">// 保存所有的p，len(allp) == gomaxprocs</span></span><br><span class="line"></span><br><span class="line">ncpu         <span class="keyword">int32</span>  <span class="comment">// 系统中cpu核的数量，程序启动时由runtime代码初始化</span></span><br><span class="line">gomaxprocs   <span class="keyword">int32</span>  <span class="comment">// p的最大值，默认等于ncpu，但可以通过GOMAXPROCS修改</span></span><br><span class="line"></span><br><span class="line">sched     schedt    <span class="comment">// 调度器结构体对象，记录了调度器的工作状态</span></span><br><span class="line"></span><br><span class="line">m0 m        <span class="comment">// 代表进程的主线程</span></span><br><span class="line">g0  g       <span class="comment">// m0的g0，也就是m0.g0 = &amp;g0</span></span><br></pre></td></tr></table></figure>

<h1 id="分步骤剖析调度的初始化"><a href="#分步骤剖析调度的初始化" class="headerlink" title="分步骤剖析调度的初始化"></a>分步骤剖析调度的初始化</h1><p>下面是用go实现的hello world，代码里并没有关于调度的初始化，所以程序的入口并非是main.main，下面通过gdb一步步找到go是如何初始化调度的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;hello, world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go build -gcflags &quot;-N -l&quot; test.go</span><br></pre></td></tr></table></figure>

<p><strong>使用OS X的同学注意，go1.11之后压缩的debug信息，OS X的同学需要同时做以下设置参考<a href="https://stackoverflow.com/questions/52534287/debug-go-program-with-gdb-on-macos">Debug Go Program With Gdb On Macos</a></strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export GOFLAGS=&quot;-ldflags=-compressdwarf=false&quot;</span><br></pre></td></tr></table></figure>

<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><ul>
<li>利用断点可以找出目标文件的信息，在入口处打一个断点，找到程序入口在rt0_darwin_amd64.s的第8行</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  sudo gdb test </span><br><span class="line">(gdb) info files</span><br><span class="line">Symbols from &quot;/Users/journey/workspace/src/tool/gdb/test&quot;.</span><br><span class="line">Local exec file:</span><br><span class="line">	`/Users/journey/workspace/src/tool/gdb/test&#x27;, file type mach-o-x86-64.</span><br><span class="line">	Entry point: 0x104cd00</span><br><span class="line">	0x0000000001001000 - 0x00000000010515b1 is .text</span><br><span class="line">	0x00000000010515c0 - 0x000000000108162a is __TEXT.__rodata</span><br><span class="line">	0x0000000001081640 - 0x0000000001081706 is __TEXT.__symbol_stub1</span><br><span class="line">	0x0000000001081720 - 0x0000000001081e80 is __TEXT.__typelink</span><br><span class="line">	0x0000000001081e80 - 0x0000000001081e88 is __TEXT.__itablink</span><br><span class="line">	0x0000000001081e88 - 0x0000000001081e88 is __TEXT.__gosymtab</span><br><span class="line">	0x0000000001081ea0 - 0x00000000010bfacd is __TEXT.__gopclntab</span><br><span class="line">	0x00000000010c0000 - 0x00000000010c0020 is __DATA.__go_buildinfo</span><br><span class="line">	0x00000000010c0020 - 0x00000000010c0128 is __DATA.__nl_symbol_ptr</span><br><span class="line">	0x00000000010c0140 - 0x00000000010c0d08 is __DATA.__noptrdata</span><br><span class="line">	0x00000000010c0d20 - 0x00000000010c27f0 is .data</span><br><span class="line">	0x00000000010c2800 - 0x00000000010ddc90 is .bss</span><br><span class="line">	0x00000000010ddca0 - 0x00000000010e01e8 is __DATA.__noptrbss</span><br><span class="line">(gdb) b *0x104cd00</span><br><span class="line">Breakpoint 1 at 0x104cd00: file /usr/local/go/src/runtime/rt0_darwin_amd64.s, line 8.</span><br></pre></td></tr></table></figure>

<ul>
<li>进入上面找到的文件rt0_darwin_amd64.s(不同的架构文件是不同的)</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  runtime ls rt0_*</span><br><span class="line">rt0_aix_ppc64.s       rt0_darwin_amd64.s    rt0_freebsd_arm.s     rt0_linux_arm64.s     rt0_nacl_386.s        rt0_netbsd_arm64.s    rt0_plan9_amd64.s</span><br><span class="line">rt0_android_386.s     rt0_darwin_arm.s      rt0_illumos_amd64.s   rt0_linux_mips64x.s   rt0_nacl_amd64p32.s   rt0_openbsd_386.s     rt0_plan9_arm.s</span><br><span class="line">rt0_android_amd64.s   rt0_darwin_arm64.s    rt0_js_wasm.s         rt0_linux_mipsx.s     rt0_nacl_arm.s        rt0_openbsd_amd64.s   rt0_solaris_amd64.s</span><br><span class="line">rt0_android_arm.s     rt0_dragonfly_amd64.s rt0_linux_386.s       rt0_linux_ppc64.s     rt0_netbsd_386.s      rt0_openbsd_arm.s     rt0_windows_386.s</span><br><span class="line">rt0_android_arm64.s   rt0_freebsd_386.s     rt0_linux_amd64.s     rt0_linux_ppc64le.s   rt0_netbsd_amd64.s    rt0_openbsd_arm64.s   rt0_windows_amd64.s</span><br><span class="line">rt0_darwin_386.s      rt0_freebsd_amd64.s   rt0_linux_arm.s       rt0_linux_s390x.s     rt0_netbsd_arm.s      rt0_plan9_386.s       rt0_windows_arm.s</span><br></pre></td></tr></table></figure>

<ul>
<li>打开文件go/src/runtime/rt0_darwin_amd64.s:8<br>这里没有做什么就调了函数_rt0_amd64</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">TEXT _rt0_amd64_darwin(SB),NOSPLIT,$<span class="number">-8</span> <span class="comment">// 参数+返回值共8字节</span></span><br><span class="line">	JMP	_rt0_amd64(SB)</span><br></pre></td></tr></table></figure>

<ul>
<li>然后在打断点看看_rt0_amd64在哪<br>在ams_amd64.s第15行</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) b _rt0_amd64</span><br><span class="line">Breakpoint 2 at 0x1049350: file /usr/local/go/src/runtime/asm_amd64.s, line 15.</span><br></pre></td></tr></table></figure>

<p>这里首先把参数放到DI，SI寄存器中，然后调用runtime.rt0_go，这就是进程初始化主要函数了<br>参数0放在DI通用寄存器<br>参数1放在SI通用寄存器<br>参数2放在DX通用寄存器<br>参数3放在CX通用寄存器</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">TEXT _rt0_amd64(SB),NOSPLIT,$<span class="number">-8</span> <span class="comment">// 参数+返回值共8字节</span></span><br><span class="line">	MOVQ	<span class="number">0</span>(SP), DI	<span class="comment">// argc</span></span><br><span class="line">	LEAQ	<span class="number">8</span>(SP), SI	<span class="comment">// argv</span></span><br><span class="line">	JMP	runtime·rt0_go(SB)</span><br></pre></td></tr></table></figure>

<ul>
<li>然后跳转到runtime.rt0_go</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) b runtime.rt0_go</span><br><span class="line">Breakpoint 3 at 0x1049360: file /usr/local/go/src/runtime/asm_amd64.s, line 89.</span><br></pre></td></tr></table></figure>

<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>这个函数有点长，下面我们分段来看rt0_go这个函数</p>
<h3 id="初始化参数以及创建g0"><a href="#初始化参数以及创建g0" class="headerlink" title="初始化参数以及创建g0"></a>初始化参数以及创建g0</h3><ol>
<li>首先将之前放入通用寄存器的参数放入AX，BX寄存器，然后调整栈顶指针(真SP寄存器)的位置，SP指针先减39，关于16字节向下对齐(因为CPU有一组 SSE 指令，这些指令中出现的内存地址必须是16的倍数)，然后把参数放到SP+16字节和SP+24字节处</li>
</ol>
<p><strong>golang的汇编有抽象出来的寄存器，通过是否有前缀变量区分真假寄存器，例如a+8(SP)就是golang的寄存器，8(SP)就是真的寄存器</strong></p>
<ol start="2">
<li>创建g0，并初始化g.stackgruard0，g.stackguard1以及g.stack.lo，g.stack.hi的值(实际上是分配一段内存，然后分割成小段，约定哪小段表示哪个变量)</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">TEXT runtime·rt0_go(SB),NOSPLIT,$<span class="number">0</span></span><br><span class="line">	MOVQ	DI, AX		<span class="comment">// argc</span></span><br><span class="line">	MOVQ	SI, BX		<span class="comment">// argv</span></span><br><span class="line">	SUBQ	$(<span class="number">4</span>*<span class="number">8</span>+<span class="number">7</span>), SP		<span class="comment">// 2args 2auto</span></span><br><span class="line">	ANDQ	$~<span class="number">15</span>, SP</span><br><span class="line">	MOVQ	AX, <span class="number">16</span>(SP)</span><br><span class="line">	MOVQ	BX, <span class="number">24</span>(SP)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化g0，g0就是go的第一个协程</span></span><br><span class="line">	<span class="comment">// 给g0分配栈空间大概64K</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	MOVQ	$runtime·g0(SB), DI</span><br><span class="line">	LEAQ	(<span class="number">-64</span>*<span class="number">1024</span>+<span class="number">104</span>)(SP), BX <span class="comment">// BX = SP - 64 * 1024 + 104</span></span><br><span class="line">	MOVQ	BX, g_stackguard0(DI) <span class="comment">// g0.g_stackguard0 = SP - 64 * 1024 + 104</span></span><br><span class="line">	MOVQ	BX, g_stackguard1(DI) <span class="comment">// g0.g_stackguard1 = SP - 64 * 1024 + 104</span></span><br><span class="line">	MOVQ	BX, (g_stack+stack_lo)(DI) <span class="comment">// g0.stack.lo = SP - 64 * 1024 + 104</span></span><br><span class="line">	MOVQ	SP, (g_stack+stack_hi)(DI) <span class="comment">// g0.stack.hi = SP</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建完g0的内存分布</p>
<p><img src="/images/stack_0.png" alt="stack_0"></p>
<p>然后略过一段CPU型号检测和CGO初始化的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="创建m0"><a href="#创建m0" class="headerlink" title="创建m0"></a>创建m0</h3><ol>
<li>创建将m0.tls放入DI寄存器，然后调用runtime.settls将m0设置为线程私有变量(mac下什么也没干)，将m0与主线程绑定，然后对m0.tls进行存取操作验证是否能用，不能用就直接退出</li>
<li>绑定m0和g0的关系，m0.g0 = g0，g0.m = m0</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">	<span class="comment">// 将m0与主线程绑定</span></span><br><span class="line">	LEAQ	runtime·m0+m_tls(SB), DI <span class="comment">// 将m0的thread local store成员的地址到DI</span></span><br><span class="line">	CALL	runtime·settls(SB) <span class="comment">// 调用settls设置线程本地存储(mac 下settls什么都没做，线程已经设置好本地存储了)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过往TLS存0x123在判断tls[0]是不是0x123验证TLS是否可用，如果不可用就abort</span></span><br><span class="line">	get_tls(BX)</span><br><span class="line">	MOVQ	$<span class="number">0x123</span>, g(BX)</span><br><span class="line">	MOVQ	runtime·m0+m_tls(SB), AX</span><br><span class="line">	CMPQ	AX, $<span class="number">0x123</span></span><br><span class="line">	JEQ <span class="number">2</span>(PC)</span><br><span class="line">	CALL	runtime·abort(SB)</span><br><span class="line">ok:</span><br><span class="line">	<span class="comment">// 把g0存入m0的本地存储tls[0]</span></span><br><span class="line">	get_tls(BX) <span class="comment">// 将m0.tls[0]地址放入BX</span></span><br><span class="line">	LEAQ	runtime·g0(SB), CX <span class="comment">// 将g0地址放入CX</span></span><br><span class="line">	MOVQ	CX, g(BX) <span class="comment">// m0.tls[0] = &amp;g0</span></span><br><span class="line">	LEAQ	runtime·m0(SB), AX <span class="comment">// 将m0地址放入AX</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将m0和g0建立映射关系</span></span><br><span class="line">	<span class="comment">// save m-&gt;g0 = g0</span></span><br><span class="line">	MOVQ	CX, m_g0(AX) <span class="comment">// m0.g0 = g0</span></span><br><span class="line">	<span class="comment">// save m0 to g0-&gt;m</span></span><br><span class="line">	MOVQ	AX, g_m(CX) <span class="comment">// g0.m = m0</span></span><br><span class="line"></span><br><span class="line">	CLD				<span class="comment">// convention is D is always left cleared</span></span><br><span class="line">	CALL	runtime·check(SB)</span><br></pre></td></tr></table></figure>

<p>创建完m0之后的内存分布</p>
<p><img src="/images/stack_1.png" alt="stack_1"></p>
<h3 id="m0和g0的关系"><a href="#m0和g0的关系" class="headerlink" title="m0和g0的关系"></a>m0和g0的关系</h3><ol>
<li>m0表示主线程，g0表示主线程的第一个goroutine</li>
<li>g0主要是记录主线程的栈信息，执行调度函数(schedule后边会讲)时会用，而用户goroutine有自己的栈，执行的时候会从g0栈切换到用户goroutine栈</li>
</ol>
<h3 id="初始化调度"><a href="#初始化调度" class="headerlink" title="初始化调度"></a>初始化调度</h3><p>g0和m0都创建并初始化好了，下面就该进行调度初始化了</p>
<ol>
<li>将参数放入AX(初始化g0时将参数放入SP+16和SP+24的位置</li>
<li>runtime.args初始化参数的</li>
<li>runtime.osinit是初始化CPU核数的</li>
<li>重点看runtime.schedinit<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化m0</span></span><br><span class="line"><span class="comment">// 将argc和argv入栈</span></span><br><span class="line">MOVL	<span class="number">16</span>(SP), AX		<span class="comment">// copy argc</span></span><br><span class="line">MOVL	AX, <span class="number">0</span>(SP)</span><br><span class="line">MOVQ	<span class="number">24</span>(SP), AX		<span class="comment">// copy argv</span></span><br><span class="line">MOVQ	AX, <span class="number">8</span>(SP)</span><br><span class="line"><span class="comment">// 处理参数</span></span><br><span class="line">CALL	runtime·args(SB)</span><br><span class="line"><span class="comment">// 获取cpu的核数</span></span><br><span class="line">CALL	runtime·osinit(SB)</span><br><span class="line"><span class="comment">// 调度系统初始化</span></span><br><span class="line">CALL	runtime·schedinit(SB)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="runtime-schedinit"><a href="#runtime-schedinit" class="headerlink" title="runtime.schedinit"></a>runtime.schedinit</h4><p>下面函数省略了调度无关的代码，大概流程:</p>
<ol>
<li>设置最大线程数</li>
<li>根据GOMAXPROCS设置procs(P的数量)</li>
<li>调用procresizeprocs调整P的数量</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 取出g0</span></span><br><span class="line">	_g_ := getg()</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		_g_.racectx, raceprocctx0 = raceinit()</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置最大线程数</span></span><br><span class="line">	sched.maxmcount = <span class="number">10000</span></span><br><span class="line">	</span><br><span class="line">	...	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化m0, 前边已经将m0和g0的关系绑定好了</span></span><br><span class="line">	<span class="comment">// 只是检查一下各种变量，然后将m0挂到allm链表中</span></span><br><span class="line">	mcommoninit(_g_.m)</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	sched.lastpoll = <span class="keyword">uint64</span>(nanotime())</span><br><span class="line">	<span class="comment">// ncpu在osinit时已经获取</span></span><br><span class="line">	procs := ncpu</span><br><span class="line">	<span class="comment">// 如果GOMAXPROCS设置并且合法就将procs的设置为GOMAXPROCS</span></span><br><span class="line">	<span class="keyword">if</span> n, ok := atoi32(gogetenv(<span class="string">&quot;GOMAXPROCS&quot;</span>)); ok &amp;&amp; n &gt; <span class="number">0</span> &#123;</span><br><span class="line">		procs = n</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> procresize(procs) != <span class="literal">nil</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;unknown runnable goroutine during bootstrap&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="runtime-procresize"><a href="#runtime-procresize" class="headerlink" title="runtime.procresize"></a>runtime.procresize</h4><ul>
<li>调度初始化最后一步</li>
</ul>
<ol>
<li>更新最后一次修改P数量动作的时间戳并累加花费时间</li>
<li>根据nprocs调整P的数量(加锁)<ol>
<li>nprocs &gt; 现有P数量，就扩展allp(p的全局数组)的长度为nprocs</li>
<li>nprocs &lt; 现有P数量，就缩容allp的长度为nprocs</li>
</ol>
</li>
<li>如果上一步是扩容了，就从堆中创建新P，并把P放入扩容出来的位置</li>
<li>通过g0找到m0，然后将allp[0]和m0绑定</li>
<li>如果allp缩容了，就将多余的p销毁</li>
<li>将空闲的p加入空闲链表<br>到目前为止，创建了m0，g0，和nprocs个P，但是还是没有让调度真正的跑起来</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func procresize(nprocs int32) *p &#123;</span><br><span class="line">	old :&#x3D; gomaxprocs</span><br><span class="line">	if old &lt; 0 || nprocs &lt;&#x3D; 0 &#123;</span><br><span class="line">		throw(&quot;procresize: invalid arg&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	if trace.enabled &#123;</span><br><span class="line">		traceGomaxprocs(nprocs)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; update statistics</span><br><span class="line">	now :&#x3D; nanotime()</span><br><span class="line">	if sched.procresizetime !&#x3D; 0 &#123;</span><br><span class="line">		sched.totaltime +&#x3D; int64(old) * (now - sched.procresizetime)</span><br><span class="line">	&#125;</span><br><span class="line">	sched.procresizetime &#x3D; now</span><br><span class="line"></span><br><span class="line">	if nprocs &gt; int32(len(allp)) &#123; &#x2F;&#x2F; 初始化的len(allp) &#x3D;&#x3D; 0</span><br><span class="line">		lock(&amp;allpLock)</span><br><span class="line">		if nprocs &lt;&#x3D; int32(cap(allp)) &#123; &#x2F;&#x2F; 需要缩容</span><br><span class="line">			allp &#x3D; allp[:nprocs]</span><br><span class="line">		&#125; else &#123; &#x2F;&#x2F; 扩容</span><br><span class="line">			nallp :&#x3D; make([]*p, nprocs)</span><br><span class="line">			&#x2F;&#x2F; Copy everything up to allp&#39;s cap so we</span><br><span class="line">			&#x2F;&#x2F; never lose old allocated Ps.</span><br><span class="line">			copy(nallp, allp[:cap(allp)])</span><br><span class="line">			allp &#x3D; nallp</span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;allpLock)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for i :&#x3D; old; i &lt; nprocs; i++ &#123;</span><br><span class="line">		pp :&#x3D; allp[i]</span><br><span class="line">		if pp &#x3D;&#x3D; nil &#123;</span><br><span class="line">			pp &#x3D; new(p)</span><br><span class="line">		&#125;</span><br><span class="line">		pp.init(i)</span><br><span class="line">		atomicstorep(unsafe.Pointer(&amp;allp[i]), unsafe.Pointer(pp))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_g_ :&#x3D; getg() &#x2F;&#x2F; 获取g0</span><br><span class="line">	if _g_.m.p !&#x3D; 0 &amp;&amp; _g_.m.p.ptr().id &lt; nprocs &#123; &#x2F;&#x2F; 进程初始化时g0.m与p没有绑定，所以g0.m.p &#x3D;&#x3D; 0</span><br><span class="line">		_g_.m.p.ptr().status &#x3D; _Prunning</span><br><span class="line">		_g_.m.p.ptr().mcache.prepareForSweep()</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		if _g_.m.p !&#x3D; 0 &#123;</span><br><span class="line">			if trace.enabled &#123;</span><br><span class="line">				traceGoSched()</span><br><span class="line">				traceProcStop(_g_.m.p.ptr())</span><br><span class="line">			&#125;</span><br><span class="line">			_g_.m.p.ptr().m &#x3D; 0</span><br><span class="line">		&#125;</span><br><span class="line">		_g_.m.p &#x3D; 0</span><br><span class="line">		_g_.m.mcache &#x3D; nil</span><br><span class="line">		p :&#x3D; allp[0]</span><br><span class="line">		p.m &#x3D; 0</span><br><span class="line">		p.status &#x3D; _Pidle</span><br><span class="line">		acquirep(p) &#x2F;&#x2F; 把allp[0]和m0关联起来</span><br><span class="line">		if trace.enabled &#123;</span><br><span class="line">			traceGoStart()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 如果有需要销毁的p，就是销毁</span><br><span class="line">	for i :&#x3D; nprocs; i &lt; old; i++ &#123;</span><br><span class="line">		p :&#x3D; allp[i]</span><br><span class="line">		p.destroy()</span><br><span class="line">		&#x2F;&#x2F; can&#39;t free P itself because it can be referenced by an M in syscall</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if int32(len(allp)) !&#x3D; nprocs &#123;</span><br><span class="line">		lock(&amp;allpLock)</span><br><span class="line">		allp &#x3D; allp[:nprocs]</span><br><span class="line">		unlock(&amp;allpLock)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 将空闲p放入空闲链表</span><br><span class="line">	var runnablePs *p</span><br><span class="line">	for i :&#x3D; nprocs - 1; i &gt;&#x3D; 0; i-- &#123;</span><br><span class="line">		p :&#x3D; allp[i]</span><br><span class="line">		if _g_.m.p.ptr() &#x3D;&#x3D; p &#123; &#x2F;&#x2F; allp[0]已经和m0关联了，所以不用放入空闲链表</span><br><span class="line">			continue</span><br><span class="line">		&#125;</span><br><span class="line">		p.status &#x3D; _Pidle</span><br><span class="line">		if runqempty(p) &#123;</span><br><span class="line">			pidleput(p)</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			p.m.set(mget())</span><br><span class="line">			p.link.set(runnablePs)</span><br><span class="line">			runnablePs &#x3D; p</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	stealOrder.reset(uint32(nprocs))</span><br><span class="line">	var int32p *int32 &#x3D; &amp;gomaxprocs &#x2F;&#x2F; make compiler check that gomaxprocs is an int32</span><br><span class="line">	atomic.Store((*uint32)(unsafe.Pointer(int32p)), uint32(nprocs))</span><br><span class="line">	return runnablePs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建”第一个”goroutine"><a href="#创建”第一个”goroutine" class="headerlink" title="创建”第一个”goroutine"></a>创建”第一个”goroutine</h2><p>我们返回runtime·rt0_go接着看</p>
<ol>
<li>将runtime.main地址放入AX</li>
<li>参数AX, 0入栈(函数参数入栈由右向左)</li>
<li>然后调用runtime.newproc创建goroutine</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// create a new goroutine to start program</span></span><br><span class="line"><span class="comment">// 创建第一个goroutine执行runtime.main，源码里没搜到runtime.mainPC，在schedinit函数前注释里找到的runtime.mainPC就是runtime.main</span></span><br><span class="line">MOVQ	$runtime·mainPC(SB), AX		<span class="comment">// entry AX = func(runtime.main)</span></span><br><span class="line">PUSHQ	AX</span><br><span class="line">PUSHQ	$<span class="number">0</span>			<span class="comment">// arg size runtime.main没有参数所以入栈0</span></span><br><span class="line">CALL	runtime·newproc(SB)     <span class="comment">// 创建goroutine执行runtime.main(还没执行，只是将goroutine加入待运行队列)</span></span><br><span class="line">POPQ	AX                      <span class="comment">// 出栈</span></span><br><span class="line">POPQ	AX                      <span class="comment">// 出栈</span></span><br></pre></td></tr></table></figure>

<h3 id="newproc"><a href="#newproc" class="headerlink" title="newproc"></a>newproc</h3><ol>
<li>首先获取参数地址</li>
<li>获取当前所在goroutine(初始化时runtime代码都在g0执行)</li>
<li>获取要执行指令地址</li>
<li>在gp的栈上执行runtime.newproc1(在g0栈上执行)</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc</span><span class="params">(siz <span class="keyword">int32</span>, fn *funcval)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取函数fn的第一个参数的位置</span></span><br><span class="line">	argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)</span><br><span class="line">	<span class="comment">// 获取当前所有goroutine ---- g0</span></span><br><span class="line">	gp := getg()</span><br><span class="line">	<span class="comment">// 获取要执行指令的位置</span></span><br><span class="line">	pc := getcallerpc()</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	systemstack是将函数切换到g0的栈上运行，初始化时本来就在g0的栈上，所以直接调用函数返回</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		newproc1(fn, (*<span class="keyword">uint8</span>)(argp), siz, gp, pc)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="newproc1函数主要的工作"><a href="#newproc1函数主要的工作" class="headerlink" title="newproc1函数主要的工作"></a>newproc1函数主要的工作</h3><p>这个函数有点长分段来看</p>
<ol>
<li>首先获得当前所在goroutine(g0)</li>
<li>禁止抢占</li>
<li>计算参数位置</li>
<li>计算下参数是否过大</li>
<li>获取当前goroutine所在m的p，前边讲过g0对应的m是m0，m0对应的p是allp[0]</li>
<li>创建一个goroutine(先从p的缓存里找，找不到就new一个)，并且确认goroutine栈边界是初始化好的(方式p缓存里的goroutine参数没初始化)</li>
<li>计算栈顶的地址，如果有参数就将参数放到新创建的这个goroutine上</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc1</span><span class="params">(fn *funcval, argp *<span class="keyword">uint8</span>, narg <span class="keyword">int32</span>, callergp *g, callerpc <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取当前所在goroutine，初始化的是g0</span></span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> fn == <span class="literal">nil</span> &#123;</span><br><span class="line">		_g_.m.throwing = <span class="number">-1</span> <span class="comment">// do not dump full stacks</span></span><br><span class="line">		throw(<span class="string">&quot;go of nil func value&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 禁止抢占，把p固定在本地变量</span></span><br><span class="line">	acquirem() <span class="comment">// disable preemption because it can be holding p in a local var</span></span><br><span class="line">	siz := narg</span><br><span class="line">	siz = (siz + <span class="number">7</span>) &amp;^ <span class="number">7</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查一下参数是否需要空间是否过大，参数大小 和 栈大小 - (额外栈底空间(猜的)) - 返回需要的栈大小</span></span><br><span class="line">	<span class="keyword">if</span> siz &gt;= _StackMin<span class="number">-4</span>*sys.RegSize-sys.RegSize &#123;</span><br><span class="line">		throw(<span class="string">&quot;newproc: function arguments too large for new goroutine&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// _p_ = allp[0]</span></span><br><span class="line">	_p_ := _g_.m.p.ptr()</span><br><span class="line">	<span class="comment">// 从_p_的缓存中取一个g，初始化的时候没有可用的g所以newg==nil</span></span><br><span class="line">	newg := gfget(_p_)</span><br><span class="line">	<span class="keyword">if</span> newg == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 创建一个新g，栈空间2k, 并且给stack,stackguard0,stackguard1初始化</span></span><br><span class="line">		newg = malg(_StackMin)</span><br><span class="line">		<span class="comment">// 将g的状态设置为_Gdead</span></span><br><span class="line">		casgstatus(newg, _Gidle, _Gdead)</span><br><span class="line">		<span class="comment">// 将g加入allg链表</span></span><br><span class="line">		allgadd(newg) <span class="comment">// publishes with a g-&gt;status of Gdead so GC scanner doesn&#x27;t look at uninitialized stack.</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 确认刚才的初始化是否有效</span></span><br><span class="line">	<span class="keyword">if</span> newg.stack.hi == <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;newproc1: newg missing stack&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> readgstatus(newg) != _Gdead &#123;</span><br><span class="line">		throw(<span class="string">&quot;newproc1: new g is not Gdead&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略一段调整sp指针的函数，并且如果有参数就将参数放入new goroutine的栈中</span></span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p>设置各个寄存器的值(在cpu上恢复上下文时使用)<br>    1) 清理sched<br>    2) 设置栈顶置针位置<br>    3) 设置pc寄存器值(goexit函数第二条指令，常理应该是goroutine本身函数的第一条指令，这个妙用后边说)<br>    4) 设置goroutine地址<br>    5) 调用gostartcallfn，参数是sched和goroutine的参数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 清理sched(各参数清零)</span></span><br><span class="line">memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))</span><br><span class="line"><span class="comment">// 设置sched, 在CPU上运行的相关参数</span></span><br><span class="line">newg.sched.sp = sp</span><br><span class="line">newg.stktopsp = sp</span><br><span class="line"><span class="comment">// 设置pc，被调度时第一条指令的位置，将pc设置为goexit函数一个偏移量的位置(goexit函数第二条指令)</span></span><br><span class="line"><span class="comment">// 这里把pc设置为goexit函数的第二条指令的作用就是，伪装成goexit函数调用的fn函数，当fn执行完跳回goexit函数继续做退出需要的操作</span></span><br><span class="line">newg.sched.pc = funcPC(goexit) + sys.PCQuantum <span class="comment">// +PCQuantum so that previous instruction is in same function</span></span><br><span class="line">newg.sched.g = guintptr(unsafe.Pointer(newg))</span><br><span class="line">gostartcallfn(&amp;newg.sched, fn)</span><br></pre></td></tr></table></figure>

<p>判断一下goroutine的函数是否为空，然后调用gostartcall</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gostartcallfn</span><span class="params">(gobuf *gobuf, fv *funcval)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> fn unsafe.Pointer</span><br><span class="line">	<span class="keyword">if</span> fv != <span class="literal">nil</span> &#123;</span><br><span class="line">		fn = unsafe.Pointer(fv.fn)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fn = unsafe.Pointer(funcPC(nilfunc))</span><br><span class="line">	&#125;</span><br><span class="line">	gostartcall(gobuf, fn, unsafe.Pointer(fv))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>获取sp，现在新goroutine的栈上之后本身的函数，sp指向函数的第一个参数</li>
<li>将sp指向pc里面的指令地址，也就是goexit的第二条指令，然后重新设置新goroutinesp地址</li>
<li>这时候pc才指向goroutine自己的函数</li>
</ol>
<p>gostartcall的主要作用就是将goexit入栈，然后设置goroutine的pc指向自身函数，伪装成是goexit调用的自身函数，当自身函数执行完时返回goexit清理线程，大概就是下面这样</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	goroutine自身函数()</span><br><span class="line">	清理现场()	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gostartcall</span><span class="params">(buf *gobuf, fn, ctxt unsafe.Pointer)</span></span> &#123;</span><br><span class="line">	sp := buf.sp</span><br><span class="line">	<span class="keyword">if</span> sys.RegSize &gt; sys.PtrSize &#123;</span><br><span class="line">		sp -= sys.PtrSize</span><br><span class="line">		*(*<span class="keyword">uintptr</span>)(unsafe.Pointer(sp)) = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 预留返回值空间</span></span><br><span class="line">	sp -= sys.PtrSize</span><br><span class="line">	<span class="comment">// sp指向pc指令的位置，前边已经将goexit第二条指令的地址放入pc</span></span><br><span class="line">	*(*<span class="keyword">uintptr</span>)(unsafe.Pointer(sp)) = buf.pc </span><br><span class="line">	<span class="comment">// 然后设置sp</span></span><br><span class="line">	buf.sp = sp</span><br><span class="line">	<span class="comment">// 这时候的pc才是goroutine的函数</span></span><br><span class="line">	buf.pc = <span class="keyword">uintptr</span>(fn)</span><br><span class="line">	buf.ctxt = ctxt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再回到newproc函数，剩下的就是设置goroutine的状态，然后把goroutine放入p的待执行队列中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">	newg.gopc = callerpc <span class="comment">// 用于traceback</span></span><br><span class="line">	newg.ancestors = saveAncestors(callergp)</span><br><span class="line">	<span class="comment">// newg的函数从哪里开始执行依赖于sched.pc 不依赖于startpc</span></span><br><span class="line">	newg.startpc = fn.fn</span><br><span class="line">	<span class="keyword">if</span> _g_.m.curg != <span class="literal">nil</span> &#123;</span><br><span class="line">		newg.labels = _g_.m.curg.labels</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> isSystemGoroutine(newg, <span class="literal">false</span>) &#123;</span><br><span class="line">		atomic.Xadd(&amp;sched.ngsys, +<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	newg.gcscanvalid = <span class="literal">false</span></span><br><span class="line">	<span class="comment">// 设置newg状态为_Grunnable, 到这里newg就可以运行了</span></span><br><span class="line">	casgstatus(newg, _Gdead, _Grunnable)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _p_.goidcache == _p_.goidcacheend &#123;</span><br><span class="line">		_p_.goidcache = atomic.Xadd64(&amp;sched.goidgen, _GoidCacheBatch)</span><br><span class="line">		_p_.goidcache -= _GoidCacheBatch - <span class="number">1</span></span><br><span class="line">		_p_.goidcacheend = _p_.goidcache + _GoidCacheBatch</span><br><span class="line">	&#125;</span><br><span class="line">	newg.goid = <span class="keyword">int64</span>(_p_.goidcache)</span><br><span class="line">	_p_.goidcache++</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		newg.racectx = racegostart(callerpc)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGoCreate(newg, newg.startpc)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将newg加入p的待运行队列</span></span><br><span class="line">	runqput(_p_, newg, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;sched.npidle) != <span class="number">0</span> &amp;&amp; atomic.Load(&amp;sched.nmspinning) == <span class="number">0</span> &amp;&amp; mainStarted &#123;</span><br><span class="line">		wakep()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 取消m的固定</span></span><br><span class="line">	releasem(_g_.m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下创建第一个goroutine执行runtime.main的过程(只是创建啊，整个调度这时候还是没有跑起来)<br><img src="/images/creat_goroutine_main.png" alt="create_goroutine_main"></p>
<h2 id="调度循环"><a href="#调度循环" class="headerlink" title="调度循环"></a>调度循环</h2><p>我们再返回runtime·rt0_go继续看，总结一下到目前为止已经准备好的事情</p>
<ol>
<li>将m0与主线程绑定了(将m0结构体设为主线程的私有变量)</li>
<li>创建了g0，并且与m0绑定</li>
<li>创建了procs个p并且初始化，将allp[0]与m0绑定，形成初步的GMP模型(g0,m0,p0)</li>
<li>创建了一个执行runtime.main(不是代码里的main.main，runtime.main会做加载init函数等操作然后调用main.main)的goroutine并且放入了p0的待运行队列</li>
</ol>
<p>接下来就是调度循环了，调用runtime.mstart，这个函数就是调度循环，除非程序退出否则永远阻塞住</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// start this M</span></span><br><span class="line"><span class="comment">// 运行runtime.mstart这个函数会阻塞住，运行结束的时候就是程序退出的时候</span></span><br><span class="line">CALL	runtime·mstart(SB)</span><br><span class="line"></span><br><span class="line">CALL	runtime·abort(SB)	<span class="comment">// mstart should never return</span></span><br><span class="line">RET</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prevent dead-code elimination of debugCallV1, which is</span></span><br><span class="line"><span class="comment">// intended to be called by debuggers.</span></span><br><span class="line">MOVQ	$runtime·debugCallV1(SB), AX</span><br><span class="line">RET</span><br></pre></td></tr></table></figure>

<h3 id="runtime-mstart"><a href="#runtime-mstart" class="headerlink" title="runtime.mstart"></a>runtime.mstart</h3><ol>
<li>获取了当前所在goroutine(初始化时代码都是在g0上执行的)</li>
<li>初始化栈保护</li>
<li>调用mstart1<br>go/src/runtime/proc.go, line 1146<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func mstart() &#123;</span><br><span class="line">	_g_ :&#x3D; getg() &#x2F;&#x2F; 获取g0</span><br><span class="line"></span><br><span class="line">	osStack :&#x3D; _g_.stack.lo &#x3D;&#x3D; 0 &#x2F;&#x2F; g0.stack.lo在前边已经初始化过了，所以osStack &#x3D; false</span><br><span class="line">	if osStack &#123;</span><br><span class="line">		size :&#x3D; _g_.stack.hi</span><br><span class="line">		if size &#x3D;&#x3D; 0 &#123;</span><br><span class="line">			size &#x3D; 8192 * sys.StackGuardMultiplier</span><br><span class="line">		&#125;</span><br><span class="line">		_g_.stack.hi &#x3D; uintptr(noescape(unsafe.Pointer(&amp;size)))</span><br><span class="line">		_g_.stack.lo &#x3D; _g_.stack.hi - size + 1024</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; 初始化栈保护</span><br><span class="line">	_g_.stackguard0 &#x3D; _g_.stack.lo + _StackGuard</span><br><span class="line">	_g_.stackguard1 &#x3D; _g_.stackguard0</span><br><span class="line">	&#x2F;&#x2F; 开始m0开始运行</span><br><span class="line">	mstart1()</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Exit this thread.</span><br><span class="line">	if GOOS &#x3D;&#x3D; &quot;windows&quot; || GOOS &#x3D;&#x3D; &quot;solaris&quot; || GOOS &#x3D;&#x3D; &quot;illumos&quot; || GOOS &#x3D;&#x3D; &quot;plan9&quot; || GOOS &#x3D;&#x3D; &quot;darwin&quot; || GOOS &#x3D;&#x3D; &quot;aix&quot; &#123;</span><br><span class="line">		osStack &#x3D; true</span><br><span class="line">	&#125;</span><br><span class="line">	mexit(osStack)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="runtime-mstart1"><a href="#runtime-mstart1" class="headerlink" title="runtime.mstart1"></a>runtime.mstart1</h3><ol>
<li>保存g0的指令指针和栈指针，保存这两个值是理解调度循环的关键，mstart1执行完之后，g0继续执行指令，不会再返回来了，保存了指令和栈指针之后，g0要继续执行指令的时候，就会又从上面开始执行</li>
<li>做一些初始化工作</li>
<li>调用schedule开始调度<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func mstart1() &#123;</span><br><span class="line">	&#x2F;&#x2F; 获取当前goroutine g0</span><br><span class="line">	_g_ :&#x3D; getg()</span><br><span class="line"></span><br><span class="line">	if _g_ !&#x3D; _g_.m.g0 &#123;</span><br><span class="line">		throw(&quot;bad runtime·mstart&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; save函数保存了g0再次运行时(循环调度下一次回头)调度相关信息</span><br><span class="line">	save(getcallerpc(), getcallersp())</span><br><span class="line">	&#x2F;&#x2F; asminit</span><br><span class="line">	asminit()</span><br><span class="line">	&#x2F;&#x2F; 信号相关初始化</span><br><span class="line">	minit()</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 初始化时m &#x3D;&#x3D; m0，mstartm0也是信号相关的初始化</span><br><span class="line">	if _g_.m &#x3D;&#x3D; &amp;m0 &#123;</span><br><span class="line">		mstartm0()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 初始化时fn &#x3D;&#x3D; ni</span><br><span class="line">	if fn :&#x3D; _g_.m.mstartfn; fn !&#x3D; nil &#123;</span><br><span class="line">		fn()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if _g_.m !&#x3D; &amp;m0 &#123;</span><br><span class="line">		acquirep(_g_.m.nextp.ptr())</span><br><span class="line">		_g_.m.nextp &#x3D; 0</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; 开始调度</span><br><span class="line">	schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="runtime-schedule"><a href="#runtime-schedule" class="headerlink" title="runtime.schedule"></a>runtime.schedule</h3><p>调度开始了，m要找gorutine放到cpu上执行了</p>
<ol>
<li>每调度61次(具体为啥是61有待思考)，就从全局的goroutine列表中选goroutine</li>
<li>如果上一步没找到，就从m对应的p的缓存里找</li>
<li>如果上一步还没有找到，就调findrunnable从其他线程窃取goroutine，如果发现有就窃取一半放到自己的p缓存中，如果都没有就说明真的没有待运行的goroutine了，就陷入睡眠一直阻塞在findrunnable函数，等待被唤醒</li>
<li>直到有goroutine需要执行了，就调用execute执行goroutine</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获得g0</span></span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _g_.m.locks != <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;schedule: holding locks&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _g_.m.lockedg != <span class="number">0</span> &#123;</span><br><span class="line">		stoplockedm()</span><br><span class="line">		execute(_g_.m.lockedg.ptr(), <span class="literal">false</span>) <span class="comment">// Never returns.</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _g_.m.incgo &#123;</span><br><span class="line">		throw(<span class="string">&quot;schedule: in cgo&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">	<span class="comment">// 等待gc</span></span><br><span class="line">	<span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">		gcstopm()</span><br><span class="line">		<span class="keyword">goto</span> top</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _g_.m.p.ptr().runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">		runSafePointFn()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> gp *g</span><br><span class="line">	<span class="keyword">var</span> inheritTime <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	tryWakeP := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">if</span> trace.enabled || trace.shutdown &#123;</span><br><span class="line">		gp = traceReader()</span><br><span class="line">		<span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">			casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">			traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">			tryWakeP = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> gp == <span class="literal">nil</span> &amp;&amp; gcBlackenEnabled != <span class="number">0</span> &#123;</span><br><span class="line">		gp = gcController.findRunnableGCWorker(_g_.m.p.ptr())</span><br><span class="line">		tryWakeP = tryWakeP || gp != <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 先从全局队列中获取，每61次调度都会从全局队列中获取goroutine</span></span><br><span class="line">	<span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> _g_.m.p.ptr().schedtick%<span class="number">61</span> == <span class="number">0</span> &amp;&amp; sched.runqsize &gt; <span class="number">0</span> &#123;</span><br><span class="line">			lock(&amp;sched.lock)</span><br><span class="line">			gp = globrunqget(_g_.m.p.ptr(), <span class="number">1</span>)</span><br><span class="line">			unlock(&amp;sched.lock)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果还空就从本地队列中获取</span></span><br><span class="line">	<span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">		gp, inheritTime = runqget(_g_.m.p.ptr())</span><br><span class="line">		<span class="keyword">if</span> gp != <span class="literal">nil</span> &amp;&amp; _g_.m.spinning &#123;</span><br><span class="line">			throw(<span class="string">&quot;schedule: spinning with local work&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果本地也没有就调用findrunnable从其他线程偷一个过来，直到偷过来在运行</span></span><br><span class="line">	<span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">		gp, inheritTime = findrunnable() <span class="comment">// blocks until work is available</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">		resetspinning()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> sched.disable.user &amp;&amp; !schedEnabled(gp) &#123;</span><br><span class="line">		lock(&amp;sched.lock)</span><br><span class="line">		<span class="keyword">if</span> schedEnabled(gp) &#123;</span><br><span class="line">			unlock(&amp;sched.lock)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			sched.disable.runnable.pushBack(gp)</span><br><span class="line">			sched.disable.n++</span><br><span class="line">			unlock(&amp;sched.lock)</span><br><span class="line">			<span class="keyword">goto</span> top</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> tryWakeP &#123;</span><br><span class="line">		<span class="keyword">if</span> atomic.Load(&amp;sched.npidle) != <span class="number">0</span> &amp;&amp; atomic.Load(&amp;sched.nmspinning) == <span class="number">0</span> &#123;</span><br><span class="line">			wakep()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> gp.lockedm != <span class="number">0</span> &#123;</span><br><span class="line">		startlockedm(gp)</span><br><span class="line">		<span class="keyword">goto</span> top</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 执行这个goroutine</span></span><br><span class="line">	execute(gp, inheritTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="触发调度"><a href="#触发调度" class="headerlink" title="触发调度"></a>触发调度</h2><p>触发调度地方大致有:</p>
<ol>
<li>主动挂起</li>
<li>系统调用</li>
<li>协作式调度</li>
<li>正常退出</li>
</ol>
<ul>
<li>proc.go:1208 runtime.mstart1(调度开始)</li>
</ul>
<h3 id="主动挂起"><a href="#主动挂起" class="headerlink" title="主动挂起"></a>主动挂起</h3><ul>
<li>proc.go:2610 runtime.park_m<br>在上一章内容里讲过<a href="https://www.cnblogs.com/wuwangchuxin0924/p/13022386.html">golang channel源码阅读</a>，当goroutine接收一个channel为空且为阻塞的时候，goroutine会调用goparkunlock使goroutine陷入睡眠，等待send端调用goready函数唤醒函数，主动挂起就是这种情况，当goroutine由于某些条件在等待时，就会主动挂起，不放回待运行队列，等待被唤醒</li>
</ul>
<p>各种阻塞条件 -&gt; runtime.gopark() -&gt; runtime.park_m() -&gt; runtime.schedule</p>
<ol>
<li>获取当前所在m，并且固定m</li>
<li>获取当前程序所在goroutine</li>
<li>设置锁状态以及阻塞原因</li>
<li>调用runtime.park_m挂起goroutine</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gopark</span><span class="params">(unlockf <span class="keyword">func</span>(*g, unsafe.Pointer)</span> <span class="title">bool</span>, <span class="title">lock</span> <span class="title">unsafe</span>.<span class="title">Pointer</span>, <span class="title">reason</span> <span class="title">waitReason</span>, <span class="title">traceEv</span> <span class="title">byte</span>, <span class="title">traceskip</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> reason != waitReasonSleep &#123;</span><br><span class="line">		checkTimeouts() <span class="comment">// timeouts may expire while two goroutines keep the scheduler busy</span></span><br><span class="line">	&#125;</span><br><span class="line">	mp := acquirem()</span><br><span class="line">	gp := mp.curg</span><br><span class="line">	status := readgstatus(gp)</span><br><span class="line">	<span class="keyword">if</span> status != _Grunning &amp;&amp; status != _Gscanrunning &#123;</span><br><span class="line">		throw(<span class="string">&quot;gopark: bad g status&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	mp.waitlock = lock</span><br><span class="line">	mp.waitunlockf = unlockf</span><br><span class="line">	gp.waitreason = reason</span><br><span class="line">	mp.waittraceev = traceEv</span><br><span class="line">	mp.waittraceskip = traceskip</span><br><span class="line">	releasem(mp)</span><br><span class="line">	<span class="comment">// can&#x27;t do anything that might move the G between Ms here.</span></span><br><span class="line">	mcall(park_m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>获取当前goroutine</li>
<li>将goroutine状态设置为Gwaiting</li>
<li>重新调度</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">park_m</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGoPark(_g_.m.waittraceev, _g_.m.waittraceskip)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	casgstatus(gp, _Grunning, _Gwaiting)</span><br><span class="line">	dropg()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> fn := _g_.m.waitunlockf; fn != <span class="literal">nil</span> &#123;</span><br><span class="line">		ok := fn(gp, _g_.m.waitlock)</span><br><span class="line">		_g_.m.waitunlockf = <span class="literal">nil</span></span><br><span class="line">		_g_.m.waitlock = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">				traceGoUnpark(gp, <span class="number">2</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">			execute(gp, <span class="literal">true</span>) <span class="comment">// Schedule it back, never returns.</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="协作式调度"><a href="#协作式调度" class="headerlink" title="协作式调度"></a>协作式调度</h3><ul>
<li>proc.go:2625 runtime.goschedImpl(协作式调度)</li>
</ul>
<ol>
<li>主动让出cpu，这个情况不会挂起goroutine，而是放回队列，等待下次调度，这个函数(GoSched)被暴露出去，可以调用，例如，线上有这种情况，写log是异步的，但由于机器磁盘老旧性能不佳，所以当log goroutine运行时还是会过多的占用cpu，这时候可以调用GoSched适当降低当前goroutine优先级</li>
</ol>
<p>runtime.Gosched -&gt; runtime.gosched_m -&gt; runtime.goschedImpl runtime.schedule</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Gosched continuation on g0.</span><br><span class="line">func gosched_m(gp *g) &#123;</span><br><span class="line">	if trace.enabled &#123;</span><br><span class="line">		traceGoSched()</span><br><span class="line">	&#125;</span><br><span class="line">	goschedImpl(gp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>调度保护，当调度器发现goroutine处于禁止的状态时就会主动调度让出cpu</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// goschedguarded is a forbidden-states-avoided version of gosched_m</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goschedguarded_m</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> gp.m.locks != <span class="number">0</span> || gp.m.mallocing != <span class="number">0</span> || gp.m.preemptoff != <span class="string">&quot;&quot;</span> || gp.m.p.ptr().status != _Prunning &#123;</span><br><span class="line">		gogo(&amp;gp.sched) <span class="comment">// never return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGoSched()</span><br><span class="line">	&#125;</span><br><span class="line">	goschedImpl(gp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>发生抢占，例如当一个goroutine运行时间过长但不像等待channel那样阻塞，一直有事情做时，其他goroutine可能会抢占cpu</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gopreempt_m</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGoPreempt()</span><br><span class="line">	&#125;</span><br><span class="line">	goschedImpl(gp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goschedImpl</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">	status := readgstatus(gp)</span><br><span class="line">	<span class="keyword">if</span> status&amp;^_Gscan != _Grunning &#123;</span><br><span class="line">		dumpgstatus(gp)</span><br><span class="line">		throw(<span class="string">&quot;bad g status&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	casgstatus(gp, _Grunning, _Grunnable)</span><br><span class="line">	dropg()</span><br><span class="line">	lock(&amp;sched.lock)</span><br><span class="line">	globrunqput(gp)</span><br><span class="line">	unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">	schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非main-goroutine结束"><a href="#非main-goroutine结束" class="headerlink" title="非main goroutine结束"></a>非main goroutine结束</h3><ul>
<li>proc.go:2704,2727 runtime.goexit0(goroutine正常执行完)<br>非main goroutine结束后会继续调度，这个是正常继续下一次调度不做过多介绍</li>
</ul>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><ul>
<li>proc.go:3141 runtime.exitsyscall0(系统调用)</li>
</ul>
<p>runtime·exitsyscall -&gt; runtime·exitsyscall0 -&gt; runtime.schedule</p>
<p>我们来看下系统调用的过程</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">syscall_syscall</span><span class="params">(fn, a1, a2, a3 <span class="keyword">uintptr</span>)</span> <span class="params">(r1, r2, err <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">	entersyscall()</span><br><span class="line">	libcCall(unsafe.Pointer(funcPC(syscall)), unsafe.Pointer(&amp;fn))</span><br><span class="line">	exitsyscall()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">syscall</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>首先会调用runtime.entersyscall获取当前的指令位置和栈指针，然后调用reentersyscall做goroutine进入系统调用之前的准备</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">entersyscall</span><span class="params">()</span></span> &#123;</span><br><span class="line">	reentersyscall(getcallerpc(), getcallersp())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>禁止线程抢占防止出现栈不一致的情况</li>
<li>保证当前函数不会触发栈调整(golang进程的栈初始2k，然后动态调整)</li>
<li>设置goroutine状态为Gsyscall</li>
<li>将goroutine的P暂时和M分离，并且设置P状态为Psyscall</li>
<li>释放锁</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reentersyscall</span><span class="params">(pc, sp <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获得当前goroutine</span></span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	_g_.m.locks++</span><br><span class="line"></span><br><span class="line">	_g_.stackguard0 = stackPreempt</span><br><span class="line">	_g_.throwsplit = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Leave SP around for GC and traceback.</span></span><br><span class="line">	save(pc, sp)</span><br><span class="line">	_g_.syscallsp = sp</span><br><span class="line">	_g_.syscallpc = pc</span><br><span class="line">	casgstatus(_g_, _Grunning, _Gsyscall)</span><br><span class="line">	<span class="keyword">if</span> _g_.syscallsp &lt; _g_.stack.lo || _g_.stack.hi &lt; _g_.syscallsp &#123;</span><br><span class="line">		systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;entersyscall inconsistent &quot;</span>, hex(_g_.syscallsp), <span class="string">&quot; [&quot;</span>, hex(_g_.stack.lo), <span class="string">&quot;,&quot;</span>, hex(_g_.stack.hi), <span class="string">&quot;]\n&quot;</span>)</span><br><span class="line">			throw(<span class="string">&quot;entersyscall&quot;</span>)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		systemstack(traceGoSysCall)</span><br><span class="line">		save(pc, sp)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;sched.sysmonwait) != <span class="number">0</span> &#123;</span><br><span class="line">		systemstack(entersyscall_sysmon)</span><br><span class="line">		save(pc, sp)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _g_.m.p.ptr().runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">		systemstack(runSafePointFn)</span><br><span class="line">		save(pc, sp)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_g_.m.syscalltick = _g_.m.p.ptr().syscalltick</span><br><span class="line">	_g_.sysblocktraced = <span class="literal">true</span></span><br><span class="line">	_g_.m.mcache = <span class="literal">nil</span></span><br><span class="line">	pp := _g_.m.p.ptr()</span><br><span class="line">	pp.m = <span class="number">0</span></span><br><span class="line">	_g_.m.oldp.set(pp)</span><br><span class="line">	_g_.m.p = <span class="number">0</span></span><br><span class="line">	atomic.Store(&amp;pp.status, _Psyscall)</span><br><span class="line">	<span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">		systemstack(entersyscall_gcwait)</span><br><span class="line">		save(pc, sp)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_g_.m.locks--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就进入系统调用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">...</span><br></pre></td></tr></table></figure>

<ol>
<li>获得goroutine</li>
<li>线程加锁</li>
<li>调exitsyscallfast替当前goroutine找一个P<ol>
<li>如果原P处于Psyscall就让这个P接管，否则的话进行2)</li>
<li>否则的话就找空闲的P，有的话就调用exitsyscall0继续调度，否则的话进行3)</li>
<li>将goroutine设置为Grunning，加入全局队列，调用Gosched()继续调度<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exitsyscall</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	_g_.m.locks++ <span class="comment">// see comment in entersyscall</span></span><br><span class="line">	<span class="keyword">if</span> getcallersp() &gt; _g_.syscallsp &#123;</span><br><span class="line">		throw(<span class="string">&quot;exitsyscall: syscall frame is no longer valid&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_g_.waitsince = <span class="number">0</span></span><br><span class="line">	oldp := _g_.m.oldp.ptr()</span><br><span class="line">	_g_.m.oldp = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> exitsyscallfast(oldp) &#123;</span><br><span class="line">		<span class="keyword">if</span> _g_.m.mcache == <span class="literal">nil</span> &#123;</span><br><span class="line">			throw(<span class="string">&quot;lost mcache&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">			<span class="keyword">if</span> oldp != _g_.m.p.ptr() || _g_.m.syscalltick != _g_.m.p.ptr().syscalltick &#123;</span><br><span class="line">				systemstack(traceGoStart)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// There&#x27;s a cpu for us, so we can run.</span></span><br><span class="line">		_g_.m.p.ptr().syscalltick++</span><br><span class="line">		<span class="comment">// We need to cas the status and scan before resuming...</span></span><br><span class="line">		casgstatus(_g_, _Gsyscall, _Grunning)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Garbage collector isn&#x27;t running (since we are),</span></span><br><span class="line">		<span class="comment">// so okay to clear syscallsp.</span></span><br><span class="line">		_g_.syscallsp = <span class="number">0</span></span><br><span class="line">		_g_.m.locks--</span><br><span class="line">		<span class="keyword">if</span> _g_.preempt &#123;</span><br><span class="line">			<span class="comment">// restore the preemption request in case we&#x27;ve cleared it in newstack</span></span><br><span class="line">			_g_.stackguard0 = stackPreempt</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// otherwise restore the real _StackGuard, we&#x27;ve spoiled it in entersyscall/entersyscallblock</span></span><br><span class="line">			_g_.stackguard0 = _g_.stack.lo + _StackGuard</span><br><span class="line">		&#125;</span><br><span class="line">		_g_.throwsplit = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> sched.disable.user &amp;&amp; !schedEnabled(_g_) &#123;</span><br><span class="line">			<span class="comment">// Scheduling of this goroutine is disabled.</span></span><br><span class="line">			Gosched()</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_g_.sysexitticks = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		<span class="comment">// Wait till traceGoSysBlock event is emitted.</span></span><br><span class="line">		<span class="comment">// This ensures consistency of the trace (the goroutine is started after it is blocked).</span></span><br><span class="line">		<span class="keyword">for</span> oldp != <span class="literal">nil</span> &amp;&amp; oldp.syscalltick == _g_.m.syscalltick &#123;</span><br><span class="line">			osyield()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// We can&#x27;t trace syscall exit right now because we don&#x27;t have a P.</span></span><br><span class="line">		<span class="comment">// Tracing code can invoke write barriers that cannot run without a P.</span></span><br><span class="line">		<span class="comment">// So instead we remember the syscall exit time and emit the event</span></span><br><span class="line">		<span class="comment">// in execute when we have a P.</span></span><br><span class="line">		_g_.sysexitticks = cputicks()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_g_.m.locks--</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Call the scheduler.</span></span><br><span class="line">	mcall(exitsyscall0)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _g_.m.mcache == <span class="literal">nil</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;lost mcache&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Scheduler returned, so we&#x27;re allowed to run now.</span></span><br><span class="line">	<span class="comment">// Delete the syscallsp information that we left for</span></span><br><span class="line">	<span class="comment">// the garbage collector during the system call.</span></span><br><span class="line">	<span class="comment">// Must wait until now because until gosched returns</span></span><br><span class="line">	<span class="comment">// we don&#x27;t know for sure that the garbage collector</span></span><br><span class="line">	<span class="comment">// is not running.</span></span><br><span class="line">	_g_.syscallsp = <span class="number">0</span></span><br><span class="line">	_g_.m.p.ptr().syscalltick++</span><br><span class="line">	_g_.throwsplit = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<p><a href="https://www.cnblogs.com/abozhang/p/10766628.html">参考资料go语言调度器源代码情景分析</a></p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
</search>
