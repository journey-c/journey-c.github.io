<!DOCTYPE html>
<html lang="en-us">

<head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Hugo 0.74.3" />



<title>Linux进程管理和调度（一） - Journey-C</title>
<meta property="og:title" content="Linux进程管理和调度（一） - Journey-C">


<link href='https://journey-c.github.io/favicon.png' rel='icon' type='image/x-icon' />








<link rel="icon" href="https://journey-c.github.io/images/" type="image/x-icon" />
<link rel="stylesheet" href="https://journey-c.github.io/css/main.css" media="all">
<link rel="stylesheet" href="https://journey-c.github.io/css/fonts.css" media="all">
<link rel="stylesheet" href="https://journey-c.github.io/css/prism.css" media="all">
<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Merriweather:400|Lato:400,400italic,700">
<script type="text/javascript" src="https://journey-c.github.io/js/main.js"></script>
<script type="text/javascript" src="https://journey-c.github.io/js/prism.js"></script>



<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-181048644-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>



<script async src="https://www.googletagmanager.com/gtag/js?id=UA-181048644-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-181048644-1');
</script>




<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>


</head>

<body>
    <input type="checkbox" class="hidden toggle" id="toc-control" />

    <main class="wrapper">
        <div>
            <header class="header">
                <nav class="nav">
    <a href="https://journey-c.github.io/" class="nav-logo">
        <img src="https://journey-c.github.io/images/yangguo.png" width="50"
            height="50" alt="Logo">
    </a>

    <ul class="nav-links">
        
        <li><a href="/tags/"></a></li>
        
        <li><a href="/about/">About</a></li>
        
        <li><a href="https://github.com/journey-c">Github</a></li>
        
        <li><a href="/index.xml">RSS</a></li>
        
        <li><a href="https://www.cnblogs.com/wuwangchuxin0924/">博客园</a></li>
        
        <li>
    </ul>
</nav>

            </header>
        </div>

        <div>
            <header class="mobile-header">
                <a href="https://journey-c.github.io/" class="nav-logo">
                    <img src="https://journey-c.github.io/images/yangguo.png"
                        width="50" height="50"
                        alt="Logo">
                </a>
                <ul class="nav-links">
                    
                    <li><a href="/tags/"></a></li>
                    
                    <li><a href="/about/">About</a></li>
                    
                    <li><a href="https://github.com/journey-c">Github</a></li>
                    
                    <li><a href="/index.xml">RSS</a></li>
                    
                    <li><a href="https://www.cnblogs.com/wuwangchuxin0924/">博客园</a></li>
                    
                    <li>
                </ul>
            </header>
        </div>


<div class="content">
    <article class="article">
        
        <span class="article-duration">6 min read</span>
        

        <h1 class="article-title">Linux进程管理和调度（一）</h1>

        
        <span class="article-date">2022-01-23</span>
        

        
        
        
        <a class="article-tag" href="https://journey-c.github.io/tags/linux">Linux</a>
        
        <a class="article-tag" href="https://journey-c.github.io/tags/%E6%BA%90%E7%A0%81">源码</a>
        
        
        

        <div class="toc">
    <details >
        <summary>
            <span class="details">Table Of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e8%bf%9b%e7%a8%8b%e4%bc%98%e5%85%88%e7%ba%a7" aria-label="进程优先级">进程优先级</a></li>
                <li>
                    <a href="#%e8%bf%9b%e7%a8%8b%e8%a1%a8%e7%a4%ba" aria-label="进程表示">进程表示</a><ul>
                        
                <li>
                    <a href="#%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4" aria-label="命名空间">命名空间</a><ul>
                        
                <li>
                    <a href="#%e6%a6%82%e5%bf%b5" aria-label="概念">概念</a></li>
                <li>
                    <a href="#%e5%ae%9e%e7%8e%b0" aria-label="实现">实现</a></li>
                <li>
                    <a href="#%e7%9b%b8%e5%85%b3%e6%93%8d%e4%bd%9c" aria-label="相关操作">相关操作</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%bf%9b%e7%a8%8bid" aria-label="进程ID">进程ID</a><ul>
                        
                <li>
                    <a href="#%e5%85%a8%e5%b1%80id" aria-label="全局ID">全局ID</a></li>
                <li>
                    <a href="#%e5%b1%80%e9%83%a8id" aria-label="局部ID">局部ID</a><ul>
                        
                <li>
                    <a href="#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" aria-label="数据结构">数据结构</a></li>
                <li>
                    <a href="#%e5%87%bd%e6%95%b0" aria-label="函数">函数</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e4%bf%a1%e5%8f%b7%e5%a4%84%e7%90%86" aria-label="信号处理">信号处理</a></li>
                <li>
                    <a href="#%e8%bf%9b%e7%a8%8b%e7%8a%b6%e6%80%81" aria-label="进程状态">进程状态</a></li>
                <li>
                    <a href="#%e8%bf%9b%e7%a8%8b%e8%b0%83%e5%ba%a6" aria-label="进程调度">进程调度</a></li>
                <li>
                    <a href="#%e7%bb%9f%e8%ae%a1%e4%bf%a1%e6%81%af" aria-label="统计信息">统计信息</a></li>
                <li>
                    <a href="#%e8%bf%9b%e7%a8%8b%e5%85%b3%e7%b3%bb" aria-label="进程关系">进程关系</a></li>
                <li>
                    <a href="#%e6%9d%83%e9%99%90%e7%ae%a1%e7%90%86" aria-label="权限管理">权限管理</a></li>
                <li>
                    <a href="#%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86" aria-label="内存管理">内存管理</a></li>
                <li>
                    <a href="#%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f" aria-label="文件系统">文件系统</a></li>
                <li>
                    <a href="#%e6%a0%88%e7%a9%ba%e9%97%b4" aria-label="栈空间">栈空间</a><ul>
                        
                <li>
                    <a href="#%e7%94%a8%e6%88%b7%e6%80%81%e5%87%bd%e6%95%b0%e6%a0%88" aria-label="用户态函数栈">用户态函数栈</a><ul>
                        
                <li>
                    <a href="#32%e4%bd%8d" aria-label="32位">32位</a></li>
                <li>
                    <a href="#64%e4%bd%8d" aria-label="64位">64位</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%86%85%e6%a0%b8%e6%80%81%e5%87%bd%e6%95%b0%e6%a0%88" aria-label="内核态函数栈">内核态函数栈</a></li>
                <li>
                    <a href="#%e7%94%a8%e6%88%b7%e6%80%81task_struct%e6%9f%a5%e6%89%be%e5%86%85%e6%a0%b8%e6%a0%88" aria-label="用户态task_struct查找内核栈">用户态task_struct查找内核栈</a></li>
                <li>
                    <a href="#%e5%86%85%e6%a0%b8%e6%a0%88%e6%9f%a5%e6%89%be%e7%94%a8%e6%88%b7%e6%80%81task_struct" aria-label="内核栈查找用户态task_struct">内核栈查找用户态task_struct</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>


        <div class="article-content">
            <p>几乎所有现代操作系统都支持同时运行若干程序（至少在用户错觉是这样的）。这种错觉是由内核和处理器建立的，在很短的时间间隔内多任务不停切换。由于用户无法注意到短时间内的停滞，所以就造成了感官上的多任务并行。本文就一起来探究一下Linux是如果管理多任务的。</p>
<h1 id="进程优先级">进程优先级</h1>
<p>并非所有进程都具有同样的重要性，比如渲染屏幕的进程收到指令后要尽可能快的反馈到屏幕上，稍慢些用户就会感觉到卡顿，而用户分析计算数据的进程则不需要时刻反馈进度，只需要将结果返回即可。根据这个条件就可以粗略的将进程分为：实时进程和非实时进程。</p>
<ol>
<li>硬实时进程，不能丝毫的耽误，例如火箭发射，机械控制。这些操作需要在规定时间内必须完成，否则会造成严重后果。主流Linux内核是不支持这类型进程的。</li>
<li>软实时进程，可以略微的耽误进度，例如写磁盘操作，需要尽快写到磁盘防止丢失，但机器负载较高时也可以暂停写入。</li>
<li>普通进程，不需要再明确的时间内完成的进程，这种进程就可根据优先级来分配调度。</li>
</ol>
<p>
<div class="post-img-view">
<a data-fancybox="gallery" href="/images/linux-process-management-and-scheduling-process-priority.png">
<img src="/images/linux-process-management-and-scheduling-process-priority.png" alt="linux-process-management-and-scheduling-process-priority"  />
</a>
</div>

</p>
<p>调度时，unix系统中通常的做法是，将CPU时间进行分割，每个进程根据重要性分配一个时间片，然后进程依次使用CPU，时间到了就换下一个，这也就是<strong>抢占式多任务处理</strong>。</p>
<p>
<div class="post-img-view">
<a data-fancybox="gallery" href="/images/linux-process-management-and-scheduling-process-preemptive-multitasking-scheduling.png">
<img src="/images/linux-process-management-and-scheduling-process-preemptive-multitasking-scheduling.png" alt="linux-process-management-and-scheduling-process-preemptive-multitasking-scheduling"  />
</a>
</div>

</p>
<p>这种简单的模型没考虑到几个重要的问题：</p>
<ol>
<li>进程某些时刻就是没有事情在做，占用CPU只会浪费。</li>
<li>时间片力度划分很难有一个标准，单位太小则频繁切换上下文产生无关任务的消耗，单位太大则分配不均匀。</li>
</ol>
<p>Linux的内核开发者就此进行了非常热烈的讨论，Linux的调度算法需要满足进程分类的特点、满足不同负荷，即能在微型计算机上工作，又能在大型计算机上工作。这非常具有挑战性，Linux的调度算法至今进行过两次重大的重写：</p>
<ol>
<li>2.5系列开发过程中，用所谓的O(1)调度器代替了前一个调度器，这个调度器的特点是可以在常数时间内完成调度工作，不依赖进程的数量。</li>
<li>2.6.23版本合并进来的<strong>完全公平调度器</strong>，将Linux真正变成<strong>可用</strong>的操作系统内核，该算法尽可能<strong>公平</strong>的调度每个进程，还可以特别关注某些进程，满足Linux进程分类的特点，也是沿用至今的调度器。这也是本章要讲的核心内容。</li>
</ol>
<h1 id="进程表示">进程表示</h1>
<p>既然要管理任务，就要有一个描述任务的数据结构，操作系统一般用<a href="https://en.wikipedia.org/wiki/Process_(computing)">进程</a>来表示任务，Linux中将进程线程抽象为<a href="https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/sched.h#L640">struct task_struct</a>，<a href="https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/sched.h#L640">struct task_struct</a>中涉及了若干个子系统，十分的复杂，我们一点点来分析。

<div class="post-img-view">
<a data-fancybox="gallery" href="/images/linux-process-management-and-scheduling-process.png">
<img src="/images/linux-process-management-and-scheduling-process.png" alt="linux-process-management-and-scheduling-process"  />
</a>
</div>

</p>
<h2 id="命名空间">命名空间</h2>
<p>在分析其他字段之前，先简单了解一下namespace的概念，因为后边讲的东西多多少少都会涉及这个特性。命名空间提供了虚拟化的一种轻量级形式，使得我们可以从不同的方面来查看运行系统的全局属性。该机制类似于Solaris中的zone或FreeBSD中的jail。</p>
<h3 id="概念">概念</h3>
<p>传统的类UNIX系统中许多资源都是全局管理的，内核统一维护所有进程的ID，以及用户ID等，调用者调用uname命令看到的内核信息都是相同的。</p>
<p>全局管理可以有选择的允许或拒绝某些特权，0号进程几乎可以做任何事，但是其他用户的权限会被收敛，例如用户A不能杀死用户B的进程。虽然用户A不能杀死用户B的进程，但是能看到。Linux是多任务、多用户的的系统，没道理不让看其他用户的活动。</p>
<p>但是在有些情况下，这种特性并不是十分友好，例如云厂商对外提供计算服务，当然要给予他机器所有的权利，最直白的方式是给用户提供物理机，但是用户需要的计算能力不一样，并且采购也需要时间的，运营成品极高。使用KVM或VMWare提供的虚拟化环境是另一种解决问题的方案。但是这种方案的弊端明显，需要先虚出来硬件，然后在此基础上运行操作系统，虽然随着虚拟化的发展，性能损耗可以讲到1%以下。但是创建计算节点的耗时高还是给使用上带来了不便。</p>
<p>
<div class="post-img-view">
<a data-fancybox="gallery" href="/images/linux-process-management-and-scheduling-namespace_1.png">
<img src="/images/linux-process-management-and-scheduling-namespace_1.png" alt="linux-process-management-and-scheduling-namespace_1"  />
</a>
</div>


而命名空间则提供了一种新的解决方案，将所有全局资源通过命名空间抽象起来，将一组进程放入容器中，容器间隔离，但也允许一定程度上的共享，例如两个容器共享同一个文件系统。</p>
<h3 id="实现">实现</h3>
<p>资源隔离后所有资源不再是全局唯一，只有<code>资源+资源所在命名空间</code>的二元组全局唯一。

<div class="post-img-view">
<a data-fancybox="gallery" href="/images/linux-process-management-and-scheduling-namespace_2.png">
<img src="/images/linux-process-management-and-scheduling-namespace_2.png" alt="linux-process-management-and-scheduling-namespace_1"  />
</a>
</div>

</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/* Namespaces: */</span>
<span style="color:#66d9ef">struct</span> nsproxy          <span style="color:#f92672">*</span>nsproxy;
</code></pre></div><p><a href="https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/sched.h#L640">struct task_struct</a>中使用<a href="https://github.com/torvalds/linux/blob/60a9483534ed0d99090a2ee1d4bb0b8179195f51/include/linux/nsproxy.h#L31">struct nsproxy</a>来维护namespace的信息。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">struct</span> nsproxy {
    atomic_t count;
    <span style="color:#66d9ef">struct</span> uts_namespace <span style="color:#f92672">*</span>uts_ns;
    <span style="color:#66d9ef">struct</span> ipc_namespace <span style="color:#f92672">*</span>ipc_ns;
    <span style="color:#66d9ef">struct</span> mnt_namespace <span style="color:#f92672">*</span>mnt_ns;
    <span style="color:#66d9ef">struct</span> pid_namespace <span style="color:#f92672">*</span>pid_ns_for_children;
    <span style="color:#66d9ef">struct</span> net       <span style="color:#f92672">*</span>net_ns;
    <span style="color:#66d9ef">struct</span> time_namespace <span style="color:#f92672">*</span>time_ns;
    <span style="color:#66d9ef">struct</span> time_namespace <span style="color:#f92672">*</span>time_ns_for_children;
    <span style="color:#66d9ef">struct</span> cgroup_namespace <span style="color:#f92672">*</span>cgroup_ns;
};
</code></pre></div><p>当前内核可以感知以下命名空间</p>
<ul>
<li>uts_ns 记录了内核名称、版本、体系结构等信息，通过<code>uname</code>系统调用可以获取</li>
<li>ipc_us 记录了进程间通信的信息</li>
<li>mnt_ns 已经装载的文件系统的视图</li>
<li>pid_ns_for_children 进程ID相关的信息</li>
<li>net_ns 包含所有网络相关的命名空间参数</li>
<li>time_ns和time_ns_for_children 维护了时间相关信息</li>
<li>cgroup_ns 包含了计算资源分配相关的信息，例如CPU、内存、磁盘I/O等</li>
<li>count是引用计数，各task通过指针指向相同的nsproxy，所以这里有一个引用计数</li>
</ul>
<p>相同namespace进程通过指针指向同一个nsproxy结构，反之的指向不同nsproxy，这样就做到改变只影响本namespace。</p>
<h3 id="相关操作">相关操作</h3>
<p>使用最频繁的操作就是获取当前进程所在的命名空间了。</p>
<ol>
<li>如果没有给定数字类型pid或者struct task_struct结构体，就使用get_current()获取当前进程。</li>
<li>根据task_struct-&gt;thread_pid-&gt;level取出第几个struct upid</li>
<li>struct upid中有对应的struct pid_namespace</li>
</ol>
<h2 id="进程id">进程ID</h2>
<p>进程作为操作系统的一个核心概念，每个进程都有自己的ID：进程ID，也有自己的生命周期。

<div class="post-img-view">
<a data-fancybox="gallery" href="/images/linux-process-management-and-scheduling-life-cycle.png">
<img src="/images/linux-process-management-and-scheduling-life-cycle.png" alt="linux-process-management-and-scheduling-life-cycle"  />
</a>
</div>

</p>
<p>子进程有父进程，父进程也有父进程，这样就形成了以init进程为根的家族树。除了纵向的关系，还有横向的关系：进程组、会话组。</p>
<p>
<div class="post-img-view">
<a data-fancybox="gallery" href="/images/linux-process-management-and-scheduling-process_groups_and_session_groups.png">
<img src="/images/linux-process-management-and-scheduling-process_groups_and_session_groups.png" alt="linux-process-management-and-scheduling-process_groups_and_session_groups"  />
</a>
</div>

</p>
<p>进程组和会话组的之间又形成了两级的关系：进程组是一组进程的集合，而会话组则是一组相关进程组的集合。</p>
<ul>
<li>进程组组长，linux中直接在task_struct中用变量<a href="https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/sched.h#L859">task_struct-&gt;group_leader</a>指向进程组组长。</li>
<li>会话组组长，进程组组成会话组，所以会话内某个进程组组长就是会话组组长，每个进程组组长都有一个变量<a href="https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/sched/signal.h#L162">task_struct-&gt;group_leader-&gt;signal-&gt;leader</a>来表示自己是不是会话组组长。</li>
</ul>
<p>由上边的描述，进程就需要三个ID来标识不同身份：</p>
<ul>
<li>进程ID（PID）进程的唯一标识。</li>
<li>进程组ID（PGID）一般为进程组组长的PID，创建新进程是默认会继承父进程PGID。</li>
<li>会话ID（SID）一般为会话组组长的PID，创建新进程是默认会继承父进程SID。</li>
</ul>
<p>再细分的话，进程内部的工作单位还有线程，几个线程也可以合并为一个线程组。这样就又需要两个ID来标识身份：</p>
<ul>
<li>线程ID（TID）Linux中当task_struct作为线程时、其TID的值为PID。</li>
<li>线程组ID（TGID）为线程组组长的TID，而线程组组长的TID就是整个进程的ID，所以Linux中又以TID是否为PID来判断线程是否为主线程。</li>
</ul>
<p>
<div class="post-img-view">
<a data-fancybox="gallery" href="/images/linux-process-management-and-scheduling-process-id.png">
<img src="/images/linux-process-management-and-scheduling-process-id.png" alt="linux-process-management-and-scheduling-process-id"  />
</a>
</div>

</p>
<p>如果没有命名空间的特性的话，内核可以直接在struct task_struct使用五个数字类型的ID来表示上面定义的ID。但是命名空间的特性使得各种ID的维护变得更加的复杂。</p>
<p>PID的命名空间类似树形的层次结构，创建一个新的命名空间时，该空间内所有的PID都是对父命名空间以及上层的命名空间可见的。往上多一层就要多一个ID表示。</p>
<p>
<div class="post-img-view">
<a data-fancybox="gallery" href="/images/linux-process-management-and-scheduling-process-id-namespace_1.png">
<img src="/images/linux-process-management-and-scheduling-process-id-namespace_1.png" alt="linux-process-management-and-scheduling-process-id-namespace_1"  />
</a>
</div>

</p>
<p>例如图中进程，对init命名空间、命名空间2、命名空间4可见，则PID就需要三个值来分别在三个命名空间表示唯一。</p>
<p>根据命名空间的分层，可以将PID分成两类：全局ID、局部ID</p>
<ol>
<li>全局ID，是内核本身和初始命名空间(init进程所在namespace)的ID号。</li>
<li>局部ID，属于某个特定namespace，不同namespace间可以相同，但namespace内部不同。</li>
</ol>
<h3 id="全局id">全局ID</h3>
<p>首先全局的pid和tgid直接保存在struct task_struct中。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">struct</span> task_struct {
    ...
    pid_t pid;
    pid_t tgid;
    ...
};
</code></pre></div><p>其余全局ID都可以用这两个ID来表示：</p>
<ul>
<li>全局SID，为会话组组长的全局pid。</li>
<li>全局PGID，为进程组组长的全局pid。</li>
<li>全局TID，当task_struct为线程时，pid就是tid，则全局pid也就是全局tid</li>
</ul>
<h3 id="局部id">局部ID</h3>
<p>除了全局ID这两个字段之外，内核还需要管理局部ID，因为增加了namespace的特性，所以这需要几个相互联系的数据结构，以及辅助函数。</p>
<h4 id="数据结构">数据结构</h4>
<p>先来看一下pid的<a href="https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/pid_namespace.h#L20">namespace</a>表示方式。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">struct</span> pid_namespace {
    ...
	<span style="color:#66d9ef">struct</span> task_struct <span style="color:#f92672">*</span>child_reaper;
    ...
	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> level;
	<span style="color:#66d9ef">struct</span> pid_namespace <span style="color:#f92672">*</span>parent;
    ...
} __randomize_layout;
</code></pre></div><p>其中主要的变量：</p>
<ul>
<li>child_reaper 每个命名空间必须绑定一个进程，这个进程就相当于init进程，该进程也必须完成init进程的工作，例如对孤儿进程调用<code>wait4</code>。</li>
<li>parent 指向父命名空间。level表示当前命名空间的深度，初始为0，依次递增。level较低命名空间对较高命名空间可见。</li>
</ul>
<p>局部pid的管理主要围绕两个数据结构：<a href="https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/pid.h#L59">struct pid</a>是内核对局部ID的表示，而<a href="https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/pid.h#L54">struct upid</a>则是PID在namespace内的可见信息。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">struct</span> upid {
    <span style="color:#66d9ef">int</span> nr;
    <span style="color:#66d9ef">struct</span> pid_namespace <span style="color:#f92672">*</span>ns;
};
<span style="color:#66d9ef">struct</span> pid
{
    refcount_t count;
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> level;
    spinlock_t lock;
    <span style="color:#75715e">/* 使用该pid的进程列表 */</span>
    <span style="color:#66d9ef">struct</span> hlist_head tasks[PIDTYPE_MAX];
    <span style="color:#66d9ef">struct</span> hlist_head inodes;
    <span style="color:#75715e">/* wait queue for pidfd notifications */</span>
    wait_queue_head_t wait_pidfd;
    <span style="color:#66d9ef">struct</span> rcu_head rcu;
    <span style="color:#66d9ef">struct</span> upid numbers[<span style="color:#ae81ff">1</span>];
};
</code></pre></div><p>首先是<a href="https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/pid.h#L54">struct upid</a>，变量nr表示id的数值，比如执行shell命令<code>ps</code>得到的PID就是取的这个值。ns指向对应的namespace。这样一个数据结构就能在增加namespace特性的情况下唯一的表示一个局部ID。</p>
<p><a href="https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/pid.h#L59">struct pid</a>中count是一个引用计数，task是一个散列数组，包含了所有引用该struct pid的进程。因为同一个ID可能用于几个进程。比如进程组内进程组ID相同等。PIDTYPE_MAX表示ID的类型数。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">enum</span> pid_type
{
    PIDTYPE_PID,
    PIDTYPE_TGID,
    PIDTYPE_PGID,
    PIDTYPE_SID,
    PIDTYPE_MAX,
};
</code></pre></div><p>一个进程可能对多个namespace都可见，所以level表示namespace的深度，如图左下角。而numbers对应一个<a href="https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/pid.h#L54">struct upid</a>的数组，长度为level，表示在每个namespace的ID。<strong>注意该数组形式上只有一个数组项，如果一个进程只包含在全局命名空间中，那么确实如此。由于该数组位于结构的末尾，因此 只要分配更多的内存空间，即可向数组添加附加的项。</strong></p>
<p>
<div class="post-img-view">
<a data-fancybox="gallery" href="/images/linux-process-management-and-scheduling-process-id-2.png">
<img src="/images/linux-process-management-and-scheduling-process-id-2.png" alt="linux-process-management-and-scheduling-process-id-2"  />
</a>
</div>

</p>
<p>这三个数据结构的关系如上图：</p>
<ul>
<li>struct task_struct内部会有指向struct pid的指针，方便查找ID时找到数据结构。指向struct pid的指针也做了分类，像PID、TID这种一般不会进行<strong>组操作的ID</strong>就用struct pid *thread_pid指针缓存，查找PID时直接用这个指针。而PGID、TGID、SID这种需要<strong>组操作的ID</strong>就放在task_struct-&gt;signal-&gt;pids[PID_TYPE]里面，查找这三类ID时就直接从task_struct-&gt;signal-&gt;pids[PID_TYPE]查。</li>
<li>同时struct pid也会缓存引用他的struct task_struct，将引用他的struct task_struct都放在自身tasks变量中。</li>
<li>struct pid中level变量会记录当前struct pid在第几层namespace，而pid-&gt;numbers记录了ID在各层ID数值。</li>
</ul>
<h4 id="函数">函数</h4>
<p>内核提供了若干函数辅助操作上面的三个数据结构，但本质离不开两个问题：</p>
<ol>
<li>给定局部数字类型ID和namespace，如何找到对应的struct pid。</li>
<li>给出task_struct、ID类型和namespace，如何找到数字类型的ID。</li>
</ol>
<p>在这两个问题之前，有个问题：如何找到进程所在的namespace？</p>
<p>
<div class="post-img-view">
<a data-fancybox="gallery" href="/images/linux-process-management-and-scheduling-process-id-find-namespace.png">
<img src="/images/linux-process-management-and-scheduling-process-id-find-namespace.png" alt="linux-process-management-and-scheduling-process-id-find-namespace"  />
</a>
</div>

</p>
<p>首先如果没给定task_struct的话，可以调用<a href="https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/arch/x86/include/asm/current.h#L18">current</a>宏获取当前所在task_struct。</p>
<p>然后调用<a href="https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/kernel/pid.c#L507">task_active_pid_ns</a>获取namespace，大概流程就是，通过task_struct-&gt;thread_pid指针获的指向的struct pid，其变量记录了当前所在第几层namespace，然后从pid-&gt;numbers[level]变量中取出对应的struct upid，其变量记录了对应的namespace。</p>
<p>再回到前边两个问题:</p>
<p><strong>[1]给定局部数字类型ID和namespace，如何找到对应的struct pid?</strong></p>
<p>内核用<a href="https://en.wikipedia.org/wiki/Radix_tree">基数树</a>存储局部ID到struct pid的映射，实际就是存储了局部ID（数字类型）对应的struct pid的内存地址（数字）。</p>
<p>通过<a href="https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/kernel/pid.c#L309">find_pid_ns</a>找到局部ID对应的struct pid对象。</p>
<p>然后根据需要的ID的类型取出pid-&gt;tasks[ID_TYPE]散列表中第一个实例。</p>
<p><strong>[2] 给出task_struct、ID类型和namespace，如何找到数字类型的ID?</strong></p>
<ol>
<li>通过task_struct和ID类型拿到struct pid:
<ol>
<li>PID/TID: 取task_struct-&gt;thread_pid</li>
<li>其他类型:
<ol>
<li>PGID: 通过task_struct-&gt;group_leader找到进程组组长对应的task_struct</li>
<li>TGID: 线程组ID就是PID，调用<a href="https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/arch/x86/include/asm/current.h#L18">current</a>获取task_struct</li>
<li>SID: 调用<a href="https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/arch/x86/include/asm/current.h#L18">current</a>获取task_struct。</li>
<li>分别调用<a href="https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/sched.h#L1368">task_pid</a>、<a href="https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/sched/signal.h#L637">task_pgrp</a>、<a href="https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/sched/signal.h#L627">task_tgid</a>、<a href="https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/sched/signal.h#L642">task_session</a>获取对应的struct pid</li>
</ol>
</li>
</ol>
</li>
<li>然后根据struct pid和namespace找到对应数字类型ID，这里实际就是用namespace里的level去struct pid里取第几个struct upid，然后struct upid的成员变量nr就是所需要的数字类型id。</li>
</ol>
<h2 id="信号处理">信号处理</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/* Signal handlers: */</span>
<span style="color:#66d9ef">struct</span> signal_struct        <span style="color:#f92672">*</span>signal;
<span style="color:#66d9ef">struct</span> sighand_struct __rcu     <span style="color:#f92672">*</span>sighand;
sigset_t            blocked;
sigset_t            real_blocked;
<span style="color:#75715e">/* Restored if set_restore_sigmask() was used: */</span>
sigset_t            saved_sigmask;
<span style="color:#66d9ef">struct</span> sigpending       pending;
<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>           sas_ss_sp;
size_t              sas_ss_size;
<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>            sas_ss_flags;
</code></pre></div><p>这里定义了哪些信号被阻塞暂不处理（blocked），哪些信号尚等待处理（pending），哪些信号正在通过信号处理函数进行处理（sighand）。处理的结果可以是忽略，可以是结束进程等等。</p>
<p>信号处理函数默认使用用户态的函数栈，当然也可以开辟新的栈专门用于信号处理，这就是 sas_ss_xxx 这三个变量的作用。</p>
<h2 id="进程状态">进程状态</h2>
<p>
<div class="post-img-view">
<a data-fancybox="gallery" href="/images/linux-process-management-and-scheduling-process-life-cycle.png">
<img src="/images/linux-process-management-and-scheduling-process-life-cycle.png" alt="linux-process-management-and-scheduling-process-life-cycle"  />
</a>
</div>

</p>
<p>也就是进程的生命周期，Linux内核将上面的状态又进行了更细的划分。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/* -1 unrunnable, 0 runnable, &gt;0 stopped: */</span>
<span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">long</span> state;

<span style="color:#66d9ef">int</span> exit_state;
<span style="color:#66d9ef">int</span> exit_code;
<span style="color:#66d9ef">int</span> exit_signal;

<span style="color:#75715e">/* Per task flags (PF_*), defined further below: */</span>
<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>            flags;
</code></pre></div><p>task_struct-&gt;state表示进程的状态，取值如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/* Used in tsk-&gt;state: */</span>
<span style="color:#75715e">#define TASK_RUNNING            0x0000
</span><span style="color:#75715e">#define TASK_INTERRUPTIBLE      0x0001
</span><span style="color:#75715e">#define TASK_UNINTERRUPTIBLE        0x0002
</span><span style="color:#75715e">#define __TASK_STOPPED          0x0004
</span><span style="color:#75715e">#define __TASK_TRACED           0x0008
</span></code></pre></div><ul>
<li>TASK_RUNNING 处于运行态进程（可被调度，不一定正在使用CPU）</li>
<li>TASK_INTERRUPTIBLE 处于睡眠中的进程，可以被唤醒。例如正在做I/O操作，但这时候来了一个信号，还是可以唤醒这个进程的</li>
<li>TASK_UNINTERRUPTIBLE 处于睡眠中并且不会被任何信号唤醒，只能等待操作完成，假如操作因为某些特殊原因完成不了，那么这个进程就无法被唤醒了，kill信号也无法唤醒，因为信号已经被忽略了。所以这是一个非常危险的状态，如果没有百分百的把握就不要将进程设置为这种状态。</li>
<li>__TASK_STOPPED 暂停状态，收到某种信号暂停运行。SIGSTOP、SIGTSTP、SIGTTIN、SIGTTOUT这些信号都能使进程陷入暂停。</li>
<li>__TASK_TRACED 被追踪状态，例如使用gdb调试进程时，进程就处于__TASK_TRACED态。</li>
</ul>
<p>使用时，state会是这几种状态中的一种，或者几种状态的组合（通过bit操作）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/* Used in tsk-&gt;exit_state: */</span>
<span style="color:#75715e">#define EXIT_DEAD           0x0010
</span><span style="color:#75715e">#define EXIT_ZOMBIE         0x0020
</span></code></pre></div><p>EXIT_DEAD 和 EXIT_ZOMBIE都表示进程终止，有什么区别呢？</p>
<ul>
<li>EXIT_ZOMBIE 当进程结束时，最先进入EXIT_ZOMBIE态，这时只是任务执行完了，但是父进程还没执行wait()调用</li>
<li>EXIT_DEAD 当父进程执行wait调用后，进程进入最终态EXIT_DEAD，就可以进行清理回收工作了</li>
</ul>
<h2 id="进程调度">进程调度</h2>
<p>以下是task_struct中调度相关的参数，这里就不细讲了，后边用到时在作说明。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// 标识：当前是否在运行队列
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span>             on_rq;

<span style="color:#75715e">// 优先级
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span>             prio;
<span style="color:#66d9ef">int</span>             static_prio;
<span style="color:#66d9ef">int</span>             normal_prio;
<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>            rt_priority;

<span style="color:#75715e">// 调度器类
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> sched_class    <span style="color:#f92672">*</span>sched_class;
<span style="color:#75715e">// 调度实体
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> sched_entity     se;
<span style="color:#66d9ef">struct</span> sched_rt_entity      rt;
<span style="color:#66d9ef">struct</span> sched_dl_entity      dl;

<span style="color:#75715e">// 调度策略
</span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>            policy;

<span style="color:#75715e">// CPU可使用情况
</span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>            policy;
<span style="color:#66d9ef">int</span>             nr_cpus_allowed;
<span style="color:#66d9ef">const</span> cpumask_t         <span style="color:#f92672">*</span>cpus_ptr;
cpumask_t           cpus_mask;

<span style="color:#66d9ef">struct</span> sched_info       sched_info;
</code></pre></div><h2 id="统计信息">统计信息</h2>
<p>生产中通常都会用各种工具查看进程的状态和一些指标，而这些值task_struct也是需要维护起来的。并且调度时也需要根据这些指标来挑选运行的进程。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// 用户态消耗CPU时间
</span><span style="color:#75715e"></span>u64             utime;
<span style="color:#75715e">// 内核态消耗CPU时间
</span><span style="color:#75715e"></span>u64             stime;
<span style="color:#75715e">// 用户态进程组消耗CPU时间
</span><span style="color:#75715e"></span>u64             gtime;

<span style="color:#75715e">// 主动上下文切换次数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>           nvcsw;
<span style="color:#75715e">// 被动上下文切换次数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>           nivcsw;

<span style="color:#75715e">// 进程启动时间（不包含睡眠）
</span><span style="color:#75715e"></span>u64             start_time;
<span style="color:#75715e">// 进程启动时间（包含睡眠）
</span><span style="color:#75715e"></span>u64             start_boottime;
</code></pre></div><h2 id="进程关系">进程关系</h2>
<p>这里的进程关系是指纵向的父子关系。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">struct</span> task_struct __rcu    <span style="color:#f92672">*</span>real_parent;
<span style="color:#66d9ef">struct</span> task_struct __rcu    <span style="color:#f92672">*</span>parent;

<span style="color:#66d9ef">struct</span> list_head        children;
<span style="color:#66d9ef">struct</span> list_head        sibling;
</code></pre></div><p>
<div class="post-img-view">
<a data-fancybox="gallery" href="/images/linux-process-management-and-scheduling-process-process-relationship.png">
<img src="/images/linux-process-management-and-scheduling-process-process-relationship.png" alt="linux-process-management-and-scheduling-process-process-relationship"  />
</a>
</div>

</p>
<ul>
<li>real_parent 真实父进程，例如使用bash启动GDB调试一个进程，则real_parent为bash</li>
<li>parent 父进程</li>
<li>children 子进程列表</li>
<li>sibling 兄弟进程列表</li>
</ul>
<h2 id="权限管理">权限管理</h2>
<p>Linux作为多任务、多用户的操作系统，自然要合理的分配管理每个用户的权限。task_struct中权限相关字段如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/* Process credentials: */</span>

<span style="color:#75715e">/* Tracer&#39;s credentials at attach: */</span>
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> cred __rcu     <span style="color:#f92672">*</span>ptracer_cred;

<span style="color:#75715e">/* Objective and real subjective task credentials (COW): */</span>
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> cred __rcu     <span style="color:#f92672">*</span>real_cred;

<span style="color:#75715e">/* Effective (overridable) subjective task credentials (COW): */</span>
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> cred __rcu     <span style="color:#f92672">*</span>cred;
</code></pre></div><ul>
<li>ptracer_cred trace进程对本进程的权限，例如GDB调试时，可以拥有哪些对被调试进程的权限。</li>
<li>real_cred 其他进程对本进程的权限</li>
<li>cred 本进程对其他进程的权限</li>
</ul>
<p>接着看struct cred的定义:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">struct</span> cred {
    ...
    kuid_t      uid;        <span style="color:#75715e">/* real UID of the task */</span>
    kgid_t      gid;        <span style="color:#75715e">/* real GID of the task */</span>
    kuid_t      suid;       <span style="color:#75715e">/* saved UID of the task */</span>
    kgid_t      sgid;       <span style="color:#75715e">/* saved GID of the task */</span>
    kuid_t      euid;       <span style="color:#75715e">/* effective UID of the task */</span>
    kgid_t      egid;       <span style="color:#75715e">/* effective GID of the task */</span>
    kuid_t      fsuid;      <span style="color:#75715e">/* UID for VFS ops */</span>
    kgid_t      fsgid;      <span style="color:#75715e">/* GID for VFS ops */</span>
    ...
    kernel_cap_t    cap_inheritable; <span style="color:#75715e">/* caps our children can inherit */</span>
    kernel_cap_t    cap_permitted;  <span style="color:#75715e">/* caps we&#39;re permitted */</span>
    kernel_cap_t    cap_effective;  <span style="color:#75715e">/* caps we can actually use */</span>
    kernel_cap_t    cap_bset;   <span style="color:#75715e">/* capability bounding set */</span>
    kernel_cap_t    cap_ambient;    <span style="color:#75715e">/* Ambient capability set */</span>
    ...
} __randomize_layout;
</code></pre></div><p>前几个参数控制用户和组权限</p>
<ul>
<li>uid gid 启动该进程的进程的userid和groupid。实际使用时不会审核这个。</li>
<li>euid egid 如注释，审核时使用的userid和groupid</li>
<li>suid sgid 作为tmpid，当euid和egid切换时，临时保存</li>
<li>fsuid fsgid 审核文件权限时使用</li>
</ul>
<p>除了用户和组权限的管理，还有用户等级（能力）的管理，例如root和普通用户权利就不同。平常创建进程时要么用root权限要么用普通用户权限，但Linux实际具有非常详细的<a href="https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/uapi/linux/capability.h#L106">权限划分</a>，叫做 capabilities机制。用位图表示是否有哪项权限。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#define CAP_CHOWN            0
</span><span style="color:#75715e">#define CAP_DAC_OVERRIDE     1
</span><span style="color:#75715e">#define CAP_DAC_READ_SEARCH  2
</span><span style="color:#75715e">#define CAP_FOWNER           3
</span><span style="color:#75715e"></span>...
</code></pre></div><p>当有某项权限就可以做那项事情，没有则不可以，<a href="https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/cred.h#L111">struct cred</a>中:</p>
<ul>
<li>cap_permitted 表示进程被允许的权限，和cap_effective有差异。</li>
<li>cap_inheritable 表示哪些权限可被继承，就是exec新进程时，哪些权限可以被加到新进程的cap_permitted中。</li>
<li>cap_effective 表示进程能使用哪些权限，是cap_permitted的子集。</li>
<li>cap_bset 使系统保留权限，如果cap_bset中没有某项权限，则所有进程都没有（包括root）。</li>
<li>cap_ambient 是新加入的权限，为了解决继承问题，之前继承权限只会加入到新进程cap_permitted中，而cap_ambient会被同时加入到cap_permitted和cap_effective中。</li>
</ul>
<h2 id="内存管理">内存管理</h2>
<p>进程就是若干个子系统的集合，而内存模块的变量如下，这里就不多讲了，在<a href="/linux-memory-management/">《Linux内存管理》</a>中讲得很详细了。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">struct</span> mm_struct        <span style="color:#f92672">*</span>mm;
<span style="color:#66d9ef">struct</span> mm_struct        <span style="color:#f92672">*</span>active_mm;
</code></pre></div><h2 id="文件系统">文件系统</h2>
<p>文件子系统相关的字段如下。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/* Filesystem information: */</span>
<span style="color:#66d9ef">struct</span> fs_struct        <span style="color:#f92672">*</span>fs;

<span style="color:#75715e">/* Open file information: */</span>
<span style="color:#66d9ef">struct</span> files_struct     <span style="color:#f92672">*</span>files;
</code></pre></div><ul>
<li>fs 表示文件系统的类型</li>
<li>files 表示本进程已打开的文件信息</li>
</ul>
<h2 id="栈空间">栈空间</h2>
<p>进程的执行实际就是一行行代码和函数的执行，函数的执行离不开栈来保存现场以及各种参数。除了单纯的调用，进程还要处理用户态和内核态的调用关系，例如系统调用的时候，函数怎么从用户栈跳到内核栈，然后再回来。</p>
<p>涉及变量如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/*
</span><span style="color:#75715e"> * For reasons of header soup (see current_thread_info()), this
</span><span style="color:#75715e"> * must be the first element of task_struct.
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">struct</span> thread_info      thread_info;
<span style="color:#66d9ef">void</span>                <span style="color:#f92672">*</span>stack;
</code></pre></div><p>先来了解一下什么是栈？栈的本质也是一段内存，下面是进程的虚拟内存的布局。

<div class="post-img-view">
<a data-fancybox="gallery" href="/images/memory-management-user-mode-memory-layout.png">
<img src="/images/memory-management-user-mode-memory-layout.png" alt="memory-management-user-mode-memory-layout"  />
</a>
</div>

</p>
<p>最上边是内核态，再往下过了分界线一段后是用户态的栈空间。进程操作时的入栈出栈都是操作的这块空间。除了空间还有两个CPU的寄存器辅助操作：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>32位名称</th>
<th>64位名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>栈顶指针寄存器</td>
<td>ESP</td>
<td>rsp</td>
</tr>
<tr>
<td>栈基地址指针寄存器</td>
<td>EBP</td>
<td>rbp</td>
</tr>
<tr>
<td>返回值寄存器</td>
<td>EAX</td>
<td>rax</td>
</tr>
</tbody>
</table>
<p>基地址指针寄存器存放的值表示，本次操作数据是从哪开始放的。
栈顶指针寄存器存放的值表示，本次操作的数据放到哪了。
本次操作结束，有数据返回时，繁缛返回寄存器。</p>
<p>通过 栈空间 + 栈操作寄存器 组成了进程的逻辑意义上的<code>栈</code>。</p>
<p>下面通过函数调用的例子分析下栈的细节。</p>
<h3 id="用户态函数栈">用户态函数栈</h3>
<h4 id="32位">32位</h4>
<p>函数调用的本质实际是代码的跳转。如果只有代码的跳转则不需要涉及太多东西，但是函数调用往往涉及参数的传递，以及跳过去再怎么跳过回来的问题。</p>
<p>结合交叉编译的32位汇编代码分析这个例子：A 调用 B，B 返回 A。</p>
<ul>
<li>Linux上交叉编译32位代码</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// main.c
</span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">B</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b)
{
    <span style="color:#66d9ef">return</span> a <span style="color:#f92672">+</span> b;
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">A</span>()
{
    <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
    <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> a <span style="color:#f92672">+</span> b;
    <span style="color:#66d9ef">return</span> B(a, b) <span style="color:#f92672">+</span> c;
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> argv[])
{
    printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, A());
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#75715e">/*
</span><span style="color:#75715e"> * sudo apt-get install build-essential module-assistant
</span><span style="color:#75715e"> * sudo apt-get install gcc-multilib g++-multilib
</span><span style="color:#75715e"> * cc -S -m32 main.c
</span><span style="color:#75715e"> */</span>
</code></pre></div><p>
<div class="post-img-view">
<a data-fancybox="gallery" href="/images/linux-process-management-and-scheduling-process-user-stack-1.png">
<img src="/images/linux-process-management-and-scheduling-process-user-stack-1.png" alt="linux-process-management-and-scheduling-process-user-stack-1"  />
</a>
</div>

</p>
<div>
	<center>(上图的状态处于A调用B函数，B函数的执行中，一小格=4B)</center>
</div>
<p>A函数栈帧中：</p>
<ul>
<li>首先将main函数栈帧基地址ebp入栈
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">pushl</span>   %ebp
</code></pre></div></li>
<li>然后开辟A函数的栈帧
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">movl</span>    %esp, %ebp
</code></pre></div></li>
<li>然后存放A函数中局部变量
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">subl</span>    <span style="color:#66d9ef">$16</span>, %esp
<span style="color:#a6e22e">movl</span>    <span style="color:#66d9ef">$1</span>, -<span style="color:#ae81ff">12</span>(%ebp)
<span style="color:#a6e22e">movl</span>    <span style="color:#66d9ef">$2</span>, -<span style="color:#ae81ff">8</span>(%ebp)
<span style="color:#a6e22e">movl</span>    -<span style="color:#ae81ff">12</span>(%ebp), %edx
<span style="color:#a6e22e">movl</span>    -<span style="color:#ae81ff">8</span>(%ebp), %eax
<span style="color:#a6e22e">addl</span>    %edx, %eax
<span style="color:#a6e22e">movl</span>    %eax, -<span style="color:#ae81ff">4</span>(%ebp)
</code></pre></div></li>
<li>然后调用B函数，先是参数入栈
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">pushl</span>   -<span style="color:#ae81ff">8</span>(%ebp)
<span style="color:#a6e22e">pushl</span>   -<span style="color:#ae81ff">12</span>(%ebp)
</code></pre></div></li>
<li>调用B函数的call指令会顺便将A函数返回地址也入栈
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">call</span>    <span style="color:#66d9ef">B</span> 
</code></pre></div></li>
</ul>
<p>到此位置A函数的栈帧基本形成了，如上图，由栈底开始依次是上一个函数ebp，局部变量、下一个函数参数、返回地址。</p>
<p><code>局部变量和参数之间根据栈帧的长度会有一定的填充</code>，保持内存空间与16字节对齐。</p>
<h4 id="64位">64位</h4>
<p>64位和32位栈帧组成差不多，唯一的区别就是64位机器寄存器多了，函数参数前六个参数可以放在rax、rsi、rdx、rcx、r8d、r9d上。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// main.c
</span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">B</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b, <span style="color:#66d9ef">int</span> c, <span style="color:#66d9ef">int</span> d, <span style="color:#66d9ef">int</span> e, <span style="color:#66d9ef">int</span> f, <span style="color:#66d9ef">int</span> g)
{
    <span style="color:#66d9ef">return</span> a <span style="color:#f92672">+</span> b <span style="color:#f92672">+</span> c <span style="color:#f92672">+</span> d <span style="color:#f92672">+</span> e <span style="color:#f92672">+</span> f <span style="color:#f92672">+</span> g;
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">A</span>()
{
    <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
    <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
    <span style="color:#66d9ef">int</span> d <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;
    <span style="color:#66d9ef">int</span> e <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
    <span style="color:#66d9ef">int</span> f <span style="color:#f92672">=</span> <span style="color:#ae81ff">6</span>;
    <span style="color:#66d9ef">int</span> g <span style="color:#f92672">=</span> <span style="color:#ae81ff">7</span>;
    <span style="color:#66d9ef">return</span> B(a, b, c, d, e, f, g);
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> argv[])
{
    printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, A());
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#75715e">/*
</span><span style="color:#75715e"> * cc -S main.c
</span><span style="color:#75715e"> */</span>
</code></pre></div><p>
<div class="post-img-view">
<a data-fancybox="gallery" href="/images/linux-process-management-and-scheduling-process-user-stack-2.png">
<img src="/images/linux-process-management-and-scheduling-process-user-stack-2.png" alt="linux-process-management-and-scheduling-process-user-stack-2"  />
</a>
</div>

</p>
<p>64位系统中：</p>
<ul>
<li>保存main函数的栈基地址指针寄存器</li>
<li>开辟A的栈帧，并且将局部变量a～g放入栈中</li>
<li>前六个参数入寄存器：rax、rsi、rdx、rcx、r8d、r9d。第七个参数入栈</li>
<li>调用B函数，然后返回结果，最后返回main函数</li>
</ul>
<h3 id="内核态函数栈">内核态函数栈</h3>
<p>进程不光要在用户态运行，涉及系统调用以及其他情况时也要在内核态运行。在内核态运行时同样会涉及函数调用传参，这块布局不常见。</p>
<p>进程的<a href="https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/sched.h#L657">stack</a>变量的作用就是维护内核态的栈空间。源码中定义内核栈初始大小的变量为：<a href="https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/sched.h#L1726">THREAD_SIZE</a>，</p>
<p>32位机器中定义如下，PAGE_SIZE=4KB，所以内核栈初始大小位8KB</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#define THREAD_SIZE_ORDER   1
</span><span style="color:#75715e">#define THREAD_SIZE     (PAGE_SIZE &lt;&lt; THREAD_SIZE_ORDER)
</span></code></pre></div><p>64位机器中定义如下，内核初始大小为16KB，并且要求起始地址与16KB对齐。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#ifdef CONFIG_KASAN
</span><span style="color:#75715e">#define KASAN_STACK_ORDER 1
</span><span style="color:#75715e">#else
</span><span style="color:#75715e">#define KASAN_STACK_ORDER 0
</span><span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#define THREAD_SIZE_ORDER   (2 + KASAN_STACK_ORDER)
</span><span style="color:#75715e">#define THREAD_SIZE  (PAGE_SIZE &lt;&lt; THREAD_SIZE_ORDER)
</span></code></pre></div><p>
<div class="post-img-view">
<a data-fancybox="gallery" href="/images/linux-process-management-and-scheduling-process-user-stack-3.png">
<img src="/images/linux-process-management-and-scheduling-process-user-stack-3.png" alt="linux-process-management-and-scheduling-process-user-stack.png"  />
</a>
</div>

</p>
<p>由高地址到低地址，首先是预留8字节，接下来是<a href="https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/arch/x86/include/asm/ptrace.h#L56">pt_regs</a>结构体，存放的是寄存器信息，进程处于内核态时大部分情况都是从用户态进入的，所以要保存当时寄存器里值。仔细观察寄存器的顺序就会发现，汇编代码中使用寄存器的顺序就是按照变量在结构体中的顺序来的。</p>
<p>最后一部分是<a href="https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/arch/x86/include/asm/thread_info.h#L56">thread_info</a>结构体，里面存放的也是进程信息，task_struct中存放的是通用信息，thread_info中存放的是与体系有关的东西。</p>
<p>内核栈使用时和用户态</p>
<h3 id="用户态task_struct查找内核栈">用户态task_struct查找内核栈</h3>
<p>上小结就提到了task_struct-&gt;stack指向了内核栈的最顶端(thread_info位置不是栈顶)，所以用户态查找内核栈时就可以通过<a href="https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/sched/task_stack.h#L19">task_stack_page</a>函数取stack的值。</p>
<p>使用<a href="https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/arch/x86/include/asm/processor.h#L772">task_pt_regs</a>调用可以获得寄存器信息。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#define task_pt_regs(task) \
</span><span style="color:#75715e">({									\
</span><span style="color:#75715e">	unsigned long __ptr = (unsigned long)task_stack_page(task);	\
</span><span style="color:#75715e">	__ptr += THREAD_SIZE - TOP_OF_KERNEL_STACK_PADDING;		\
</span><span style="color:#75715e">	((struct pt_regs *)__ptr) - 1;					\
</span><span style="color:#75715e">})
</span></code></pre></div><p>分析下过程：</p>
<ul>
<li>首先是通过task_stack_page函数获取栈顶地址</li>
<li>然后向上移动了<code>THREAD_SIZE</code>然后向下移动<code>TOP_OF_KERNEL_STACK_PADDING</code></li>
</ul>
<p><code>THREAD_SIZE</code>之前讨论过，就是内核栈的长度，移动这个距离就是到达内核栈的最底端。<code>TOP_OF_KERNEL_STACK_PADDING</code>主要作用权限的限制。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#ifdef CONFIG_X86_32
</span><span style="color:#75715e"># ifdef CONFIG_VM86
</span><span style="color:#75715e">#  define TOP_OF_KERNEL_STACK_PADDING 16
</span><span style="color:#75715e"># else
</span><span style="color:#75715e">#  define TOP_OF_KERNEL_STACK_PADDING 8
</span><span style="color:#75715e"># endif
</span><span style="color:#75715e">#else
</span><span style="color:#75715e"># define TOP_OF_KERNEL_STACK_PADDING 0
</span><span style="color:#75715e">#endif
</span></code></pre></div><p>其中32位机器上是8，其余是0，其原因是，涉及权限变化时32位操作系统会保存堆栈信息（SS堆栈寄存器、ESP栈顶指针寄存器）。64位操作系统优化了这个问题。</p>
<h3 id="内核栈查找用户态task_struct">内核栈查找用户态task_struct</h3>
<p>直接通过<a href="https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/arch/x86/include/asm/current.h#L13">get_current()</a>获取当前运行的task_struct。task_struct的值直接放在Per CPU变量里。</p>

        </div>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: 'a60f22cd3c5d7e6aafa8',
        clientSecret: 'db8f7c66f2e8e20275173155975b749870291c5b',
        repo: 'journey-c.github.io',
        owner: 'journey-c',
        admin: ['journey-c'],
        id: 'Linux进程管理和调度（一）',
        distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
</script>

        

        
    </article>
</div>

      <footer class="footer">
        <ul class="footer-links">
          <li>
            <p>Copyright @ 2020-<script>document.write(new Date().getFullYear())</script> <a class="footer-links-kudos" href="https://github.com/journey-c">Journey-C</a>.
    </p>
          </li>
        </ul>
      </footer>
    </main>

    <script type=text/javascript async src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$']],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(),
            i;
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
    MathJax.Hub.Config({
        TeX: {
            equationNumbers: {
                autoNumber: "AMS"
            }
        }
    });
    </script>
  </body>
</html>

