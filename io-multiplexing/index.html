<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Hugo 0.74.3" />


<title>Linux的I/O多路复用机制 - Journey-C</title>
<meta property="og:title" content="Linux的I/O多路复用机制 - Journey-C">


  <link href='https://journey-c.github.com/favicon.png' rel='icon' type='image/x-icon'/>



  




<link rel="icon" href="https://journey-c.github.comimages/" type="image/x-icon"/>
<link rel="stylesheet" href="https://journey-c.github.comcss/main.css" media="all">
<link rel="stylesheet" href="https://journey-c.github.comcss/fonts.css" media="all">
<link rel="stylesheet" href="https://journey-c.github.comcss/prism.css" media="all">
<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Merriweather:400|Lato:400,400italic,700">
<script type="text/javascript" src="https://journey-c.github.comjs/main.js"></script>
<script type="text/javascript" src="https://journey-c.github.comjs/prism.js"></script>

  </head>
  <body>
    <div class="wrapper">
      <header class="header">
        <nav class="nav">
  <a href="https://journey-c.github.com" class="nav-logo">
    <img src="https://journey-c.github.comimages/yangguo.png" 
         width="50" 
         height="50" 
         alt="Logo">
  </a>

  <ul class="nav-links">
    
    <li><a href="/archives/"></a></li>
    
    <li><a href="/tags/"></a></li>
    
    <li><a href="/about/">About</a></li>
    
    <li><a href="https://github.com/journey-c">Github</a></li>
    
    <li><a href="https://www.cnblogs.com/wuwangchuxin0924/">博客园</a></li>
    
  </ul>
</nav>

      </header>


<main class="content" role="main">
  <article class="article">
    
    
<section class="toc-section" id="toc-section">









<div class="article-toc" id="article-toc">

    <div class="article-toc-header"><strong>CONTENTS</strong></div>

    <div id="page-scrollspy" class="article-toc-nav">

        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#1-%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e7%ae%80%e4%bb%8b">
                            1. 文件系统简介
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#2-%e5%87%a0%e7%a7%8dio%e6%a8%a1%e5%9e%8b">
                            2. 几种I/O模型
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#21-blocking-io">
                            2.1 Blocking I/O
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#22-nonblocking-io">
                            2.2 Nonblocking I/O
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#23-signal-driven-io">
                            2.3 Signal Driven I/O
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#24-asynchronous-io">
                            2.4 Asynchronous I/O
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#25-io-multiplexing">
                            2.5 I/O Multiplexing
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#3-select">
                            3. Select
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#31-%e4%bd%bf%e7%94%a8">
                            3.1 使用
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#32-%e5%ae%9e%e7%8e%b0">
                            3.2 实现
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#33-%e5%b0%8f%e7%bb%93">
                            3.3 小结
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#4-poll">
                            4. Poll
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#41-%e4%bd%bf%e7%94%a8">
                            4.1 使用
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#42-%e5%ae%9e%e7%8e%b0">
                            4.2 实现
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#43-%e5%b0%8f%e7%bb%93">
                            4.3 小结
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#5-epoll">
                            5. Epoll
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#51-%e4%bd%bf%e7%94%a8">
                            5.1 使用
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#52-%e5%ae%9e%e7%8e%b0">
                            5.2 实现
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#521-epoll_create">
                            5.2.1 epoll_create
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#522-epoll_ctl">
                            5.2.2 epoll_ctl
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#523-epoll_wait">
                            5.2.3 epoll_wait
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#53-%e5%b0%8f%e7%bb%93">
                            5.3 小结
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#6-selectpollepoll%e5%af%b9%e6%af%94">
                            6. select、poll、epoll对比
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#7-%e4%ba%8b%e4%bb%b6%e5%9b%9e%e8%b0%83">
                            7. 事件回调
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#71-%e6%b5%81%e7%a8%8b">
                            7.1 流程
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#72-%e6%b5%81%e7%a8%8b%e5%9b%be">
                            7.2 流程图
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                
            
        

    </div>
    
</div>



</section>

    

    
    <span class="article-duration">3 min read</span>
    

    <h1 class="article-title">Linux的I/O多路复用机制</h1>

    
    <span class="article-date">2020-12-20</span>
    

    
        
            
            <a class="article-tag" href="https://journey-c.github.com/tags/linux">linux</a>
            
            <a class="article-tag" href="https://journey-c.github.com/tags/i/o%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">I/O多路复用</a>
            
        
    

    <div class="article-content">
      <h1 id="1-文件系统简介">1. 文件系统简介</h1>
<p>Linux平台万物皆文件，这句话实际是在夸Linux出色的虚拟文件系统，Linux将所有设备抽象为文件，与设备的数据交互抽象为文件的I/O。</p>
<p><img src="/images/file.png" alt="file"></p>
<p>Linux的虚拟文件系统大概分为四块：</p>
<ul>
<li>超级块</li>
</ul>
<ol>
<li>文件系统(ext3,ext4以及windows上的NTFS、FAT32、FAT16等)</li>
<li>内核结构对应<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/fs.h#L1415">super_block</a>，对应操作对象<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/fs.h#L1921">super_operations</a>。</li>
</ol>
<ul>
<li>索引节点</li>
</ul>
<ol>
<li>操作系统以块为单位对磁盘操作(块是扇区大小的整数倍)。索引节点记录了文件在磁盘上所有的物理块(文件内容)，以及其他信心(更新时间，操作时间等)。</li>
<li>内核结构对应<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/fs.h#L615">inode</a>，对应操作对象<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/fs.h#L1843">inode_operations</a>。</li>
</ol>
<ul>
<li>目录项</li>
</ul>
<ol>
<li>可以理解为文件的路径(不是目录，Linux上目录也是文件)，进程操作文件时通过目录项找到实际文件。</li>
<li>内核结构对应<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/dcache.h#L89">dentry</a>，对应操作对象<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/dcache.h#L135">dentry_operations</a>。</li>
</ol>
<ul>
<li>文件</li>
</ul>
<ol>
<li>由进程打开的文件。</li>
<li>内核结构对应<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/fs.h#L921">file</a>，对应操作对象<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/fs.h#L1801">file_operations</a></li>
</ol>
<p>通常服务里例如socket，pipe等对象的read，write实际就是file对应的file_operations的操作，而本文讲解I/O相关事情。</p>
<h1 id="2-几种io模型">2. 几种I/O模型</h1>
<h2 id="21-blocking-io">2.1 Blocking I/O</h2>
<ul>
<li>传统的阻塞I/O，对一个文件描述符操作(FD)时，如果操作没有响应就会一直等待，直到内核有反馈。缺点就是单线程一次只能操作一个FD。</li>
</ul>
<p><img src="/images/io_block.jpeg" alt="io_block"></p>
<h2 id="22-nonblocking-io">2.2 Nonblocking I/O</h2>
<ul>
<li>非阻塞I/O，对FD操作时，如果内核没反馈不会一直等待。非阻塞I/O会将所有FD放入FD set，一直轮询所有FD，直到有反馈的。缺点就是每次轮询时没有事件的FD也会被操作，浪费CPU。</li>
</ul>
<p><img src="/images/io_noblock.jpeg" alt="io_noblock"></p>
<h2 id="23-signal-driven-io">2.3 Signal Driven I/O</h2>
<ul>
<li>信号驱动I/O的基本原理就是首先注册signal handler，当FD有事件到来时，内核会像进程发送信号，然后应用进程执行signal handler。缺点就是，编程难度高，信号处理起来复杂。</li>
</ul>
<p><img src="/images/io_signal.jpeg" alt="io_signal"></p>
<h2 id="24-asynchronous-io">2.4 Asynchronous I/O</h2>
<ul>
<li>异步I/O和信号驱动I/O都是异步的，区别是:信号驱动I/O是FD满足条件时内核通知应用程序可以进行I/O了，而异步I/O是应用程序将I/O操作交给内核，当内核做完之后再通知应用程序I/O做完了。缺点是异步的并发量不好控制。</li>
</ul>
<p><img src="/images/io_async.jpeg" alt="io_async"></p>
<h2 id="25-io-multiplexing">2.5 I/O Multiplexing</h2>
<ul>
<li>多路复用实际不是一个技术而是一个理念，在I/O多路复用之前就有通讯线路的频分复用和时分复用，大概就是合理的安排每个单位使用资源的时间和位置，看起来所有单位一起在使用原本只能允许少量单位同时使用的资源。</li>
<li>Linux的I/O多路复用机制就是本文要讲的内容了。I/O多路复用就是将所有的FD注册到内核，然后当哪个FD可用时，那个会通知应用程序可用。</li>
</ul>
<p><img src="/images/io_multi.jpeg" alt="io_multi"></p>
<p>应用程序使用Linux提供的I/O多路复用机制都是通过<a href="/2020/11/27/what-is-system-call">系统调用</a>使用的。最初Linux只提供了Select，在哪个服务端fd使用数量普遍不高的年代是够用的，后来随着网络的发展，1024个FD的限制已经不够用了，所以Linux提供了Poll，Poll只优化了存储结构，Select使用BitMap来存储FD，Poll使用数组来存储FD，不再限制数量，但是遍历时间复杂度还是$O(lg^N)$。终于在Linux 2.5.44版本，epoll闪亮登场，这是现在普遍使用的I/O多路复用机制。</p>
<h1 id="3-select">3. Select</h1>
<h2 id="31-使用">3.1 使用</h2>
<p>Select是Linux最初提供的I/O多路复用函数。下面是libc库使用select的调用接口。</p>
<pre><code>int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
void FD_SET(int fd, fd_set *set);
void FD_CLR(int fd, fd_set *set);
int  FD_ISSET(int fd, fd_set *set);
void FD_ZERO(fd_set *set);
</code></pre><p>Select总共三部分参数</p>
<ol>
<li>传入FD(文件描述符)最大的+1</li>
<li>传入的FD，分三类
<ul>
<li>1). 监听读</li>
<li>2). 监听写</li>
<li>3). 监听异常</li>
</ul>
</li>
<li>如果一直没有满足条件的fd，最多等多久(超时时间)</li>
</ol>
<p>select用一个<code>__FD_SETSIZE</code>位的BitMap表示输入参数，<code>__FD_SETSIZE</code>默认为1024。因为没有1024位那么长的数，所以用一个数组表示，因为数组元素地址连续，所以实际就是一个1024位的数，比如第1位为1，表示这次输入有fd1(标准输出fd)。这个地方也限制了<code>select最多支持1024个fd，并且fd的号码不能大于等于1024。</code></p>
<p><img src="/images/fd_set.png" alt="fd_set"></p>
<p>解释完fd_set的构造，FD_SET、FD_CLR等操作也就明白了，FD_SET(d, s)就是d是几号fd就将s的第几位置1，其他的类似。</p>
<h2 id="32-实现">3.2 实现</h2>
<p>Linux的select函数是通过系统调用的机制提供给用户，我们来一起看一下Select的流程:</p>
<ol>
<li>系统调用函数入口在<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L722">SYSCALL_DEFINE5</a>，可能是历史原因想保留这个接口，所以这个函数没做事情直接调用了<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L700">kern_select</a>。</li>
<li>Select传入的时间是一个相对时间，<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L700">kern_select</a>判断如果时间参数不为空的话，就调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L273">poll_select_set_timeout</a>将相对时间转化为绝对时间(准确的几点几分几秒)，然后就调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L621">core_sys_select</a></li>
<li><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L621">core_sys_select</a>主要的工作就是为Select工作分配资源空间。
<ul>
<li>获取<a href="https://en.wikipedia.org/wiki/Read-copy-update">rcu锁</a>，check一下第一个参数n是不是比进程最大可打开文件描述符数还大，如果还大的话修正n为最大可打开文件描述符数。释放<a href="https://en.wikipedia.org/wiki/Read-copy-update">rcu锁</a>，rcu实际就是延迟更新，读操作不需要获取锁，只需要标记一下还有用户在读。写操作时拷贝一份数据，更新副本，当所有没有读者读旧数据的时候再将副本数据更新到原始数据上。</li>
<li>接下来就是给输入的三个变量fds.in, fds.out, fds.ex，保存结果的三个变量(fds.res_in, fds.res_out, fds.res_ex)分配存储空间，先从<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L630">栈</a>分配，栈空间不够时从<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L658">堆</a>分配。</li>
<li>资源分配结束后就调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L476">do_select</a>开始真正的检查每个FD是否可用。</li>
<li><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L476">do_select</a>是select的核心，流程如下:
<ul>
<li>首先调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L419">max_select_fd</a>找出传入FD的最大值+1，比较一下参数n是不是比最大FD+1还大，如果是就修正n为最大FD+1(<code>这里之所以总是将n修正为最大值+1，是因为do_select遍历范围是[0,n)</code>)，顺便检查下，传入的FD是不是有已关闭或者未打开的，如果有就报错<code>EBADF</code>:
<ul>
<li>传入fd_set是long的数组，openfiles也是long的数组，因为之前n根据线程最大打开文件数修正过，所以通过(n/(long的位数))可以最高位可以比较的数组下表，然后fd_set数组的那一位根据(n % (long的位数))来去掉不满足条件的FD</li>
<li>然后就从最高位开始fd_set和open_file做AND操作，第一个匹配的就是最大FD。</li>
<li><img src="/images/max_select_fd.png" alt="max_select_fd"></li>
</ul>
</li>
<li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L121">poll_initwait</a>初始化<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L103">poll_wqueues</a>(维护select/poll任务的主要struct)，并且将<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L221">__pollwait</a>注册为<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L43">poll_table</a>的proc函数，file_operations-&gt;poll会调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L48">poll_wait</a>将此时所在线程(task)放入队列，poll_wait对调用__poll_wait，这个_poll_wait此时注册的函数。主要作用就是将任务放入队列，以及做一些其他任务。</li>
<li>如果timeout不为空，调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L236">poll_schedule_timeout</a>设置超时时间。</li>
<li>重复遍历所有fd_set:
<ul>
<li>这个循环是个死循环，跳出条件为:
<ul>
<li>超时时间到(如果设置了超时时间)。</li>
<li>线程被唤醒。</li>
<li>当前线程被信号唤醒。</li>
</ul>
</li>
<li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/file.h#L63">fdget</a>获取fd对应的file结构体。</li>
<li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L86">vfs_poll</a>，获取file的事件mask，如果有in，out，ex就放入对应结果的fd_set中。
<ul>
<li><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L86">vfs_poll</a>最终会调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/fs.h#L1801">file_operations</a>的poll函数获取FD的事件状态mask，vfs_poll会调用file_operations-&gt;poll函数检查FD的事件，如果没有就调用poll_wait将线程放入等待队列。</li>
</ul>
</li>
<li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/file.h#L43">fdput</a>释放fd对应file结构体。</li>
<li>如果本次遍历一个有事件的FD也没有就调用cond_resched出让CPU，并且把线程状态设为INTERRUPTIBLE(睡眠可打断状态)，休眠直到被唤醒。</li>
<li>等到有<a href="#event_callback">事件回调</a>，就会重新遍历FD集合这次肯定有事件了，如果超时或者被信号唤醒也有相应操作。</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L476">do_select</a>将可用FD返回之后，调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L688">set_fd_set</a>拷贝回用户空间。</li>
<li>如果传入参数的BitsMap一开始是分配在堆上的就释放调。</li>
</ul>
</li>
<li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L297">poll_select_finish</a>将剩余时间拷贝回用户空间。</li>
</ol>
<h2 id="33-小结">3.3 小结</h2>
<p>select的流程简单来讲就是，将FD通过BitsMap传入内核，轮询所有的FD通过调用file-&gt;poll函数查询是否有对应事件，没有就将task加入FD对应file的待唤醒队列，等待事件来临被唤醒。(例如网卡来数据了)</p>
<p><img src="/images/select_process.png" alt="select_process"></p>
<ol>
<li>select使用BitsMap来传入和接受FD，每次调用都会在用户空间和内核空间之间拷贝。</li>
<li>select的BitsMap限制只能监听FD 0~1023。</li>
<li>轮询的方式监听所有FD，$O(n)$的复杂度</li>
</ol>
<h1 id="4-poll">4. Poll</h1>
<h2 id="41-使用">4.1 使用</h2>
<p>随着互联网的发展Select 1024个FD的限制已经不满足众多服务了，于是出现了Poll，不再用BitsMap来传入FD，取而代之用动态数组传入FD，但获取事件状态的方式还是轮询。</p>
<pre><code>int poll(struct pollfd *fds, nfds_t nfds, int timeout);
struct pollfd {
    int   fd;         /* file descriptor */
    short events;     /* requested events */
    short revents;    /* returned events */
};

</code></pre><ul>
<li>1.fds: 传入fd集合，由pollfd构成
<ul>
<li>
<ol>
<li>fd: 文件描述符</li>
</ol>
</li>
<li>
<ol start="2">
<li>events: 监听事件</li>
</ol>
</li>
<li>
<ol start="3">
<li>revents: 返回FD是因为什么事件返回的</li>
</ol>
</li>
</ul>
</li>
<li>2.nfds: fds的长度</li>
<li>3.timeout: 超时时间，单位毫秒</li>
</ul>
<h2 id="42-实现">4.2 实现</h2>
<p>Poll和Select的入口都在<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c">fs/select.c</a>中，下面我们来看一下Poll内核实现的流程:</p>
<ol>
<li>Poll的入口在<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L1057">SYSCALL_DEFINE3</a>，<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L1057">SYSCALL_DEFINE3</a>的主要工作是将timeout由相对时间转化为绝对时间。然后调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L970">do_sys_poll</a></li>
<li><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L970">do_sys_poll</a>流程:
<ul>
<li>检查nfds是否超过进程最大可打开文件数，如果是就报错-EINVAL。</li>
<li>给输入参数分配空间再从用户空间拷贝过来，先试图在栈上分配，如果不够再从堆上分配。</li>
<li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L121">poll_initwait</a>初始化poll_wqueues(和select一样)，然后调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L881">do_poll</a>，do_poll主要流程为:
<ul>
<li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L75">select_estimate_accuracy</a>设置过期时间。</li>
<li>然后就轮训所有的FD，调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L851">do_pollfd</a>检查FD的事件。do_pollfd也是调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L86">vfs_poll</a>来检测FD事件的，如果没有就将线程放入对应FD的等待队列等待被激活，自己休眠。(和select一样)</li>
</ul>
</li>
<li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L138">poll_freewait</a>释放刚刚初始化的poll_wqueues。</li>
<li>调用<code>__put_user</code>将结果拷贝回用户空间。</li>
<li>如果最开始参数是在堆上分配的，就释放内存。</li>
</ul>
</li>
</ol>
<h2 id="43-小结">4.3 小结</h2>
<p>poll和select差不多，区别就是BitsMap换成了链表，FD数量只受poll可用内核内存大小限制。</p>
<p><img src="/images/poll_process.png" alt="poll_process"></p>
<ol>
<li>poll监听FD数量不再有限制(除线程本身限制外)，但是每次调用poll还是要将FD集合拷贝到内核态，完成后再拷贝回来。</li>
<li>监听所有FD的方式还是轮训，$O(n)$的复杂度。</li>
</ol>
<h1 id="5-epoll">5. Epoll</h1>
<h2 id="51-使用">5.1 使用</h2>
<p>正因为select和poll有着各自的缺点，所以linux 2.5.44版本提供了新的I/O复用机制Epoll，在后续的版本中继续做了很多优化。</p>
<pre><code>struct epoll_event {
    uint32_t     events;      /* Epoll events */
    epoll_data_t data;        /* User data variable */
};
typedef union epoll_data {
    void        *ptr;
    int          fd;
    uint32_t     u32;
    uint64_t     u64;
} epoll_data_t;
</code></pre><pre><code>// 创建用于epoll工作的FD
int epoll_create(int size);

// 对事件操作：增、删等
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 

// 等待事件
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);  
</code></pre><ul>
<li>
<p>epoll_create</p>
<ul>
<li>size: 监听fd的数量，Linux 2.6.8就去掉了这个参数，因为要兼容，所以留着这个参数，但实际内核没用。</li>
</ul>
</li>
<li>
<p>epoll_ctl</p>
<ul>
<li>epfd: epoll对应的FD</li>
<li>op: 操作码，增(EPOLL_CTL_ADD),删(EPOLL_CTL_DEL),改(EPOLL_CTL_MOD)</li>
<li>fd: 对epoll操作的源FD，例如要添加删除修改的FD</li>
<li>event: 要监听的事件</li>
</ul>
</li>
<li>
<p>epoll_wait</p>
<ul>
<li>epfd: epoll对应的FD</li>
<li>events: 要等待的事件数组</li>
<li>maxevents: 监听事件数量</li>
<li>timeout: 超时时间，单位毫秒</li>
</ul>
</li>
</ul>
<h2 id="52-实现">5.2 实现</h2>
<h3 id="521-epoll_create">5.2.1 epoll_create</h3>
<ol>
<li>epoll_create的入口在<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L2088">SYSCALL_DEFINE1</a>，这个函数只是简单的检查了一下size是否为0，epoll_create的size参数随便填只要大于0即可，不使用的。然后调用了<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L2040">do_epoll_create</a>对epoll_create操作统一处理。</li>
<li><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L2040">do_epoll_create</a>流程如下:
<ul>
<li>检查一下flags除了EPOLL_CLOEXEC，还有没有其他的flag</li>
<li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1006">ep_alloc</a>申请一个<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L181">eventpoll</a>结构，这是存储epoll所有数据的数据结构。</li>
<li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/file.c#L561">get_unused_fd_flags</a>根据flags申请一个本进程最小未使用的fd。</li>
<li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/anon_inodes.c#L74">anon_inode_getfile</a>创建一个对应匿名inode的file，file的私有数据存的是eventpoll结构体。inode在VFS中对应一个文件，记录了此文件在磁盘那些块以及文件各种信息，匿名inode就是将此文件的dentry(目录项)删掉了，在文件系统中一般是通过dentry(目录项)来查找使用文件，这样其他进程就用不了这个文件。相当于创建一个临时文件。</li>
<li><img src="/images/anonymous_inode.png" alt="anonymous_inode"></li>
<li>现在file(由进程打开的文件)有了，fd有了，把file和fd的关系放入本进程的open_files中，就相当于本进程打开了这个文件。</li>
</ul>
</li>
</ol>
<h3 id="522-epoll_ctl">5.2.2 epoll_ctl</h3>
<ol>
<li>epoll_ctl的入口在<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L2272">SYSCALL_DEFINE4</a>，首先根据op选择要不要从用户空间拷贝参数(只要不是DEL都需要拷贝)，之后就调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L2108">do_epoll_ctl</a>做主要的工作了。</li>
<li><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L2108">do_epoll_ctl</a>主要流程如下:
<ul>
<li>参数获取:
<ul>
<li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/file.h#L63">fdget</a>根据epfd获得epoll对应的file(epoll_create时创建的)，根据参数传入的fd获取对应的file。</li>
</ul>
</li>
<li>参数 :
<ul>
<li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L81">file_can_poll</a>判断该文件支不支持poll函数，实际就是判断该文件对应的file_operation的poll函数为不为空。</li>
<li>判断系统支不支持autosleep功能，如果支持且用户也传入了EPOLLWAKEUP标志，就调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/uapi/linux/eventpoll.h#L83">ep_take_care_of_epollwakeup</a>将标志加到事件中，否则就将EPOLLWAKEUP事件丢弃。</li>
<li>check一下要操作的fd是不是epfd(操作自己epoll的fd)和epfd是不是一个epoll fd。</li>
<li>EPOLLEXCLUSIVE(since Linux 3.5)是一个FD被多个epoll监听时，当这个FD事件来临只有一个epoll会被唤起(避免惊群效应)。而epoll只允许add的时传入不允许mod时传入，这里就是check一下这种情况。</li>
<li>处理一种Epoll A包含Epoll B的FD，Epoll B也包含Epoll A的FD的情况，这时候如果其中一个FD有了事件，那么两个Epoll会循环被唤醒。</li>
</ul>
</li>
<li>接下来就是核心操作:
<ul>
<li>根据file地址和fd大小 调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1041">ep_find</a> 查找传入fd是否在eventpoll结构体中的rbtree(存储所有监听的fd)已存在。rbtree的key就是<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L107">epoll_filefd</a>，比较规则，先比较file的地址，相同的话在比较fd的大小。</li>
<li>如果是ADD就调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1490">ep_insert</a>:
<ul>
<li>当前用用户的epoll_watch和<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1502">max_user_watches</a>检查是否还有可用空间，内核给每个用户的epoll可以用空间限制为syscall可使用空间的$1/25$。</li>
<li>从缓存中创建一个新的epitem(<a href="/2020/10/22/red-black-tree">红黑树</a>的value)。</li>
<li>初始化rdllink(满足事件链表)，fllink(链接fd对应的file链表)，pwqlist(poll等待队列)。</li>
<li>初始化epitem的参数，调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L322">ep_set_ffd</a>根据file，fd生成<a href="/2020/10/22/red-black-tree">红黑树</a>的key(struct epoll_filefd)等。</li>
<li>向插入fd对应file的epoll事件链表(f_ep_links)中新增事件。</li>
<li>将epitem插入<a href="/2020/10/22/red-black-tree">红黑树</a>。</li>
<li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L75">init_poll_funcptr</a>注册poll回调函数<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1309">ep_ptable_queue_proc</a>。在前select一节有描述。这里回调函数<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1309">ep_ptable_queue_proc</a>除了将task放入FD对应file的等待队列之外，事件来临还会调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1204">ep_poll_callback</a>函数。</li>
<li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L877">ep_item_poll</a>
<ul>
<li>如果不是epoll的FD就调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L86">vfs_poll</a>-&gt;file_operations.poll查询FD事件如果有就返回，没有就插入等待队列。</li>
<li>如果是epoll的FD，就调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L677">ep_scan_ready_list</a>将epoll的rdllist(已就绪的FD)传入用户空间。</li>
</ul>
</li>
<li>如果有事件的话并且之前不在就绪链表rdllist，就放入就绪链表</li>
</ul>
</li>
<li>如果是DEL就调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L767">ep_remove</a>:
<ul>
<li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L618">ep_unregister_pollwait</a>注销epoll_add时注册的file对应的poll_wait函数。</li>
<li>从各链表中删除。</li>
<li>从<a href="/2020/10/22/red-black-tree">红黑树</a>中删除。</li>
</ul>
</li>
<li>如果是MOD就调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1622">ep_modify</a>:
<ul>
<li>修改FD事件。</li>
<li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L877">ep_item_poll</a>查询是否修改后有事件，有的话就放入rdllist就绪链表。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="523-epoll_wait">5.2.3 epoll_wait</h3>
<ol>
<li>epoll_wait入口在<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L2330">SYSCALL_DEFINE4</a>，之后调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L2288">do_epoll_wait</a></li>
<li><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L2288">do_epoll_wait</a>主要流程:
<ul>
<li>检查参数，参数是否正确，返回结果地址是否正确，要操作的epollfd是否正确。</li>
<li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1818">ep_poll</a>
<ul>
<li>如果有timeout不为零，就将时间转化为绝对时间，如果为0就检查一下当前就绪队列是否为空，如果有事件直接返回，没有事件就返回空。</li>
<li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L375">ep_events_available</a>检查当前有无就绪FD，有就直接返回，或者当前file_operations-&gt;poll函数正忙就等等，看工作完有没有。</li>
<li>如果没有就进入死循环，和select一样，将task设为TASK_INTERRUPTIBLE，等待被唤醒或被信号唤醒或超时。</li>
<li>直到被唤醒依然调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L375">ep_events_available</a>检查有没有就绪FD，有的话就调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1778">ep_send_events</a>将结果传回用户空间。
<ul>
<li><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1778">ep_send_events</a>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L677">ep_scan_ready_list</a>扫描rdllist链表并且调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1694">ep_send_events_proc</a>将事件发回用户空间，如果FD的使用的epoll的模式为EPOLLET(水平触发)发送完之后重新被加入rdllist链表，等待下次epoll_wait时，如果fd在rdllink中且已经不可读了就不再加入rdllist中了。</li>
<li>发送会用户空间之后，将因为rdllist发送时加锁而没加入的事件(放入了ovflist)加入rdllist。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="53-小结">5.3 小结</h2>
<p>select和poll的模式都是，一次将参数拷贝到内核空间，等有结果了再一次拷贝出去，类似无状态服务。而epoll则只是在epoll_ctl(ADD)时将数据拷入，epoll_wait时在将数据拷出，多次复用没有其他数据拷贝，大大节省了数据拷贝。epoll采用<a href="/2020/10/22/red-black-tree">红黑树</a>存储所有被监听的FD是的查找删除时间复杂度由$O(N)$缩短为$O(log^N)$。</p>
<p><img src="/images/epoll_process.png" alt="epoll_process"></p>
<ol>
<li>epoll_create创建eventpoll结构。</li>
<li>epoll_ctl:
<ul>
<li>
<ol>
<li>ADD检查FD事件，有就加入rdllist队列，没有就将task放入FD对应file的待唤醒列表，将FD加入<a href="/2020/10/22/red-black-tree">红黑树</a>维护。</li>
</ol>
</li>
<li>
<ol start="2">
<li>DEL从eventpoll的各个资源中删除。</li>
</ol>
</li>
<li>
<ol start="3">
<li>MOD修改事件，并再次检查FD事件，有就加入rdllist队列，没有就将task放入FD对应file的待唤醒列表并且注册事件回调函数——有事件来临就加入rdllist。</li>
</ol>
</li>
</ul>
</li>
<li>epoll_wait检查rdllist有没有已经就绪的FD，没有就等待时间来临唤醒，有事件就返回用户空间，并且清空rdllist链表，如果FD是EPOLLLET模式的就重新加入rdllist链表中，等待下次epoll_wait看情况清理。</li>
</ol>
<h1 id="6-selectpollepoll对比">6. select、poll、epoll对比</h1>
<table>
<thead>
<tr>
<th>名称</th>
<th>监听FD数量</th>
<th>数据拷贝</th>
<th>操作复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>select</td>
<td>1024</td>
<td>每次操作从用户空间拷入内核空间然后拷出</td>
<td>$O(N)$</td>
</tr>
<tr>
<td>poll</td>
<td>内核限制sys内存大小</td>
<td>每次操作从用户空间拷入内核空间然后拷出</td>
<td>$O(N)$</td>
</tr>
<tr>
<td>epoll</td>
<td>内核限制sys内存大小</td>
<td>ADD时拷贝一次，epoll_wait时利用MMAP和用户共享空间，直接拷贝数据到用户控件</td>
<td>$O(1)$</td>
</tr>
</tbody>
</table>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h1 id="7-事件回调">7. 事件回调</h1>
<p>select/poll/epoll最后都会调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L86">vfs_poll</a>，检查FD是否有相应事件。
<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L86">vfs_poll</a>的核心流程就是:</p>
<ul>
<li>先检查FD对应的file目前是否已有事件，如果没有则将当前task(linux中线程进程都是task)加入到file的wait_queue，然后就让出CPU，等待被激活。</li>
<li>当file对应的设备有事件来临时，会激活file的wait_queue中所有等待的task(将task从等待态变为运行态，重新加入到调度列表中)。</li>
</ul>
<pre><code>CPU1                CPU2
sys_select          receive packet
...                 ...
__add_wait_queue    update tp-&gt;rcv_nxt
...                 ...
tp-&gt;rcv_nxt check   sock_def_readable
...                 {
schedule               rcu_read_lock();
                       wq = rcu_dereference(sk-&gt;sk_wq);
                       if (wq &amp;&amp; waitqueue_active(&amp;wq-&gt;wait))
                           wake_up_interruptible(&amp;wq-&gt;wait)
                       ...
                    }
</code></pre><h2 id="71-流程">7.1 流程</h2>
<p>下面我们以socket为例，分析一下事件是如何回调的。</p>
<p>设备驱动层主要做的事情是，网卡作为一个硬件，当收到网络包的时候如何通知操作系统。没错，是硬件中断，硬件和操作系统打交道的方式基本都是硬件中断。而网卡与内核交互采用了硬件中断+下半部（主要是拷贝数据太耗时，放在中断处理程序中不妥）</p>
<ul>
<li>设备给中断控制器引脚发送信号。</li>
<li>中断控制器收到后给CPU发送信号。</li>
<li>CPU收到信号后产生中断，根据中断号在中断向量表中执行内核实现的中断处理程序。(执行程序实际就是已经与内核通讯了)
<img src="/images/event_driver.png" alt="event_driver"></li>
</ul>
<p>以intel的ixgb网卡为例。</p>
<ol>
<li>网卡程序初始化时调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L116">ixgb_init_module</a>注册驱动<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L92">ixgb_driver</a>，并且调用驱动的probe函数<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L359">ixgb_probe</a>。</li>
<li><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L359">ixgb_probe</a>中与本文相关的有:
<ul>
<li>
<ol>
<li>创建一个<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/netdevice.h#L1863">struct net_device</a>表示网络设备。</li>
</ol>
</li>
<li>
<ol start="2">
<li>设置网卡的相关操作<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L331">ixgb_netdev_ops</a>，其中ndo_open函数是网卡激活时执行的函数，对应ixgb网卡的<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L593">ixgb_open</a>函数。调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L6600">netif_napi_add</a>为这个网络设备注册一个轮询 poll 函数 <a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L1752">ixgb_clean</a>，将来一旦出现网络包的时候，就是要通过它来轮询了。</li>
</ol>
</li>
<li>
<ol start="3">
<li><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L593">ixgb_open</a>中调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L171">ixgb_up</a>注册硬件中断，类型为IRQF_SHARED，中断设备名字ixgb，并且中断处理程序为<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L1721">ixgb_intr</a></li>
</ol>
</li>
</ul>
</li>
<li>当网卡有数据来临时，网卡给中断控制器发送信号，中断控制器给CPU发送信号，CPU执行对应的中断处理函数<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L1721">ixgb_intr</a>
<ul>
<li>
<ol>
<li><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L1721">ixgb_intr</a>中调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L6281">__napi_schedule</a>和<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L4240">___napi_schedule</a>将设备标记，触发软件中断NET_RX_SOFTIRQ，软件中断号对应的中断处理函数为<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L6735">net_rx_action</a></li>
</ol>
</li>
<li>
<ol start="2">
<li><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L6735">net_rx_action</a>调用napi_poll轮询所有的网络设备，napi_poll调用网卡注册是注册的poll函数<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L1752">ixgb_clean</a></li>
</ol>
</li>
<li>
<ol start="3">
<li><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L1752">ixgb_clean</a>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L1929">ixgb_clean_rx_irq</a>读取数据并将数据存放到struct sk_buff中，然后调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L5553">netif_receive_skb</a>处理二层的数据。</li>
</ol>
</li>
</ul>
</li>
<li>从<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L5553">netif_receive_skb</a>开始处理二层的数据，调用链<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L5478">netif_receive_skb_internal</a>-&gt;<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L5380">__netif_receive_skb</a>-&gt;<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L5079">__netif_receive_skb_core</a>
<ul>
<li>
<ol>
<li><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L5079">__netif_receive_skb_core</a>中根据协议头将数据交给三层对应的协议栈。</li>
</ol>
</li>
</ul>
</li>
<li>现在就开始处理三层的数据里，假如当前的包是一个IPv4的包，数据就会流向<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/ip_input.c#L530">ip_rcv</a>
<ul>
<li>
<ol>
<li><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/ip_input.c#L530">ip_rcv</a>中得到IP的报头，然后调用NF_HOOK判断路由，不是本机的包就发走，是本机的包就调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/ip_input.c#L414">ip_rcv_finish</a></li>
</ol>
</li>
<li>
<ol start="2">
<li><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/ip_input.c#L414">ip_rcv_finish</a>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/ip_input.c#L314">ip_rcv_finish_core</a>然后根据IP报头中的协议把数据交给四层的协议栈。</li>
</ol>
</li>
</ul>
</li>
<li>千辛万苦数据终于来到了四层，假如当前是一个TCP包的话。会调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/tcp_ipv4.c#L1886">tcp_v4_rcv</a>
<ul>
<li>
<ol>
<li><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/tcp_ipv4.c#L1886">tcp_v4_rcv</a>根据IP以及tcp报头内容在<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/tcp_ipv4.c#L91">tcp_hashinfo</a> (<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/net/inet_hashtables.h#L124">inet_hashinfo</a>)找到对应socket</li>
</ol>
</li>
<li>
<ol start="2">
<li>接下来根据socket的不同状态进行处理，socket根据情况进入三个不同队列，这一步主要是先将包找个地方放一下，赶紧离开中断状态。</li>
</ol>
<ul>
<li>
<ol>
<li>backlog 当前没有用户在读数据，就将socket 放入backlog中，离开软件中断状态(到之前为止一直在软件中断中)</li>
</ol>
</li>
<li>
<ol start="2">
<li>prequeue 如果当前有用户在读数据，且一个窗口的包还没收集完就放入prequeue</li>
</ol>
</li>
<li>
<ol start="3">
<li>sk_receive_queue 当一个窗口的包准确收集完了，就放入sk_receive_queue中，用户可读取了。</li>
</ol>
</li>
</ul>
</li>
<li>
<ol start="3">
<li>当一个窗口的包准确收集完之后，就会调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/tcp_input.c#L4849">tcp_data_queue</a>将数据放入sk_receive_queue，然后调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/tcp_input.c#L4837">tcp_data_ready</a>，在调用sock的sk_data_ready函数<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/sock.c#L2901">sock_def_readable</a>，<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/sock.c#L2901">sock_def_readable</a>会唤醒之前因为调用file_operations.poll为阻塞的进程或线程。</li>
</ol>
</li>
</ul>
</li>
<li>这就到了咱们最关心的问题了，<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/tcp_input.c#L4837">tcp_data_ready</a>唤醒的是哪些task。</li>
</ol>
<h2 id="72-流程图">7.2 流程图</h2>
<p><img src="/images/net_callback.png" alt="net_callback"></p>

    </div>
  </article>

  

</main>

      <footer class="footer">
        <ul class="footer-links">
          <li>
            <p>Copyright @ 2020-<script>document.write(new Date().getFullYear())</script> <a class="footer-links-kudos" href="https://github.com/journey-c">Journey-C</a>.
    </p>
          </li>
        </ul>
      </footer>

    </div>

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'xxxxx', 'auto');
	
	ga('send', 'pageview');
}
</script>


    <script type=text/javascript async src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$']],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(),
            i;
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
    MathJax.Hub.Config({
        TeX: {
            equationNumbers: {
                autoNumber: "AMS"
            }
        }
    });
    </script>

    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
	var gitalk = new Gitalk({
    		clientID: 'a60f22cd3c5d7e6aafa8',
    		clientSecret: 'db8f7c66f2e8e20275173155975b749870291c5b',
    		repo: 'journey-c.github.io',
    		owner: 'journey-c',
    		admin: ['journey-c'],
    		id: '<%=page.title%>',
    		distractionFreeMode: true
  	});
  	gitalk.render('gitalk-container');
</script>

    
  </body>
</html>

