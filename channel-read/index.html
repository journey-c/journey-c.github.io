<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Hugo 0.74.3" />


<title>channel 源码阅读 - Journey-C</title>
<meta property="og:title" content="channel 源码阅读 - Journey-C">


  <link href='https://journey-c.github.io/favicon.png' rel='icon' type='image/x-icon'/>



  




<link rel="icon" href="https://journey-c.github.io/images/" type="image/x-icon"/>
<link rel="stylesheet" href="https://journey-c.github.io/css/main.css" media="all">
<link rel="stylesheet" href="https://journey-c.github.io/css/fonts.css" media="all">
<link rel="stylesheet" href="https://journey-c.github.io/css/prism.css" media="all">
<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Merriweather:400|Lato:400,400italic,700">
<script type="text/javascript" src="https://journey-c.github.io/js/main.js"></script>
<script type="text/javascript" src="https://journey-c.github.io/js/prism.js"></script>

  </head>
  <body>
    <div class="wrapper">
      <header class="header">
        <nav class="nav">
  <a href="https://journey-c.github.io/" class="nav-logo">
    <img src="https://journey-c.github.io/images/yangguo.png" 
         width="50" 
         height="50" 
         alt="Logo">
  </a>

  <ul class="nav-links">
    
    <li><a href="/archives/"></a></li>
    
    <li><a href="/tags/"></a></li>
    
    <li><a href="/about/">About</a></li>
    
    <li><a href="https://github.com/journey-c">Github</a></li>
    
    <li><a href="https://www.cnblogs.com/wuwangchuxin0924/">博客园</a></li>
    
  </ul>
</nav>

      </header>


<main class="content" role="main">
  <article class="article">
    
    
<section class="toc-section" id="toc-section">









<div class="article-toc" id="article-toc">

    <div class="article-toc-header"><strong>CONTENTS</strong></div>

    <div id="page-scrollspy" class="article-toc-nav">

        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#1-%e7%ae%80%e4%bb%8b">
                            1. 简介
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#2-%e6%95%b0%e6%8d%ae%e9%83%a8%e5%88%86">
                            2. 数据部分
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#21--hchan">
                            2.1 hchan
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#211-%e5%8f%82%e6%95%b0%e6%84%8f%e4%b9%89">
                            2.1.1 参数意义
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#22-waitq">
                            2.2 waitq
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#221-%e5%8f%82%e6%95%b0%e6%84%8f%e4%b9%89">
                            2.2.1 参数意义
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#222-%e5%87%bd%e6%95%b0">
                            2.2.2 函数
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#2221-enqueue">
                            2.2.2.1 enqueue
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#2222-dequeue">
                            2.2.2.2 dequeue
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#23-sudog">
                            2.3 sudog
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#231-%e5%88%9b%e5%bb%basudogacquiresudog">
                            2.3.1 创建sudog——acquireSudog
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#232-%e9%94%80%e6%af%81sudogreleasesudog">
                            2.3.2 销毁sudog——releaseSudog
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#3-%e5%ae%9e%e7%8e%b0%e7%bb%86%e8%8a%82">
                            3. 实现细节
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#31-%e5%88%9b%e5%bb%bachannel">
                            3.1 创建channel
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#311-makechan64">
                            3.1.1 makechan64
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#312-makechan">
                            3.1.2 makechan
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#32-%e5%8f%91%e9%80%81">
                            3.2 发送
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#321-chansend">
                            3.2.1 chansend
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#3211-racereadpc">
                            3.2.1.1 racereadpc
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#3212-send">
                            3.2.1.2 send
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#33-%e6%8e%a5%e6%94%b6">
                            3.3 接收
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#331-chanrecv">
                            3.3.1 chanrecv
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#33-%e5%85%b3%e9%97%adchannel">
                            3.3 关闭channel
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#%e9%99%84%e5%bd%95">
                            附录
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav" id="markdown-toc">
                    
                    <ul class="nav" id="markdown-toc">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#chandot">
                            chan.dot
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                
            
        

    </div>
    
</div>



</section>

    

    
    <span class="article-duration">11 min read</span>
    

    <h1 class="article-title">channel 源码阅读</h1>

    
    <span class="article-date">2020-10-29</span>
    

    
        
            
            <a class="article-tag" href="https://journey-c.github.io/tags/%E6%BA%90%E7%A0%81">源码</a>
            
            <a class="article-tag" href="https://journey-c.github.io/tags/golang">Golang</a>
            
        
    

    <div class="article-content">
      <p>(年初的时候go语言的学习提上了日程，前一篇sync.pool阅读之后，阅读代码进度本该更快些，奈何身体被掏空，所以这篇文章断断续续一个月终于攒起来了。)</p>
<!-- raw HTML omitted -->
<p>[toc]</p>
<h1 id="1-简介">1. 简介</h1>
<p>channel是golang中用于goroutine之间通讯的数据结构，有以下特点：</p>
<ol>
<li>线程安全</li>
<li>创建channel时返回的是指针，不需要考虑拷贝的问题</li>
<li>顺序通讯，写入和读出的顺序一致</li>
</ol>
<h1 id="2-数据部分">2. 数据部分</h1>
<p><img src="/images/chan.png" alt=""></p>
<p><strong>源码位置go/src/runtime/chan.go</strong></p>
<h2 id="21--hchan">2.1  hchan</h2>
<p>channel对应的数据结构</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">hchan</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">qcount</span>   <span style="color:#66d9ef">uint</span>
	<span style="color:#a6e22e">dataqsiz</span> <span style="color:#66d9ef">uint</span>
	<span style="color:#a6e22e">buf</span>      <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>
	<span style="color:#a6e22e">elemsize</span> <span style="color:#66d9ef">uint16</span>
	<span style="color:#a6e22e">closed</span>   <span style="color:#66d9ef">uint32</span>
	<span style="color:#a6e22e">elemtype</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">_type</span>
	<span style="color:#a6e22e">sendx</span>    <span style="color:#66d9ef">uint</span>
	<span style="color:#a6e22e">recvx</span>    <span style="color:#66d9ef">uint</span>
	<span style="color:#a6e22e">recvq</span>    <span style="color:#a6e22e">waitq</span>
	<span style="color:#a6e22e">sendq</span>    <span style="color:#a6e22e">waitq</span>

	<span style="color:#75715e">// lock protects all fields in hchan, as well as several
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// fields in sudogs blocked on this channel.
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// Do not change another G&#39;s status while holding this lock
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// (in particular, do not ready a G), as this can deadlock
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// with stack shrinking.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">lock</span> <span style="color:#a6e22e">mutex</span>
}
</code></pre></div><h3 id="211-参数意义">2.1.1 参数意义</h3>
<p>qcount   uint // 表示channel中元素的个数
dataqsiz uint // 表示channel的大小长度
buf      unsafe.Pointer // 存储元素的环形队列头指针
elemsize uint16 // 表示此channel能存储元素的大小
closed   uint32 // channel是否关闭了
elemtype *_type // 表示此channel能存储元素的类型
sendx    uint // 表示发送操作对应buf的下标，超过dataqsiz之后清0（因为是循环队列嘛）
recvx    uint // 表示接收操作对应buf的下标
recvq    waitq // 等待接收操作的goroutine队列
sendq    waitq // 等待发送操作的goroutine队列</p>
<p>lock mutex // channel的锁</p>
<h2 id="22-waitq">2.2 waitq</h2>
<p>用来表示等待发送或者接受的goroutine队列（用sudog表示队列一个节点）</p>
<pre><code>type waitq struct {
	first *sudog
	last  *sudog
}
</code></pre><h3 id="221-参数意义">2.2.1 参数意义</h3>
<pre><code>first goroutine指针，队首指针
last  goroutine指针，队尾指针
</code></pre><h3 id="222-函数">2.2.2 函数</h3>
<h4 id="2221-enqueue">2.2.2.1 enqueue</h4>
<p>两种情况：</p>
<ol>
<li>队列为空，将元素放入队尾将first指针和last指针赋好值</li>
<li>队列不为空，直接将元素放入队尾</li>
</ol>
<pre><code>func (q *waitq) enqueue(sgp *sudog) {
	// 将goroutine的next置为空
	sgp.next = nil
	x := q.last
	if x == nil { // 如果尾指针为空，说明队列为空，就把这个goroutine放进去
		sgp.prev = nil
		q.first = sgp
		q.last = sgp
		return
	}
	// 直接入队列
	sgp.prev = x
	x.next = sgp
	q.last = sgp
}
</code></pre><h4 id="2222-dequeue">2.2.2.2 dequeue</h4>
<p>从队列头开始遍历</p>
<ol>
<li>first指针为空，说明队列为空，则直接返回空</li>
<li>如果队列只有一个元素了，将元素取出，并且清空first指针和last指针</li>
<li>队列还有很多元素，直接将first指针对应的元素去除</li>
<li>最后判断如果这个元素(sudog——在channel中用来表示等待接收或者发送的goroutine的)在select结构中并且select结构有其他接口，就跳过，继续遍历下一个节点。</li>
</ol>
<pre><code>func (q *waitq) dequeue() *sudog {
	for {
		sgp := q.first
		if sgp == nil { // 头指针为空，说明队列为空，直接返回
			return nil
		}
		y := sgp.next
		if y == nil { // 如果next指针为空，说明队列就一个元素了，取出这个就空了，就将队列置空
			q.first = nil
			q.last = nil
		} else { // next不为空，就将next作为队首，将原来的队首返回
			y.prev = nil
			q.first = y
			sgp.next = nil // mark as removed (see dequeueSudog)
		}

		// if a gogoroutine was put on this queue because of a
		// select, there is a small window between the gogoroutine
		// being woken up by a different case and it grabbing the
		// channel locks. Once it has the lock
		// it removes itself from the queue, so we won't see it after that.
		// We use a flag in the G struct to tell us when someone
		// else has won the race to signal this gogoroutine but the gogoroutine
		// hasn't removed itself from the queue yet.
		// 如果goroutine处于select结构中并且select有其他出口就跳过这个
		if sgp.isSelect &amp;&amp; !atomic.Cas(&amp;sgp.g.selectDone, 0, 1) {
			continue
		}

		return sgp
	}
}
</code></pre><h2 id="23-sudog">2.3 sudog</h2>
<p>sudog是在等待对channel发送或者接受的goroutine</p>
<p><strong>为什么有了goroutine还要有一个sudog？</strong></p>
<ol>
<li>因为goroutine和等待的channel是多对多的关系，一个goroutine可能在等待多个channel，一个channel也可能有很多goroutine在等待，所以用sudog表示这个等待中的goroutine</li>
<li>sudog是channel等待或者接发送链表的一个node</li>
</ol>
<p><strong>sudog通过acquireSudog创建，releaseSudog销毁</strong></p>
<ol>
<li>在go/src/runtime/proc.go中</li>
<li>go会维护一个全局的缓存（有锁），然后每个调度器（P）有自己的缓存</li>
<li>创建sudog时会先从P的缓存中找，没有就到全局缓存中找，在没有才new一个</li>
<li>销毁sudog的时候先判断P是不是满了，如果满了就将一半缓存放到全局缓存然后再把sudog放到自己缓存</li>
<li>全局缓存的生存周期时两次GC的间隔，go/src/runtime/mgc.go 中clearpools()函数中可以看到，每次GC都会清理全局缓存</li>
</ol>
<pre><code>type sudog struct {
	// sudog替哪个goroutine在等待
	g *g

	isSelect bool  // 是否在select结构中(select可能取消阻塞发送或接收)
	next     *sudog // 下一个节点
	prev     *sudog // 上一个节点
	elem     unsafe.Pointer // data element (may point to stack)

	acquiretime int64 // 创建时间
	releasetime int64 // 释放时间
	ticket      uint32
	parent      *sudog // semaRoot binary tree
	waitlink    *sudog // g.waiting list or semaRoot
	waittail    *sudog // semaRoot
	c           *hchan // channel 在等待哪个channel
}
</code></pre><h3 id="231-创建sudogacquiresudog">2.3.1 创建sudog——acquireSudog</h3>
<p>大概逻辑就是现在当前goroutine所在调度器(P)的缓存中找，如果没有就从全局缓存中找，如果还没有就new一个</p>
<pre><code>func acquireSudog() *sudog {
	// 获得当前goroutine所在的线程(M)
	mp := acquirem()
	// 获得当前goroutine所在调度器(P)
	pp := mp.p.ptr()
	if len(pp.sudogcache) == 0 { // 如果调度器的sudog缓存为空，就从中央缓存找，如果再为空就new一个
		lock(&amp;sched.sudoglock)
		// First, try to grab a batch from central cache.
		for len(pp.sudogcache) &lt; cap(pp.sudogcache)/2 &amp;&amp; sched.sudogcache != nil {
			s := sched.sudogcache
			sched.sudogcache = s.next
			s.next = nil
			pp.sudogcache = append(pp.sudogcache, s)
		}
		unlock(&amp;sched.sudoglock)
		// If the central cache is empty, allocate a new one.
		if len(pp.sudogcache) == 0 {
			pp.sudogcache = append(pp.sudogcache, new(sudog))
		}
	}
	n := len(pp.sudogcache)
	s := pp.sudogcache[n-1]
	pp.sudogcache[n-1] = nil
	pp.sudogcache = pp.sudogcache[:n-1]
	if s.elem != nil {
		throw(&quot;acquireSudog: found s.elem != nil in cache&quot;)
	}
	releasem(mp)
	return s
}
</code></pre><h3 id="232-销毁sudogreleasesudog">2.3.2 销毁sudog——releaseSudog</h3>
<p>大概逻辑就是如果当前goroutine所在调度器(P)的缓存满了，就将调度器(P)的缓存一半放入全局缓存，然后在把sudog放入</p>
<pre><code>func releaseSudog(s *sudog) {
	// 这部分都是check sudog 是否合法
	if s.elem != nil {
		throw(&quot;runtime: sudog with non-nil elem&quot;)
	}
	if s.isSelect {
		throw(&quot;runtime: sudog with non-false isSelect&quot;)
	}
	if s.next != nil {
		throw(&quot;runtime: sudog with non-nil next&quot;)
	}
	if s.prev != nil {
		throw(&quot;runtime: sudog with non-nil prev&quot;)
	}
	if s.waitlink != nil {
		throw(&quot;runtime: sudog with non-nil waitlink&quot;)
	}
	if s.c != nil {
		throw(&quot;runtime: sudog with non-nil c&quot;)
	}
	gp := getg()
	if gp.param != nil {
		throw(&quot;runtime: releaseSudog with non-nil gp.param&quot;)
	}
	mp := acquirem() // avoid rescheduling to another P
	pp := mp.p.ptr()
	// 如果当前调度器的缓存满了，就将一半放入中央缓存
	if len(pp.sudogcache) == cap(pp.sudogcache) {
		// Transfer half of local cache to the central cache.
		var first, last *sudog
		for len(pp.sudogcache) &gt; cap(pp.sudogcache)/2 {
			n := len(pp.sudogcache)
			p := pp.sudogcache[n-1]
			pp.sudogcache[n-1] = nil
			pp.sudogcache = pp.sudogcache[:n-1]
			if first == nil {
				first = p
			} else {
				last.next = p
			}
			last = p
		}
		lock(&amp;sched.sudoglock)
		last.next = sched.sudogcache
		sched.sudogcache = first
		unlock(&amp;sched.sudoglock)
	}
	pp.sudogcache = append(pp.sudogcache, s)
	releasem(mp)
}
</code></pre><h1 id="3-实现细节">3. 实现细节</h1>
<h2 id="31-创建channel">3.1 创建channel</h2>
<p><em>go中所有的channel的创建都会使用make关键字，make(arg1, arg2)函数最终会调用到runtime.makechan和runtime.makechan64，下面讲解go在编译时期是如何做这些事情的</em></p>
<p><a href="https://github.com/golang/go/blob/go1.13.8/src/cmd/compile/internal/gc/typecheck.go">typecheck.go</a>
编译器会将make(arg1, arg2)转化成OMAKE类型的节点，并在类型检查阶段将OMAKE类型的节点按照arg1的类型转化为OMAKECHAN，OMAKEMAP，OMAKESLICE等类型</p>
<pre><code>func typecheck1(n *Node, top int) (res *Node) {
    ...
    switch n.Op {
    ...
    case OMAKE:
        ... 
        switch t.Etype {
        ...
        case TCHAN:
            l = nil
            if i &lt; len(args) {
                ....
            } else {
                n.Left = nodintconst(0)
            }
            n.Op = OMAKECHAN // 节点类型转化为OMAKECHAN
        }
    ...
    }
    ...
}
</code></pre><p><a href="https://github.com/golang/go/blob/go1.13.8/src/cmd/compile/internal/gc/walk.go">walk.go</a>
OMAKECHAN类型的节点最终会在SSA中间代码生成之前被转化成runtime.makechan或者runtime.makechan64</p>
<pre><code>func walkexpr(n *Node, init *Nodes) *Node {
    ...
    switch n.Op {
    ...
    case OMAKECHAN:
        // When size fits into int, use makechan instead of
        // makechan64, which is faster and shorter on 32 bit platforms.
        size := n.Left
        fnname := &quot;makechan64&quot;
        argtype := types.Types[TINT64]

        // Type checking guarantees that TIDEAL size is positive and fits in an int.
        // The case of size overflow when converting TUINT or TUINTPTR to TINT
        // will be handled by the negative range checks in makechan during runtime.
        if size.Type.IsKind(TIDEAL) || maxintval[size.Type.Etype].Cmp(maxintval[TUINT]) &lt;= 0 {
            fnname = &quot;makechan&quot;
            argtype = types.Types[TINT]
        }

        n = mkcall1(chanfn(fnname, 1, n.Type), n.Type, init, typename(n.Type), conv(size, argtype))
    ...
    }
    ...
}
</code></pre><h3 id="311-makechan64">3.1.1 makechan64</h3>
<p>check一下size是否是int，然后就执行makechan了</p>
<pre><code>func makechan64(t *chantype, size int64) *hchan {
	if int64(int(size)) != size {
		panic(plainError(&quot;makechan: size out of range&quot;))
	}

	return makechan(t, int(size))
}
</code></pre><h3 id="312-makechan">3.1.2 makechan</h3>
<ol>
<li>安全检查: channel能存的元素类型大小是否超过2^16</li>
<li>判断<a href="https://www.cnblogs.com/wuwangchuxin0924/p/12735129.html">hchanSize</a>是否关于maxAlign对齐，判断元素对齐是否maxAlign小，如果大maxAlign就没用了，这里hchanSize设计十分巧妙，位运算神操作优化，可以看另一篇文章<a href="https://www.cnblogs.com/wuwangchuxin0924/p/12735129.html">关于2的n次幂对齐</a></li>
<li>判断申请的空间大小是否uint64大，判断所需空间是否超过最大可申请空间，判断size是否小于0(非法)</li>
<li>然后就是给hchan申请内存空间了
<ol>
<li>无缓冲的size=0的，只需要给hchan申请hchansize大小的内存空间即可</li>
<li>有缓冲，但是元素是非指针类型的，就申请hchanSize+mem大小的连续内存空间, 并将hchanSize之后的首地址赋值给buf</li>
<li>有缓冲，并且元素类型是指针的，hchan和底层buf内存就可以分开申请不用连续</li>
</ol>
</li>
<li>给其他变量赋值</li>
<li>返回hchan指针，<strong>注意这里返回的是指针，所以channel在各函数之间传递时，就不是值传递了</strong></li>
</ol>
<p><strong>为什么元素类型是非指针hchan和buf要在一段地址连续的内存中，而指针类型的则可以分开</strong>
这是源码注释的原话:
Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.
buf points into the same allocation, elemtype is persistent.
SudoG&rsquo;s are referenced from their owning thread so they can&rsquo;t be collected.
TODO(dvyukov,rlh): Rethink when collector can move allocated objects.
<strong>猜想:</strong>
大概意思是，当channel中元素类型不包含指针时，gc时需要回收这段空间的，当channel中元素类型包含指针时，这些指针被自己所在线程引用gc是不能回收，所以当元素不包含指针时申请一段连续的空间可以减小gc的压力</p>
<pre><code>func makechan(t *chantype, size int) *hchan {
	elem := t.elem

	// compiler checks this but be safe.
	if elem.size &gt;= 1&lt;&lt;16 {
		throw(&quot;makechan: invalid channel element type&quot;)
	}
	if hchanSize%maxAlign != 0 || elem.align &gt; maxAlign {
		throw(&quot;makechan: bad alignment&quot;)
	}

	// 计算大小需要多少空间，check是否
	// 	math.MulUintptr(a, b)函数返回a * b，以及结果是否超过uintptr的最大值
	// 判断所需空间是否比uint64大，判断所需空间是否超过最大可申请空间，判断size是否小于0(非法)
	mem, overflow := math.MulUintptr(elem.size, uintptr(size))
	if overflow || mem &gt; maxAlloc-hchanSize || size &lt; 0 {
		panic(plainError(&quot;makechan: size out of range&quot;))
	}

	var c *hchan
	switch {
	case mem == 0:
		// 就是无缓冲channel，只需要申请hchan需要的大小就行
		c = (*hchan)(mallocgc(hchanSize, nil, true))
		c.buf = c.raceaddr()
	case elem.ptrdata == 0:
		// 有缓冲队列channel，但是存放元素不是指针类型的，就要申请hchanSize+这些元素大小的内存空间，然后把申请下来空间首地址赋给buf
		c = (*hchan)(mallocgc(hchanSize+mem, nil, true))
		c.buf = add(unsafe.Pointer(c), hchanSize)
	default:
		// 默认除了给hchan申请内存空间之外还需要申请size个元素大小的内存空间，并且把首地址赋给c.buf
		c = new(hchan)
		c.buf = mallocgc(mem, elem, true)
	}

	c.elemsize = uint16(elem.size)
	c.elemtype = elem
	c.dataqsiz = uint(size)

	if debugChan {
		print(&quot;makechan: chan=&quot;, c, &quot;; elemsize=&quot;, elem.size, &quot;; elemalg=&quot;, elem.alg, &quot;; dataqsiz=&quot;, size, &quot;\n&quot;)
	}
	return c
}
</code></pre><h2 id="32-发送">3.2 发送</h2>
<p><strong>具体编译时做的转换可参考makechan，代码都在类似的地方</strong></p>
<h3 id="321-chansend">3.2.1 chansend</h3>
<ol>
<li>首先检测channel是否为空, 如果为空直接报错</li>
<li>check是否开启了竞争检测，golang的竞争检测通过ThreadSanitizer库(C++)做的</li>
<li>然后kill掉一些不用加锁就可以判断的情况，如果是非阻塞并且channel未关闭，size = 0或者channel满了, 直接返回false(发送失败)</li>
<li>如果已经有goroutine在等待了，就直接调send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int)发给那个goroutine</li>
<li>如果没有goroutine在等待.</li>
<li>如果channel是非阻塞并且还地方，就放入buffer中，如果没地方了就直接返回false</li>
<li>如果channel是阻塞并且不在select中或者在select中且没有其他出口的，就将创建一个sudog，将sudog初始化并且放入待发送队列(sendq), 并且调用goparkunlock(&amp;c.lock, waitReasonChanSend, traceEvGoBlockSend, 3)使当前goroutine陷入沉睡直到被唤醒(已经发出去了)</li>
<li>清理这个过程的垃圾数据</li>
</ol>
<p><strong>第四步中如果有goroutine在等待就直接发送，会影响非阻塞channel数据的顺序吗？</strong>
不会，channel的数据由唯一全局锁保护，读写互斥，假设一个goroutine来读channel，只有两种情况:</p>
<ol>
<li>channel buffer中有数据，这时goroutine会直接读取数据，不会被阻塞。</li>
<li>channel buffer中没有数据，这时goroutine会被阻塞。</li>
</ol>
<p>只有当buffer中有数据且有goroutine被阻塞时，顺序才会被打乱，但这两个条件是互斥的，有数据就不可能阻塞，阻塞就不可能有数据。</p>
<pre><code>// entry point for c &lt;- x from compiled code
//go:nosplit
func chansend1(c *hchan, elem unsafe.Pointer) {
	chansend(c, elem, true, getcallerpc())
}
</code></pre><pre><code>func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {
	// 如果c为空
	if c == nil {
		// 如果是非阻塞的，就是那种有容量的，就返回false写channel失败
		if !block {
			return false
		}
		// 如果是非阻塞的就让当前goroutine停止(这里写个小程序就能看效果，这个goroutine的defer不会执行)
		gopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2)
		throw(&quot;unreachable&quot;)
	}

	if debugChan {
		print(&quot;chansend: chan=&quot;, c, &quot;\n&quot;)
	}

	if raceenabled { // 开启竞争检测
		racereadpc(c.raceaddr(), callerpc, funcPC(chansend))
	}

	// 先不加锁判断非阻塞channel且没关闭
	// 如果size = 0或者channel满了, 直接返回false(发送失败)
	if !block &amp;&amp; c.closed == 0 &amp;&amp; ((c.dataqsiz == 0 &amp;&amp; c.recvq.first == nil) ||
		(c.dataqsiz &gt; 0 &amp;&amp; c.qcount == c.dataqsiz)) {
		return false
	}

	var t0 int64
	if blockprofilerate &gt; 0 {
		t0 = cputicks()
	}

	// channel加锁
	lock(&amp;c.lock)

	// 如果channel关闭了，就返回panic
	if c.closed != 0 {
		unlock(&amp;c.lock)
		panic(plainError(&quot;send on closed channel&quot;))
	}

	// 等receive队列的队首中取出一个接收者，如果这个接收者不是nil就绕过buffer直接把ep发给他，并且释放锁
	if sg := c.recvq.dequeue(); sg != nil {
		// Found a waiting receiver. We pass the value we want to send
		// directly to the receiver, bypassing the channel buffer (if any).
		send(c, sg, ep, func() { unlock(&amp;c.lock) }, 3)
		return true
	}

	// channel还没满就将元素放入buffer
	if c.qcount &lt; c.dataqsiz {
		// Space is available in the channel buffer. Enqueue the element to send.
		// 获取一下发送数据的位置
		qp := chanbuf(c, c.sendx)
		if raceenabled {
			raceacquire(qp)
			racerelease(qp)
		}
		// 将元素拷贝进buffer
		typedmemmove(c.elemtype, qp, ep)
		c.sendx++
		if c.sendx == c.dataqsiz { // 循环一下
			c.sendx = 0
		}
		c.qcount++
		unlock(&amp;c.lock)
		return true
	}

	// 如果是非阻塞channel满了就返回false
	if !block {
		unlock(&amp;c.lock)
		return false
	}

	// Block on the channel. Some receiver will complete our operation for us.
	// 获取当前goroutine
	gp := getg()
	// 创建sudog
	mysg := acquireSudog()
	mysg.releasetime = 0
	if t0 != 0 {
		mysg.releasetime = -1
	}
	// No stack splits between assigning elem and enqueuing mysg
	// on gp.waiting where copystack can find it.
	// 完善sudog的信息
	mysg.elem = ep
	mysg.waitlink = nil
	mysg.g = gp
	mysg.isSelect = false
	mysg.c = c
	gp.waiting = mysg
	gp.param = nil
	// 放入发送列表中
	c.sendq.enqueue(mysg)
	// 将当前goroutine陷入沉睡
	goparkunlock(&amp;c.lock, waitReasonChanSend, traceEvGoBlockSend, 3)
	KeepAlive(ep)
	// 再次唤醒的时候说明元素已经发送完毕了

	// someone woke us up.
	if mysg != gp.waiting {
		throw(&quot;G waiting list is corrupted&quot;)
	}
	gp.waiting = nil
	if gp.param == nil {
		if c.closed == 0 {
			throw(&quot;chansend: spurious wakeup&quot;)
		}
		panic(plainError(&quot;send on closed channel&quot;))
	}
	gp.param = nil
	if mysg.releasetime &gt; 0 {
		blockevent(mysg.releasetime-t0, 2)
	}
	mysg.c = nil
	releaseSudog(mysg)
	return true
}
</code></pre><h4 id="3211-racereadpc">3.2.1.1 racereadpc</h4>
<p>go/src/runtime/race_amd64.s</p>
<p>PC: 指令计数器寄存器
FP: 函数的帧指针，引用函数的参数。使用形如 symbol+offset(FP) 的方式，引用函数的输入参数。例如 arg0+0(FP)，arg1+8(FP)，使用 FP 不加 symbol 时，无法通过编译，在汇编层面来讲，symbol 并没有什么用，加 symbol 主要是为了提升代码可读性。
SP: 当前函数栈帧的底部
SB: 全局静态基指针，一般用来声明函数或全局变量
参数0放在DI通用寄存器
参数1放在SI通用寄存器
参数2放在DX通用寄存器
参数3放在CX通用寄存器</p>
<pre><code>#define RARG0 DI
#define RARG1 SI
#define RARG2 DX
#define RARG3 CX
// void runtime·racereadpc(void *addr, void *callpc, void *pc)
TEXT    runtime·racereadpc(SB), NOSPLIT, $0-24
        MOVQ    addr+0(FP), RARG1
        MOVQ    callpc+8(FP), RARG2
        MOVQ    pc+16(FP), RARG3
        ADDQ    $1, RARG3 // pc is function start, tsan wants return address
        // void __tsan_read_pc(ThreadState *thr, void *addr, void *callpc, void *pc);

        MOVQ    $__tsan_read_pc(SB), AX
        JMP     racecalladdr&lt;&gt;(SB)
</code></pre><h4 id="3212-send">3.2.1.2 send</h4>
<p>用于给goroutine直接发送数据</p>
<ol>
<li>如果数据没问题就直接将数据拷贝到x := &lt;- c表达式x的内存地址上</li>
<li>然后将该goroutine放到处理器(P)的runnext上面等待执行，这里不是直接让goroutine执行，而是等下一次调度的时候直接调这个goroutine</li>
</ol>
<pre><code>func send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) {
	if raceenabled {
		if c.dataqsiz == 0 {
			racesync(c, sg)
		} else {
			qp := chanbuf(c, c.recvx)
			raceacquire(qp)
			racerelease(qp)
			raceacquireg(sg.g, qp)
			racereleaseg(sg.g, qp)
			c.recvx++
			if c.recvx == c.dataqsiz {
				c.recvx = 0
			}
			c.sendx = c.recvx // c.sendx = (c.sendx+1) % c.dataqsiz
		}
	}
	if sg.elem != nil { // 如果元素没问题就将发送的数据拷贝到x := &lt;- c表达式x所在内存地址上
		sendDirect(c.elemtype, sg, ep)
		sg.elem = nil
	}
	// 然后将将该goroutine放到处理器(P)的runnext上面等待执行，这里不是直接让goroutine执行，而是等下一次调度的时候直接调这个goroutine
	gp := sg.g
	unlockf()
	gp.param = unsafe.Pointer(sg)
	if sg.releasetime != 0 {
		sg.releasetime = cputicks()
	}
	goready(gp, skip+1)
}
</code></pre><h2 id="33-接收">3.3 接收</h2>
<p><strong>具体编译时做的转换可参考makechan，代码都在类似的地方</strong></p>
<h3 id="331-chanrecv">3.3.1 chanrecv</h3>
<p>两种接收方式：
chanrecv1是丢弃channel出来的元素，类似 &lt;- c这中表达式
chanrecv2是使用channel出来的元素，类似 elem := &lt;- c
最终都会调用到chanrecv</p>
<pre><code>// entry points for &lt;- c from compiled code
//go:nosplit
func chanrecv1(c *hchan, elem unsafe.Pointer) {
	chanrecv(c, elem, true)
}

//go:nosplit
func chanrecv2(c *hchan, elem unsafe.Pointer) (received bool) {
	_, received = chanrecv(c, elem, true)
	return
}
</code></pre><ol>
<li>判断chan是否为nil，如果是直接报错</li>
<li>kill掉一些不用枷锁就可以判断的情况，如果是非阻塞并且队列为空并且channel未关闭就返回false</li>
<li>如果channel已经关闭了，就清空ep中的数据，立即返回</li>
<li>如果已经有sendq在等待了(发送端提到过，如果没有goroutine等待接受，就加入sendq), 就直接接收这个元素</li>
<li>如果此时没有goroutine等待发送</li>
<li>如果是非阻塞且buffer中有数据直接从buffer中取出，如果没有数据直接返回false</li>
<li>如果是阻塞的且当前goroutine没在select中或者在select中但没有其他出口，就把自己加入recvq，然后调用goparkunlock(&amp;c.lock, waitReasonChanReceive, traceEvGoBlockRecv, 3)，等待被唤醒（如果被唤醒说明有有数据来了)</li>
<li>清理这个过程中的垃圾数据</li>
</ol>
<pre><code>func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {
	if debugChan {
		print(&quot;chanrecv: chan=&quot;, c, &quot;\n&quot;)
	}

	// channel为空就使goroutine 停止并报错
	if c == nil {
		if !block {
			return
		}
		gopark(nil, nil, waitReasonChanReceiveNilChan, traceEvGoStop, 2)
		throw(&quot;unreachable&quot;)
	}

	// 如果是非阻塞并且队列为空并且channel未关闭就返回false
	if !block &amp;&amp; (c.dataqsiz == 0 &amp;&amp; c.sendq.first == nil ||
		c.dataqsiz &gt; 0 &amp;&amp; atomic.Loaduint(&amp;c.qcount) == 0) &amp;&amp;
		atomic.Load(&amp;c.closed) == 0 {
		return
	}

	var t0 int64
	if blockprofilerate &gt; 0 {
		t0 = cputicks()
	}

	lock(&amp;c.lock)

	// 如果channel已关闭, 并且没有数据了就清除ep中的数据立刻返回
	if c.closed != 0 &amp;&amp; c.qcount == 0 {
		if raceenabled {
			raceacquire(c.raceaddr())
		}
		unlock(&amp;c.lock)
		if ep != nil {
			typedmemclr(c.elemtype, ep)
		}
		return true, false
	}

	// 如果已经有goroutine等着了，就直接让这个goroutine recive
	if sg := c.sendq.dequeue(); sg != nil {
		recv(c, sg, ep, func() { unlock(&amp;c.lock) }, 3)
		return true, true
	}

	// channel不为空将元素复制到ep中(ep := &lt;- c)
	if c.qcount &gt; 0 {
		// Receive directly from queue
		qp := chanbuf(c, c.recvx)
		if raceenabled {
			raceacquire(qp)
			racerelease(qp)
		}
		if ep != nil {
			typedmemmove(c.elemtype, ep, qp)
		}
		typedmemclr(c.elemtype, qp)
		c.recvx++
		if c.recvx == c.dataqsiz {
			c.recvx = 0
		}
		c.qcount--
		unlock(&amp;c.lock)
		return true, true
	}


	// 如果是非阻塞直接返回false
	if !block {
		unlock(&amp;c.lock)
		return false, false
	}

	// 获取当前goroutine
	gp := getg()
	// 创建sudog
	mysg := acquireSudog()
	mysg.releasetime = 0
	if t0 != 0 {
		mysg.releasetime = -1
	}
	mysg.elem = ep
	mysg.waitlink = nil
	gp.waiting = mysg
	mysg.g = gp
	mysg.isSelect = false
	mysg.c = c
	gp.param = nil
	c.recvq.enqueue(mysg)
	goparkunlock(&amp;c.lock, waitReasonChanReceive, traceEvGoBlockRecv, 3)

	// someone woke us up
	if mysg != gp.waiting {
		throw(&quot;G waiting list is corrupted&quot;)
	}
	gp.waiting = nil
	if mysg.releasetime &gt; 0 {
		blockevent(mysg.releasetime-t0, 2)
	}
	closed := gp.param == nil
	gp.param = nil
	mysg.c = nil
	releaseSudog(mysg)
	return true, !closed
}
</code></pre><h2 id="33-关闭channel">3.3 关闭channel</h2>
<p>关闭channel大概逻辑就是，将buffer中的数据都释放掉，然后close设置为0</p>
<pre><code>func closechan(c *hchan) {
	// 如果为空抛出异常
	if c == nil {
		panic(plainError(&quot;close of nil channel&quot;))
	}

	lock(&amp;c.lock)
	// 如果channel已经关闭就抛出异常
	if c.closed != 0 {
		unlock(&amp;c.lock)
		panic(plainError(&quot;close of closed channel&quot;))
	}

	if raceenabled {
		callerpc := getcallerpc()
		racewritepc(c.raceaddr(), callerpc, funcPC(closechan))
		racerelease(c.raceaddr())
	}

	c.closed = 1

	var glist gList

	// 清理所有的数据
	// release all readers
	for {
		sg := c.recvq.dequeue()
		if sg == nil {
			break
		}
		if sg.elem != nil {
			typedmemclr(c.elemtype, sg.elem)
			sg.elem = nil
		}
		if sg.releasetime != 0 {
			sg.releasetime = cputicks()
		}
		gp := sg.g
		gp.param = nil
		if raceenabled {
			raceacquireg(gp, c.raceaddr())
		}
		glist.push(gp)
	}

	// release all writers (they will panic)
	for {
		sg := c.sendq.dequeue()
		if sg == nil {
			break
		}
		sg.elem = nil
		if sg.releasetime != 0 {
			sg.releasetime = cputicks()
		}
		gp := sg.g
		gp.param = nil
		if raceenabled {
			raceacquireg(gp, c.raceaddr())
		}
		glist.push(gp)
	}
	unlock(&amp;c.lock)

	// Ready all Gs now that we've dropped the channel lock.
	for !glist.empty() {
		gp := glist.pop()
		gp.schedlink = 0
		goready(gp, 3)
	}
}
</code></pre><h1 id="附录">附录</h1>
<h2 id="chandot">chan.dot</h2>
<pre><code>digraph {
    bgcolor=&quot;#C6CFD532&quot;; 

    node [shape=record, fontsize=&quot;8&quot;, margin=&quot;0.04&quot;, height=0.2, color=gray] 
	edge [fontname=&quot;Inconsolata, Consolas&quot;, fontsize=10, arrowhead=normal]

    hchan [shape=record,label=&quot;{qcount|dataqsiz|buf|elemsize|closed|elemtype|&lt;sendx&gt;sendx|&lt;recvx&gt;recvx|recvq|sendq|lock}&quot;,xlabel=&quot;hchan&quot;]
    waitq[shape=record,label=&quot;{&lt;first&gt;first|&lt;last&gt;last}&quot;,xlabel=&quot;waitq&quot;]
    sudog[shape=record,label=&quot;{g|isSelect|next|prev|elem|acquiretime|releasetime|ticket|parent|waitlink|waittail|c}&quot;,xlabel=&quot;sudog&quot;]

    hchan:sendx -&gt; waitq [label=&quot;发送队列&quot;]
    hchan:recvx -&gt; waitq [label=&quot;接收队列&quot;]
    waitq:first -&gt; sudog
    waitq:last -&gt; sudog
}
</code></pre>
    </div>
  </article>

  

</main>

      
    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
	var gitalk = new Gitalk({
    		clientID: 'a60f22cd3c5d7e6aafa8',
    		clientSecret: 'db8f7c66f2e8e20275173155975b749870291c5b',
    		repo: 'journey-c.github.io',
    		owner: 'journey-c',
    		admin: ['journey-c'],
    		id: '<%=page.title%>',
    		distractionFreeMode: true
  	});
  	gitalk.render('gitalk-container');
</script>

    

      <footer class="footer">
        <ul class="footer-links">
          <li>
            <p>Copyright @ 2020-<script>document.write(new Date().getFullYear())</script> <a class="footer-links-kudos" href="https://github.com/journey-c">Journey-C</a>.
    </p>
          </li>
        </ul>
      </footer>

    </div>

    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-S162K82BSE"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-S162K82BSE');
</script>


    <script type=text/javascript async src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$']],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(),
            i;
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
    MathJax.Hub.Config({
        TeX: {
            equationNumbers: {
                autoNumber: "AMS"
            }
        }
    });
    </script>
  </body>
</html>

