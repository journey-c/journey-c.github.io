<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Hugo 0.74.3" />


<title>goroutine 源码阅读 - Journey-C</title>
<meta property="og:title" content="goroutine 源码阅读 - Journey-C">


  <link href='https://journey-c.github.io/favicon.png' rel='icon' type='image/x-icon'/>



  




<link rel="icon" href="https://journey-c.github.io/images/" type="image/x-icon"/>
<link rel="stylesheet" href="https://journey-c.github.io/css/main.css" media="all">
<link rel="stylesheet" href="https://journey-c.github.io/css/fonts.css" media="all">
<link rel="stylesheet" href="https://journey-c.github.io/css/prism.css" media="all">
<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Merriweather:400|Lato:400,400italic,700">
<script type="text/javascript" src="https://journey-c.github.io/js/main.js"></script>
<script type="text/javascript" src="https://journey-c.github.io/js/prism.js"></script>

  </head>
  <body>
    <div class="wrapper">
      <header class="header">
        <nav class="nav">
  <a href="https://journey-c.github.io/" class="nav-logo">
    <img src="https://journey-c.github.io/images/yangguo.png" 
         width="50" 
         height="50" 
         alt="Logo">
  </a>

  <ul class="nav-links">
    
    <li><a href="/archives/"></a></li>
    
    <li><a href="/tags/"></a></li>
    
    <li><a href="/about/">About</a></li>
    
    <li><a href="https://github.com/journey-c">Github</a></li>
    
    <li><a href="https://www.cnblogs.com/wuwangchuxin0924/">博客园</a></li>
    
  </ul>
</nav>

      </header>


<main class="content" role="main">
  <article class="article">
    
    
<section class="toc-section" id="toc-section">









<div class="article-toc" id="article-toc">

    <div class="article-toc-header"><strong>CONTENTS</strong></div>

    <div id="page-scrollspy" class="article-toc-nav">

        
        
            
                
                
                    
                    <ul class="nav">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#1%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84">
                            1.数据结构
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav">
                    
                    <ul class="nav">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#11-g">
                            1.1 G
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav">
                    
                    <ul class="nav">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#12-m">
                            1.2 M
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav">
                    
                    <ul class="nav">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#13-p">
                            1.3 P
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav">
                    
                    <ul class="nav">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#14-schedt">
                            1.4 schedt
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav">
                    
                    <ul class="nav">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#15-%e9%87%8d%e8%a6%81%e7%9a%84%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f">
                            1.5 重要的全局变量
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#2%e5%88%86%e6%ad%a5%e9%aa%a4%e5%89%96%e6%9e%90%e8%b0%83%e5%ba%a6%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96">
                            2.分步骤剖析调度的初始化
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav">
                    
                    <ul class="nav">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#21-%e7%bc%96%e8%af%91">
                            2.1 编译
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav">
                    
                    <ul class="nav">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#22-%e8%b0%83%e8%af%95">
                            2.2 调试
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav">
                    
                    <ul class="nav">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#23-%e5%88%9d%e5%a7%8b%e5%8c%96">
                            2.3 初始化
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav">
                    
                    <ul class="nav">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#24-%e8%b0%83%e5%ba%a6%e5%be%aa%e7%8e%af">
                            2.4 调度循环
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                
            
        
        
            
                
                
                    
                    <ul class="nav">
                    
                    <ul class="nav">
                    
                    
                        <li class="nav-item">
                            <a class="nav-link text-left" href="#25-%e8%a7%a6%e5%8f%91%e8%b0%83%e5%ba%a6">
                            2.5 触发调度
                            </a>
                        </li>
                    
                    
                    </ul>
                    
                    </ul>
                    
                
            
        

    </div>
    
</div>



</section>

    

    
    <span class="article-duration">14 min read</span>
    

    <h1 class="article-title">goroutine 源码阅读</h1>

    
    <span class="article-date">2020-10-29</span>
    

    
        
            
            <a class="article-tag" href="https://journey-c.github.io/tags/%E6%BA%90%E7%A0%81">源码</a>
            
            <a class="article-tag" href="https://journey-c.github.io/tags/golang">Golang</a>
            
        
    

    <div class="article-content">
      <h1 id="1数据结构">1.数据结构</h1>
<p>调度相关的数据结构有三个，M(线程)，P(调度器)，G(goroutine)
M表示线程，P作为调度器用来帮助每个线程管理自己的goroutine，G就是golang的协程。我们可以通过runtime.GOMAXPROCS(n int)函数设置P的个数，<strong>注意</strong>P的个数并不代表M的个数，例如程序启动时runtime代码会出实话procs个P，但开始的时候只会启动一个M，就是M0和一个栈为64K(其他goroutine默认初始栈大小2K)来执行runtime代码。</p>
<!-- raw HTML omitted -->
<p><strong>那其他线程是什么时候创建的呐?</strong>
当goroutine被唤醒时，要在M上运行(恢复goroutine的上下文)，P是帮助M管理goroutine的，恢复上下文的操作也由P来完成。如果被唤醒时发现还有空闲的P，并且没有其他M在窃取goroutine(M发现本地goroutine队列和全局goroutine队列都没有goroutine的时候，会去其他线程窃取goroutine)，说明其他M都在忙，就会创建一个M让这个空闲的P帮他来管理goroutine。
总之一句话，开始的时候创建一个M，当发现调度不过来且还有空闲P没有工作就在创建新的，直到创建procs个M(procs通过runtime.GOMAXPROCS设置)</p>
<p><img src="/images/model.png" alt="model"></p>
<h2 id="11-g">1.1 G</h2>
<p>golang 用结构体g表示goroutine</p>
<ul>
<li>g</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">g</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">stack</span>       <span style="color:#a6e22e">stack</span>   <span style="color:#75715e">// 当前栈的范围[stack.lo, stack.hi)
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">stackguard0</span> <span style="color:#66d9ef">uintptr</span> <span style="color:#75715e">// 用于抢占的，一般情况值为stack.lo + StackGuard
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">stackguard1</span> <span style="color:#66d9ef">uintptr</span> <span style="color:#75715e">// 用于C语言的抢占
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">_panic</span>         <span style="color:#f92672">*</span><span style="color:#a6e22e">_panic</span> <span style="color:#75715e">// 最内侧的panic函数
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">_defer</span>         <span style="color:#f92672">*</span><span style="color:#a6e22e">_defer</span> <span style="color:#75715e">// 最外侧的defer函数
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">m</span>              <span style="color:#f92672">*</span><span style="color:#a6e22e">m</span>      <span style="color:#75715e">// 当前goroutine属于哪个m
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">sched</span>          <span style="color:#a6e22e">gobuf</span> <span style="color:#75715e">// 调度相关信息
</span><span style="color:#75715e"></span>	<span style="color:#f92672">...</span>
	<span style="color:#a6e22e">schedlink</span>      <span style="color:#a6e22e">guintptr</span> <span style="color:#75715e">// sched是全局的goroutine链表，schedlink表示这个goroutine在链表中的下一个goroutine的指针
</span><span style="color:#75715e"></span>	<span style="color:#f92672">...</span>
	<span style="color:#a6e22e">preempt</span>        <span style="color:#66d9ef">bool</span>       <span style="color:#75715e">// 抢占标志，如果需要抢占就将preempt设置为true
</span><span style="color:#75715e"></span>	<span style="color:#f92672">...</span>
}
</code></pre></div><ul>
<li>gobuf
gobuf保存goroutine的调度信息，当一个goroutine被调度的时，本质上就是把这个goroutine放到cpu，恢复各个寄存器的值，然后运行</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">gobuf</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">sp</span>   <span style="color:#66d9ef">uintptr</span> <span style="color:#75715e">// 栈指针
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">pc</span>   <span style="color:#66d9ef">uintptr</span> <span style="color:#75715e">// 程序计数器
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">g</span>    <span style="color:#a6e22e">guintptr</span> <span style="color:#75715e">// 当前被哪个goroutine持有
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">ctxt</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>
	<span style="color:#a6e22e">ret</span>  <span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">Uintreg</span> <span style="color:#75715e">// 系统调用返回值，防止系统调用后被其他goroutine抢占，所以有个地方保存返回值
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">lr</span>   <span style="color:#66d9ef">uintptr</span>
	<span style="color:#a6e22e">bp</span>   <span style="color:#66d9ef">uintptr</span> <span style="color:#75715e">// 保存CPU的rip寄存器的值
</span><span style="color:#75715e"></span>}
</code></pre></div><h2 id="12-m">1.2 M</h2>
<p>golang中M表示实际操作系统的线程</p>
<ul>
<li>m</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">m</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">g0</span>      <span style="color:#f92672">*</span><span style="color:#a6e22e">g</span>     <span style="color:#75715e">// g0帮M处理大小事务的goroutine，他是m中的第一个goroutine
</span><span style="color:#75715e"></span>	<span style="color:#f92672">...</span>
	<span style="color:#a6e22e">gsignal</span>       <span style="color:#f92672">*</span><span style="color:#a6e22e">g</span>           <span style="color:#75715e">// 用于信号处理的goroutine
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">tls</span>           [<span style="color:#ae81ff">6</span>]<span style="color:#66d9ef">uintptr</span>   <span style="color:#75715e">// 线程私有空间
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">mstartfn</span>      <span style="color:#66d9ef">func</span>()
	<span style="color:#a6e22e">curg</span>          <span style="color:#f92672">*</span><span style="color:#a6e22e">g</span>       <span style="color:#75715e">// current running goroutine
</span><span style="color:#75715e"></span>	<span style="color:#f92672">...</span>
	<span style="color:#a6e22e">p</span>             <span style="color:#a6e22e">puintptr</span> <span style="color:#75715e">// 当前正在运行的p(处理器)
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">nextp</span>         <span style="color:#a6e22e">puintptr</span> <span style="color:#75715e">// 暂存的p
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">oldp</span>          <span style="color:#a6e22e">puintptr</span> <span style="color:#75715e">// 执行系统调用之前的p
</span><span style="color:#75715e"></span>	<span style="color:#f92672">...</span>
	<span style="color:#a6e22e">spinning</span>      <span style="color:#66d9ef">bool</span> <span style="color:#75715e">// 表示当前m没有goroutine了，正在从其他m偷取goroutine
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">blocked</span>       <span style="color:#66d9ef">bool</span> <span style="color:#75715e">// m is blocked on a note
</span><span style="color:#75715e"></span>	<span style="color:#f92672">...</span>
	<span style="color:#a6e22e">park</span>          <span style="color:#a6e22e">note</span> <span style="color:#75715e">// m没有goroutine的时候会在park上sleep，需要其他m在park中wake up这个m
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">alllink</span>       <span style="color:#f92672">*</span><span style="color:#a6e22e">m</span> <span style="color:#75715e">// on allm // 所有m的链表
</span><span style="color:#75715e"></span>	<span style="color:#f92672">...</span>
	<span style="color:#a6e22e">thread</span>        <span style="color:#66d9ef">uintptr</span> <span style="color:#75715e">// thread handle
</span><span style="color:#75715e"></span>	<span style="color:#f92672">...</span>
}
</code></pre></div><h2 id="13-p">1.3 P</h2>
<p>golang中P表示一个调度器，为M提供上下文环境，使得M可以执行多个goroutine</p>
<ul>
<li>p</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">p</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">m</span>           <span style="color:#a6e22e">muintptr</span>   <span style="color:#75715e">// 与哪个M关联(可能为空的)
</span><span style="color:#75715e"></span>	<span style="color:#f92672">...</span>
	<span style="color:#a6e22e">runqhead</span> <span style="color:#66d9ef">uint32</span> <span style="color:#75715e">// p本地goroutine队列的头
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">runqtail</span> <span style="color:#66d9ef">uint32</span> <span style="color:#75715e">// p本地goroutine队列的尾
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">runq</span>     [<span style="color:#ae81ff">256</span>]<span style="color:#a6e22e">guintptr</span> <span style="color:#75715e">// 队列指针，和sync.pool中数据结构一样也是循环队列
</span><span style="color:#75715e"></span>	<span style="color:#f92672">...</span>
	<span style="color:#a6e22e">sudogcache</span> []<span style="color:#f92672">*</span><span style="color:#a6e22e">sudog</span> <span style="color:#75715e">// sudog缓存，channel用的
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">sudogbuf</span>   [<span style="color:#ae81ff">128</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">sudog</span> <span style="color:#75715e">// 也是防止false sharing
</span><span style="color:#75715e"></span>	<span style="color:#f92672">...</span>
	<span style="color:#a6e22e">pad</span> <span style="color:#a6e22e">cpu</span>.<span style="color:#a6e22e">CacheLinePad</span> <span style="color:#75715e">// 防止false sharing
</span><span style="color:#75715e"></span>}
</code></pre></div><h2 id="14-schedt">1.4 schedt</h2>
<p>schedt结构体用来保存P的状态信息和goroutine的全局运行队列</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">schedt</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#f92672">...</span>
	<span style="color:#a6e22e">lock</span> <span style="color:#a6e22e">mutex</span> <span style="color:#75715e">// 全局锁
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">// 维护空闲的M
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">midle</span>        <span style="color:#a6e22e">muintptr</span> <span style="color:#75715e">// 等待中的M链表
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">nmidle</span>       <span style="color:#66d9ef">int32</span>    <span style="color:#75715e">// 等待中的M的数量
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">nmidlelocked</span> <span style="color:#66d9ef">int32</span>    <span style="color:#75715e">// number of locked m&#39;s waiting for work
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">mnext</span>        <span style="color:#66d9ef">int64</span>    <span style="color:#75715e">// number of m&#39;s that have been created and next M ID
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">maxmcount</span>    <span style="color:#66d9ef">int32</span>    <span style="color:#75715e">// 最多创建多少个M(10000)
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">nmsys</span>        <span style="color:#66d9ef">int32</span>    <span style="color:#75715e">// number of system m&#39;s not counted for deadlock
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">nmfreed</span>      <span style="color:#66d9ef">int64</span>    <span style="color:#75715e">// cumulative number of freed m&#39;s
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">ngsys</span> <span style="color:#66d9ef">uint32</span> <span style="color:#75715e">// number of system goroutines; updated atomically
</span><span style="color:#75715e"></span>	
	<span style="color:#75715e">// 维护空闲的P
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">pidle</span>      <span style="color:#a6e22e">puintptr</span> <span style="color:#75715e">// idle p&#39;s
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">npidle</span>     <span style="color:#66d9ef">uint32</span>
	<span style="color:#a6e22e">nmspinning</span> <span style="color:#66d9ef">uint32</span> <span style="color:#75715e">// See &#34;Worker thread parking/unparking&#34; comment in proc.go.
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">// goroutine的全局队列
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">runq</span>     <span style="color:#a6e22e">gQueue</span>
	<span style="color:#a6e22e">runqsize</span> <span style="color:#66d9ef">int32</span>
	<span style="color:#f92672">...</span>
	<span style="color:#75715e">// 全局缓存已经退出的goroutine链表，下次再创建的时候直接用
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// Global cache of dead G&#39;s.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">gFree</span> <span style="color:#66d9ef">struct</span> {
		<span style="color:#a6e22e">lock</span>    <span style="color:#a6e22e">mutex</span>
		<span style="color:#a6e22e">stack</span>   <span style="color:#a6e22e">gList</span> <span style="color:#75715e">// Gs with stacks
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">noStack</span> <span style="color:#a6e22e">gList</span> <span style="color:#75715e">// Gs without stacks
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">n</span>       <span style="color:#66d9ef">int32</span>
	}
	<span style="color:#f92672">...</span>
}
</code></pre></div><h2 id="15-重要的全局变量">1.5 重要的全局变量</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">allgs</span>    []<span style="color:#f92672">*</span><span style="color:#a6e22e">g</span>   <span style="color:#75715e">// 保存所有的g
</span><span style="color:#75715e"></span><span style="color:#a6e22e">allm</span>     <span style="color:#f92672">*</span><span style="color:#a6e22e">m</span>     <span style="color:#75715e">// 所有的m构成的一个链表，包括下面的m0
</span><span style="color:#75715e"></span><span style="color:#a6e22e">allp</span>     []<span style="color:#f92672">*</span><span style="color:#a6e22e">p</span>  <span style="color:#75715e">// 保存所有的p，len(allp) == gomaxprocs
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">ncpu</span>         <span style="color:#66d9ef">int32</span>  <span style="color:#75715e">// 系统中cpu核的数量，程序启动时由runtime代码初始化
</span><span style="color:#75715e"></span><span style="color:#a6e22e">gomaxprocs</span>   <span style="color:#66d9ef">int32</span>  <span style="color:#75715e">// p的最大值，默认等于ncpu，但可以通过GOMAXPROCS修改
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">sched</span>     <span style="color:#a6e22e">schedt</span>    <span style="color:#75715e">// 调度器结构体对象，记录了调度器的工作状态
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">m0</span> <span style="color:#a6e22e">m</span>        <span style="color:#75715e">// 代表进程的主线程
</span><span style="color:#75715e"></span><span style="color:#a6e22e">g0</span>  <span style="color:#a6e22e">g</span>       <span style="color:#75715e">// m0的g0，也就是m0.g0 = &amp;g0
</span></code></pre></div><h1 id="2分步骤剖析调度的初始化">2.分步骤剖析调度的初始化</h1>
<p>下面是用go实现的hello world，代码里并没有关于调度的初始化，所以程序的入口并非是main.main，下面通过gdb一步步找到go是如何初始化调度的。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// test.go
</span><span style="color:#75715e"></span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	println(<span style="color:#e6db74">&#34;hello, world!&#34;</span>)
}
</code></pre></div><h2 id="21-编译">2.1 编译</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">go build -gcflags <span style="color:#e6db74">&#34;-N -l&#34;</span> test.go
</code></pre></div><p><strong>使用OS X的同学注意，go1.11之后压缩的debug信息，OS X的同学需要同时做以下设置参考<a href="https://stackoverflow.com/questions/52534287/debug-go-program-with-gdb-on-macos">Debug Go Program With Gdb On Macos</a></strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">export GOFLAGS<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;-ldflags=-compressdwarf=false&#34;</span>
</code></pre></div><h2 id="22-调试">2.2 调试</h2>
<ul>
<li>利用断点可以找出目标文件的信息，在入口处打一个断点，找到程序入口在rt0_darwin_amd64.s的第8行</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">➜  sudo gdb test 
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> info files
Symbols from <span style="color:#e6db74">&#34;/Users/journey/workspace/src/tool/gdb/test&#34;</span>.
Local exec file:
	<span style="color:#e6db74">`</span>/Users/journey/workspace/src/tool/gdb/test<span style="color:#960050;background-color:#1e0010">&#39;</span>, file type mach-o-x86-64.
	Entry point: 0x104cd00
	0x0000000001001000 - 0x00000000010515b1 is .text
	0x00000000010515c0 - 0x000000000108162a is __TEXT.__rodata
	0x0000000001081640 - 0x0000000001081706 is __TEXT.__symbol_stub1
	0x0000000001081720 - 0x0000000001081e80 is __TEXT.__typelink
	0x0000000001081e80 - 0x0000000001081e88 is __TEXT.__itablink
	0x0000000001081e88 - 0x0000000001081e88 is __TEXT.__gosymtab
	0x0000000001081ea0 - 0x00000000010bfacd is __TEXT.__gopclntab
	0x00000000010c0000 - 0x00000000010c0020 is __DATA.__go_buildinfo
	0x00000000010c0020 - 0x00000000010c0128 is __DATA.__nl_symbol_ptr
	0x00000000010c0140 - 0x00000000010c0d08 is __DATA.__noptrdata
	0x00000000010c0d20 - 0x00000000010c27f0 is .data
	0x00000000010c2800 - 0x00000000010ddc90 is .bss
	0x00000000010ddca0 - 0x00000000010e01e8 is __DATA.__noptrbss
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> b *0x104cd00
Breakpoint <span style="color:#ae81ff">1</span> at 0x104cd00: file /usr/local/go/src/runtime/rt0_darwin_amd64.s, line 8.
</code></pre></div><ul>
<li>进入上面找到的文件rt0_darwin_amd64.s(不同的架构文件是不同的)</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">➜  runtime ls rt0_*
rt0_aix_ppc64.s       rt0_darwin_amd64.s    rt0_freebsd_arm.s     rt0_linux_arm64.s     rt0_nacl_386.s        rt0_netbsd_arm64.s    rt0_plan9_amd64.s
rt0_android_386.s     rt0_darwin_arm.s      rt0_illumos_amd64.s   rt0_linux_mips64x.s   rt0_nacl_amd64p32.s   rt0_openbsd_386.s     rt0_plan9_arm.s
rt0_android_amd64.s   rt0_darwin_arm64.s    rt0_js_wasm.s         rt0_linux_mipsx.s     rt0_nacl_arm.s        rt0_openbsd_amd64.s   rt0_solaris_amd64.s
rt0_android_arm.s     rt0_dragonfly_amd64.s rt0_linux_386.s       rt0_linux_ppc64.s     rt0_netbsd_386.s      rt0_openbsd_arm.s     rt0_windows_386.s
rt0_android_arm64.s   rt0_freebsd_386.s     rt0_linux_amd64.s     rt0_linux_ppc64le.s   rt0_netbsd_amd64.s    rt0_openbsd_arm64.s   rt0_windows_amd64.s
rt0_darwin_386.s      rt0_freebsd_amd64.s   rt0_linux_arm.s       rt0_linux_s390x.s     rt0_netbsd_arm.s      rt0_plan9_386.s       rt0_windows_arm.s
</code></pre></div><ul>
<li>打开文件go/src/runtime/rt0_darwin_amd64.s:8
这里没有做什么就调了函数_rt0_amd64</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">TEXT</span> <span style="color:#a6e22e">_rt0_amd64_darwin</span>(<span style="color:#a6e22e">SB</span>),<span style="color:#a6e22e">NOSPLIT</span>,<span style="color:#960050;background-color:#1e0010">$</span><span style="color:#f92672">-</span><span style="color:#ae81ff">8</span> <span style="color:#75715e">// 参数+返回值共8字节
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">JMP</span>	<span style="color:#a6e22e">_rt0_amd64</span>(<span style="color:#a6e22e">SB</span>)
</code></pre></div><ul>
<li>然后在打断点看看_rt0_amd64在哪
在ams_amd64.s第15行</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> b _rt0_amd64
Breakpoint <span style="color:#ae81ff">2</span> at 0x1049350: file /usr/local/go/src/runtime/asm_amd64.s, line 15.
</code></pre></div><p>这里首先把参数放到DI，SI寄存器中，然后调用runtime.rt0_go，这就是进程初始化主要函数了
参数0放在DI通用寄存器
参数1放在SI通用寄存器
参数2放在DX通用寄存器
参数3放在CX通用寄存器</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">TEXT</span> <span style="color:#a6e22e">_rt0_amd64</span>(<span style="color:#a6e22e">SB</span>),<span style="color:#a6e22e">NOSPLIT</span>,<span style="color:#960050;background-color:#1e0010">$</span><span style="color:#f92672">-</span><span style="color:#ae81ff">8</span> <span style="color:#75715e">// 参数+返回值共8字节
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#ae81ff">0</span>(<span style="color:#a6e22e">SP</span>), <span style="color:#a6e22e">DI</span>	<span style="color:#75715e">// argc
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">LEAQ</span>	<span style="color:#ae81ff">8</span>(<span style="color:#a6e22e">SP</span>), <span style="color:#a6e22e">SI</span>	<span style="color:#75715e">// argv
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">JMP</span>	<span style="color:#a6e22e">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">rt0_go</span>(<span style="color:#a6e22e">SB</span>)
</code></pre></div><ul>
<li>然后跳转到runtime.rt0_go</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> b runtime.rt0_go
Breakpoint <span style="color:#ae81ff">3</span> at 0x1049360: file /usr/local/go/src/runtime/asm_amd64.s, line 89.
</code></pre></div><h2 id="23-初始化">2.3 初始化</h2>
<p>这个函数有点长，下面我们分段来看rt0_go这个函数</p>
<ul>
<li>初始化参数以及创建g0</li>
</ul>
<ol>
<li>
<p>首先将之前放入通用寄存器的参数放入AX，BX寄存器，然后调整栈顶指针(真SP寄存器)的位置，SP指针先减39，关于16字节向下对齐(因为CPU有一组 SSE 指令，这些指令中出现的内存地址必须是16的倍数)，然后把参数放到SP+16字节和SP+24字节处
<strong>golang的汇编有抽象出来的寄存器，通过是否有前缀变量区分真假寄存器，例如a+8(SP)就是golang的寄存器，8(SP)就是真的寄存器</strong></p>
</li>
<li>
<p>创建g0，并初始化g.stackgruard0，g.stackguard1以及g.stack.lo，g.stack.hi的值(实际上是分配一段内存，然后分割成小段，约定哪小段表示哪个变量)</p>
</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">TEXT</span> <span style="color:#a6e22e">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">rt0_go</span>(<span style="color:#a6e22e">SB</span>),<span style="color:#a6e22e">NOSPLIT</span>,<span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">0</span>
	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#a6e22e">DI</span>, <span style="color:#a6e22e">AX</span>		<span style="color:#75715e">// argc
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#a6e22e">SI</span>, <span style="color:#a6e22e">BX</span>		<span style="color:#75715e">// argv
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">SUBQ</span>	<span style="color:#960050;background-color:#1e0010">$</span>(<span style="color:#ae81ff">4</span><span style="color:#f92672">*</span><span style="color:#ae81ff">8</span><span style="color:#f92672">+</span><span style="color:#ae81ff">7</span>), <span style="color:#a6e22e">SP</span>		<span style="color:#75715e">// 2args 2auto
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">ANDQ</span>	<span style="color:#960050;background-color:#1e0010">$~</span><span style="color:#ae81ff">15</span>, <span style="color:#a6e22e">SP</span>
	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#a6e22e">AX</span>, <span style="color:#ae81ff">16</span>(<span style="color:#a6e22e">SP</span>)
	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#a6e22e">BX</span>, <span style="color:#ae81ff">24</span>(<span style="color:#a6e22e">SP</span>)

	<span style="color:#75715e">// 初始化g0，g0就是go的第一个协程
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// 给g0分配栈空间大概64K
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// 
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#960050;background-color:#1e0010">$</span><span style="color:#a6e22e">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">g0</span>(<span style="color:#a6e22e">SB</span>), <span style="color:#a6e22e">DI</span>
	<span style="color:#a6e22e">LEAQ</span>	(<span style="color:#f92672">-</span><span style="color:#ae81ff">64</span><span style="color:#f92672">*</span><span style="color:#ae81ff">1024</span><span style="color:#f92672">+</span><span style="color:#ae81ff">104</span>)(<span style="color:#a6e22e">SP</span>), <span style="color:#a6e22e">BX</span> <span style="color:#75715e">// BX = SP - 64 * 1024 + 104
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#a6e22e">BX</span>, <span style="color:#a6e22e">g_stackguard0</span>(<span style="color:#a6e22e">DI</span>) <span style="color:#75715e">// g0.g_stackguard0 = SP - 64 * 1024 + 104
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#a6e22e">BX</span>, <span style="color:#a6e22e">g_stackguard1</span>(<span style="color:#a6e22e">DI</span>) <span style="color:#75715e">// g0.g_stackguard1 = SP - 64 * 1024 + 104
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#a6e22e">BX</span>, (<span style="color:#a6e22e">g_stack</span><span style="color:#f92672">+</span><span style="color:#a6e22e">stack_lo</span>)(<span style="color:#a6e22e">DI</span>) <span style="color:#75715e">// g0.stack.lo = SP - 64 * 1024 + 104
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#a6e22e">SP</span>, (<span style="color:#a6e22e">g_stack</span><span style="color:#f92672">+</span><span style="color:#a6e22e">stack_hi</span>)(<span style="color:#a6e22e">DI</span>) <span style="color:#75715e">// g0.stack.hi = SP
</span><span style="color:#75715e"></span>
</code></pre></div><p>创建完g0的内存分布</p>
<p><img src="/images/stack_0.png" alt="stack_0"></p>
<p>然后略过一段CPU型号检测和CGO初始化的代码</p>
<pre><code>...
</code></pre><ul>
<li>创建m0</li>
</ul>
<ol>
<li>创建将m0.tls放入DI寄存器，然后调用runtime.settls将m0设置为线程私有变量(mac下什么也没干)，将m0与主线程绑定，然后对m0.tls进行存取操作验证是否能用，不能用就直接退出</li>
<li>绑定m0和g0的关系，m0.g0 = g0，g0.m = m0</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">	<span style="color:#75715e">// 将m0与主线程绑定
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">LEAQ</span>	<span style="color:#a6e22e">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">m0</span><span style="color:#f92672">+</span><span style="color:#a6e22e">m_tls</span>(<span style="color:#a6e22e">SB</span>), <span style="color:#a6e22e">DI</span> <span style="color:#75715e">// 将m0的thread local store成员的地址到DI
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">CALL</span>	<span style="color:#a6e22e">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">settls</span>(<span style="color:#a6e22e">SB</span>) <span style="color:#75715e">// 调用settls设置线程本地存储(mac 下settls什么都没做，线程已经设置好本地存储了)
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">// 通过往TLS存0x123在判断tls[0]是不是0x123验证TLS是否可用，如果不可用就abort
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">get_tls</span>(<span style="color:#a6e22e">BX</span>)
	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">0x123</span>, <span style="color:#a6e22e">g</span>(<span style="color:#a6e22e">BX</span>)
	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#a6e22e">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">m0</span><span style="color:#f92672">+</span><span style="color:#a6e22e">m_tls</span>(<span style="color:#a6e22e">SB</span>), <span style="color:#a6e22e">AX</span>
	<span style="color:#a6e22e">CMPQ</span>	<span style="color:#a6e22e">AX</span>, <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">0x123</span>
	<span style="color:#a6e22e">JEQ</span> <span style="color:#ae81ff">2</span>(<span style="color:#a6e22e">PC</span>)
	<span style="color:#a6e22e">CALL</span>	<span style="color:#a6e22e">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">abort</span>(<span style="color:#a6e22e">SB</span>)
<span style="color:#a6e22e">ok</span>:
	<span style="color:#75715e">// 把g0存入m0的本地存储tls[0]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">get_tls</span>(<span style="color:#a6e22e">BX</span>) <span style="color:#75715e">// 将m0.tls[0]地址放入BX
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">LEAQ</span>	<span style="color:#a6e22e">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">g0</span>(<span style="color:#a6e22e">SB</span>), <span style="color:#a6e22e">CX</span> <span style="color:#75715e">// 将g0地址放入CX
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#a6e22e">CX</span>, <span style="color:#a6e22e">g</span>(<span style="color:#a6e22e">BX</span>) <span style="color:#75715e">// m0.tls[0] = &amp;g0
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">LEAQ</span>	<span style="color:#a6e22e">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">m0</span>(<span style="color:#a6e22e">SB</span>), <span style="color:#a6e22e">AX</span> <span style="color:#75715e">// 将m0地址放入AX
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">// 将m0和g0建立映射关系
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// save m-&gt;g0 = g0
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#a6e22e">CX</span>, <span style="color:#a6e22e">m_g0</span>(<span style="color:#a6e22e">AX</span>) <span style="color:#75715e">// m0.g0 = g0
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// save m0 to g0-&gt;m
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#a6e22e">AX</span>, <span style="color:#a6e22e">g_m</span>(<span style="color:#a6e22e">CX</span>) <span style="color:#75715e">// g0.m = m0
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">CLD</span>				<span style="color:#75715e">// convention is D is always left cleared
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">CALL</span>	<span style="color:#a6e22e">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">check</span>(<span style="color:#a6e22e">SB</span>)
</code></pre></div><p>创建完m0之后的内存分布</p>
<p><img src="/images/stack_1.png" alt="stack_1"></p>
<ul>
<li>m0和g0的关系</li>
</ul>
<ol>
<li>m0表示主线程，g0表示主线程的第一个goroutine</li>
<li>g0主要是记录主线程的栈信息，执行调度函数(schedule后边会讲)时会用，而用户goroutine有自己的栈，执行的时候会从g0栈切换到用户goroutine栈</li>
</ol>
<ul>
<li>初始化调度</li>
</ul>
<p>g0和m0都创建并初始化好了，下面就该进行调度初始化了</p>
<ol>
<li>将参数放入AX(初始化g0时将参数放入SP+16和SP+24的位置</li>
<li>runtime.args初始化参数的</li>
<li>runtime.osinit是初始化CPU核数的</li>
<li>重点看runtime.schedinit</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">	<span style="color:#75715e">// 初始化m0
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// 将argc和argv入栈
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">MOVL</span>	<span style="color:#ae81ff">16</span>(<span style="color:#a6e22e">SP</span>), <span style="color:#a6e22e">AX</span>		<span style="color:#75715e">// copy argc
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">MOVL</span>	<span style="color:#a6e22e">AX</span>, <span style="color:#ae81ff">0</span>(<span style="color:#a6e22e">SP</span>)
	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#ae81ff">24</span>(<span style="color:#a6e22e">SP</span>), <span style="color:#a6e22e">AX</span>		<span style="color:#75715e">// copy argv
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#a6e22e">AX</span>, <span style="color:#ae81ff">8</span>(<span style="color:#a6e22e">SP</span>)
	<span style="color:#75715e">// 处理参数
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">CALL</span>	<span style="color:#a6e22e">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">args</span>(<span style="color:#a6e22e">SB</span>)
	<span style="color:#75715e">// 获取cpu的核数
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">CALL</span>	<span style="color:#a6e22e">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">osinit</span>(<span style="color:#a6e22e">SB</span>)
	<span style="color:#75715e">// 调度系统初始化
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">CALL</span>	<span style="color:#a6e22e">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">schedinit</span>(<span style="color:#a6e22e">SB</span>)
</code></pre></div><ul>
<li>runtime.schedinit
下面函数省略了调度无关的代码，大概流程:</li>
</ul>
<ol>
<li>设置最大线程数</li>
<li>根据GOMAXPROCS设置procs(P的数量)</li>
<li>调用procresizeprocs调整P的数量</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">schedinit</span>() {
	<span style="color:#75715e">// 取出g0
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">_g_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getg</span>()
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">raceenabled</span> {
		<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">racectx</span>, <span style="color:#a6e22e">raceprocctx0</span> = <span style="color:#a6e22e">raceinit</span>()
	}	

	<span style="color:#75715e">// 设置最大线程数
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">maxmcount</span> = <span style="color:#ae81ff">10000</span>
	
	<span style="color:#f92672">...</span>	

	<span style="color:#75715e">// 初始化m0, 前边已经将m0和g0的关系绑定好了
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// 只是检查一下各种变量，然后将m0挂到allm链表中
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">mcommoninit</span>(<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>)

	<span style="color:#f92672">...</span>

	<span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">lastpoll</span> = uint64(<span style="color:#a6e22e">nanotime</span>())
	<span style="color:#75715e">// ncpu在osinit时已经获取
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">procs</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ncpu</span>
	<span style="color:#75715e">// 如果GOMAXPROCS设置并且合法就将procs的设置为GOMAXPROCS
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">atoi32</span>(<span style="color:#a6e22e">gogetenv</span>(<span style="color:#e6db74">&#34;GOMAXPROCS&#34;</span>)); <span style="color:#a6e22e">ok</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">n</span> &gt; <span style="color:#ae81ff">0</span> {
		<span style="color:#a6e22e">procs</span> = <span style="color:#a6e22e">n</span>
	}

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">procresize</span>(<span style="color:#a6e22e">procs</span>) <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;unknown runnable goroutine during bootstrap&#34;</span>)
	}

	<span style="color:#f92672">...</span>	
}
</code></pre></div><ul>
<li>
<p>runtime.procresize</p>
</li>
<li>
<p>调度初始化最后一步</p>
</li>
</ul>
<ol>
<li>更新最后一次修改P数量动作的时间戳并累加花费时间</li>
<li>根据nprocs调整P的数量(加锁)
<ol>
<li>nprocs &gt; 现有P数量，就扩展allp(p的全局数组)的长度为nprocs</li>
<li>nprocs &lt; 现有P数量，就缩容allp的长度为nprocs</li>
</ol>
</li>
<li>如果上一步是扩容了，就从堆中创建新P，并把P放入扩容出来的位置</li>
<li>通过g0找到m0，然后将allp[0]和m0绑定</li>
<li>如果allp缩容了，就将多余的p销毁</li>
<li>将空闲的p加入空闲链表
到目前为止，创建了m0，g0，和nprocs个P，但是还是没有让调度真正的跑起来</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">procresize</span>(<span style="color:#a6e22e">nprocs</span> <span style="color:#66d9ef">int32</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">p</span> {
	<span style="color:#a6e22e">old</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gomaxprocs</span>
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">old</span> &lt; <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">nprocs</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span> {
		<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;procresize: invalid arg&#34;</span>)
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">trace</span>.<span style="color:#a6e22e">enabled</span> {
		<span style="color:#a6e22e">traceGomaxprocs</span>(<span style="color:#a6e22e">nprocs</span>)
	}

	<span style="color:#75715e">// update statistics
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">now</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">nanotime</span>()
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">procresizetime</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
		<span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">totaltime</span> <span style="color:#f92672">+=</span> int64(<span style="color:#a6e22e">old</span>) <span style="color:#f92672">*</span> (<span style="color:#a6e22e">now</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">procresizetime</span>)
	}
	<span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">procresizetime</span> = <span style="color:#a6e22e">now</span>

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">nprocs</span> &gt; int32(len(<span style="color:#a6e22e">allp</span>)) { <span style="color:#75715e">// 初始化的len(allp) == 0
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">lock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">allpLock</span>)
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">nprocs</span> <span style="color:#f92672">&lt;=</span> int32(cap(<span style="color:#a6e22e">allp</span>)) { <span style="color:#75715e">// 需要缩容
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">allp</span> = <span style="color:#a6e22e">allp</span>[:<span style="color:#a6e22e">nprocs</span>]
		} <span style="color:#66d9ef">else</span> { <span style="color:#75715e">// 扩容
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">nallp</span> <span style="color:#f92672">:=</span> make([]<span style="color:#f92672">*</span><span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">nprocs</span>)
			<span style="color:#75715e">// Copy everything up to allp&#39;s cap so we
</span><span style="color:#75715e"></span>			<span style="color:#75715e">// never lose old allocated Ps.
</span><span style="color:#75715e"></span>			copy(<span style="color:#a6e22e">nallp</span>, <span style="color:#a6e22e">allp</span>[:cap(<span style="color:#a6e22e">allp</span>)])
			<span style="color:#a6e22e">allp</span> = <span style="color:#a6e22e">nallp</span>
		}
		<span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">allpLock</span>)
	}

	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">old</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">nprocs</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">pp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">allp</span>[<span style="color:#a6e22e">i</span>]
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">pp</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
			<span style="color:#a6e22e">pp</span> = new(<span style="color:#a6e22e">p</span>)
		}
		<span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">init</span>(<span style="color:#a6e22e">i</span>)
		<span style="color:#a6e22e">atomicstorep</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">allp</span>[<span style="color:#a6e22e">i</span>]), <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">pp</span>))
	}

	<span style="color:#a6e22e">_g_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getg</span>() <span style="color:#75715e">// 获取g0
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>().<span style="color:#a6e22e">id</span> &lt; <span style="color:#a6e22e">nprocs</span> { <span style="color:#75715e">// 进程初始化时g0.m与p没有绑定，所以g0.m.p == 0
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>().<span style="color:#a6e22e">status</span> = <span style="color:#a6e22e">_Prunning</span>
		<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>().<span style="color:#a6e22e">mcache</span>.<span style="color:#a6e22e">prepareForSweep</span>()
	} <span style="color:#66d9ef">else</span> {
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">trace</span>.<span style="color:#a6e22e">enabled</span> {
				<span style="color:#a6e22e">traceGoSched</span>()
				<span style="color:#a6e22e">traceProcStop</span>(<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>())
			}
			<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>().<span style="color:#a6e22e">m</span> = <span style="color:#ae81ff">0</span>
		}
		<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span> = <span style="color:#ae81ff">0</span>
		<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">mcache</span> = <span style="color:#66d9ef">nil</span>
		<span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">allp</span>[<span style="color:#ae81ff">0</span>]
		<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">m</span> = <span style="color:#ae81ff">0</span>
		<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">status</span> = <span style="color:#a6e22e">_Pidle</span>
		<span style="color:#a6e22e">acquirep</span>(<span style="color:#a6e22e">p</span>) <span style="color:#75715e">// 把allp[0]和m0关联起来
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">trace</span>.<span style="color:#a6e22e">enabled</span> {
			<span style="color:#a6e22e">traceGoStart</span>()
		}
	}

	<span style="color:#75715e">// 如果有需要销毁的p，就是销毁
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">nprocs</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">old</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">allp</span>[<span style="color:#a6e22e">i</span>]
		<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">destroy</span>()
		<span style="color:#75715e">// can&#39;t free P itself because it can be referenced by an M in syscall
</span><span style="color:#75715e"></span>	}

	<span style="color:#66d9ef">if</span> int32(len(<span style="color:#a6e22e">allp</span>)) <span style="color:#f92672">!=</span> <span style="color:#a6e22e">nprocs</span> {
		<span style="color:#a6e22e">lock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">allpLock</span>)
		<span style="color:#a6e22e">allp</span> = <span style="color:#a6e22e">allp</span>[:<span style="color:#a6e22e">nprocs</span>]
		<span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">allpLock</span>)
	}

	<span style="color:#75715e">// 将空闲p放入空闲链表
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">runnablePs</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">p</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">nprocs</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">--</span> {
		<span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">allp</span>[<span style="color:#a6e22e">i</span>]
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>() <span style="color:#f92672">==</span> <span style="color:#a6e22e">p</span> { <span style="color:#75715e">// allp[0]已经和m0关联了，所以不用放入空闲链表
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">continue</span>
		}
		<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">status</span> = <span style="color:#a6e22e">_Pidle</span>
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">runqempty</span>(<span style="color:#a6e22e">p</span>) {
			<span style="color:#a6e22e">pidleput</span>(<span style="color:#a6e22e">p</span>)
		} <span style="color:#66d9ef">else</span> {
			<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">mget</span>())
			<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">link</span>.<span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">runnablePs</span>)
			<span style="color:#a6e22e">runnablePs</span> = <span style="color:#a6e22e">p</span>
		}
	}
	<span style="color:#a6e22e">stealOrder</span>.<span style="color:#a6e22e">reset</span>(uint32(<span style="color:#a6e22e">nprocs</span>))
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">int32p</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">int32</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">gomaxprocs</span> <span style="color:#75715e">// make compiler check that gomaxprocs is an int32
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Store</span>((<span style="color:#f92672">*</span><span style="color:#66d9ef">uint32</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">int32p</span>)), uint32(<span style="color:#a6e22e">nprocs</span>))
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">runnablePs</span>
}
</code></pre></div><p>2.4 创建&quot;第一个&quot;goroutine</p>
<p>我们返回runtime·rt0_go接着看</p>
<ol>
<li>将runtime.main地址放入AX</li>
<li>参数AX, 0入栈(函数参数入栈由右向左)</li>
<li>然后调用runtime.newproc创建goroutine</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">	<span style="color:#75715e">// create a new goroutine to start program
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// 创建第一个goroutine执行runtime.main，源码里没搜到runtime.mainPC，在schedinit函数前注释里找到的runtime.mainPC就是runtime.main
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#960050;background-color:#1e0010">$</span><span style="color:#a6e22e">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">mainPC</span>(<span style="color:#a6e22e">SB</span>), <span style="color:#a6e22e">AX</span>		<span style="color:#75715e">// entry AX = func(runtime.main)
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">PUSHQ</span>	<span style="color:#a6e22e">AX</span>
	<span style="color:#a6e22e">PUSHQ</span>	<span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">0</span>			<span style="color:#75715e">// arg size runtime.main没有参数所以入栈0
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">CALL</span>	<span style="color:#a6e22e">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">newproc</span>(<span style="color:#a6e22e">SB</span>)     <span style="color:#75715e">// 创建goroutine执行runtime.main(还没执行，只是将goroutine加入待运行队列)
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">POPQ</span>	<span style="color:#a6e22e">AX</span>                      <span style="color:#75715e">// 出栈
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">POPQ</span>	<span style="color:#a6e22e">AX</span>                      <span style="color:#75715e">// 出栈
</span></code></pre></div><ul>
<li>newproc</li>
</ul>
<ol>
<li>首先获取参数地址</li>
<li>获取当前所在goroutine(初始化时runtime代码都在g0执行)</li>
<li>获取要执行指令地址</li>
<li>在gp的栈上执行runtime.newproc1(在g0栈上执行)</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">newproc</span>(<span style="color:#a6e22e">siz</span> <span style="color:#66d9ef">int32</span>, <span style="color:#a6e22e">fn</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">funcval</span>) {
	<span style="color:#75715e">// 获取函数fn的第一个参数的位置
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">argp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">fn</span>), <span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">PtrSize</span>)
	<span style="color:#75715e">// 获取当前所有goroutine ---- g0
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">gp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getg</span>()
	<span style="color:#75715e">// 获取要执行指令的位置
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">pc</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getcallerpc</span>()
	<span style="color:#75715e">/*
</span><span style="color:#75715e">	systemstack是将函数切换到g0的栈上运行，初始化时本来就在g0的栈上，所以直接调用函数返回
</span><span style="color:#75715e">	*/</span>
	<span style="color:#a6e22e">systemstack</span>(<span style="color:#66d9ef">func</span>() {
		<span style="color:#a6e22e">newproc1</span>(<span style="color:#a6e22e">fn</span>, (<span style="color:#f92672">*</span><span style="color:#66d9ef">uint8</span>)(<span style="color:#a6e22e">argp</span>), <span style="color:#a6e22e">siz</span>, <span style="color:#a6e22e">gp</span>, <span style="color:#a6e22e">pc</span>)
	})
}
</code></pre></div><ul>
<li>newproc1函数主要的工作
这个函数有点长分段来看</li>
</ul>
<ol>
<li>首先获得当前所在goroutine(g0)</li>
<li>禁止抢占</li>
<li>计算参数位置</li>
<li>计算下参数是否过大</li>
<li>获取当前goroutine所在m的p，前边讲过g0对应的m是m0，m0对应的p是allp[0]</li>
<li>创建一个goroutine(先从p的缓存里找，找不到就new一个)，并且确认goroutine栈边界是初始化好的(方式p缓存里的goroutine参数没初始化)</li>
<li>计算栈顶的地址，如果有参数就将参数放到新创建的这个goroutine上</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">newproc1</span>(<span style="color:#a6e22e">fn</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">funcval</span>, <span style="color:#a6e22e">argp</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">uint8</span>, <span style="color:#a6e22e">narg</span> <span style="color:#66d9ef">int32</span>, <span style="color:#a6e22e">callergp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">g</span>, <span style="color:#a6e22e">callerpc</span> <span style="color:#66d9ef">uintptr</span>) {
	<span style="color:#75715e">// 获取当前所在goroutine，初始化的是g0
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">_g_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getg</span>()

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">fn</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">throwing</span> = <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#75715e">// do not dump full stacks
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;go of nil func value&#34;</span>)
	}
	<span style="color:#75715e">// 禁止抢占，把p固定在本地变量
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">acquirem</span>() <span style="color:#75715e">// disable preemption because it can be holding p in a local var
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">siz</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">narg</span>
	<span style="color:#a6e22e">siz</span> = (<span style="color:#a6e22e">siz</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">7</span>) <span style="color:#f92672">&amp;^</span> <span style="color:#ae81ff">7</span>

	<span style="color:#75715e">// 检查一下参数是否需要空间是否过大，参数大小 和 栈大小 - (额外栈底空间(猜的)) - 返回需要的栈大小
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">siz</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">_StackMin</span><span style="color:#f92672">-</span><span style="color:#ae81ff">4</span><span style="color:#f92672">*</span><span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">RegSize</span><span style="color:#f92672">-</span><span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">RegSize</span> {
		<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;newproc: function arguments too large for new goroutine&#34;</span>)
	}

	<span style="color:#75715e">// _p_ = allp[0]
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">_p_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>()
	<span style="color:#75715e">// 从_p_的缓存中取一个g，初始化的时候没有可用的g所以newg==nil
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">newg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gfget</span>(<span style="color:#a6e22e">_p_</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">newg</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#75715e">// 创建一个新g，栈空间2k, 并且给stack,stackguard0,stackguard1初始化
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">newg</span> = <span style="color:#a6e22e">malg</span>(<span style="color:#a6e22e">_StackMin</span>)
		<span style="color:#75715e">// 将g的状态设置为_Gdead
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">casgstatus</span>(<span style="color:#a6e22e">newg</span>, <span style="color:#a6e22e">_Gidle</span>, <span style="color:#a6e22e">_Gdead</span>)
		<span style="color:#75715e">// 将g加入allg链表
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">allgadd</span>(<span style="color:#a6e22e">newg</span>) <span style="color:#75715e">// publishes with a g-&gt;status of Gdead so GC scanner doesn&#39;t look at uninitialized stack.
</span><span style="color:#75715e"></span>	}
	<span style="color:#75715e">// 确认刚才的初始化是否有效
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">stack</span>.<span style="color:#a6e22e">hi</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
		<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;newproc1: newg missing stack&#34;</span>)
	}

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">readgstatus</span>(<span style="color:#a6e22e">newg</span>) <span style="color:#f92672">!=</span> <span style="color:#a6e22e">_Gdead</span> {
		<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;newproc1: new g is not Gdead&#34;</span>)
	}

	<span style="color:#75715e">// 省略一段调整sp指针的函数，并且如果有参数就将参数放入new goroutine的栈中
</span><span style="color:#75715e"></span>	<span style="color:#f92672">...</span>
</code></pre></div><p>设置各个寄存器的值(在cpu上恢复上下文时使用)
1) 清理sched
2) 设置栈顶置针位置
3) 设置pc寄存器值(goexit函数第二条指令，常理应该是goroutine本身函数的第一条指令，这个妙用后边说)
4) 设置goroutine地址
5) 调用gostartcallfn，参数是sched和goroutine的参数</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">	<span style="color:#75715e">// 清理sched(各参数清零)
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">memclrNoHeapPointers</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">sched</span>), <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Sizeof</span>(<span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">sched</span>))
	<span style="color:#75715e">// 设置sched, 在CPU上运行的相关参数
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">sp</span> = <span style="color:#a6e22e">sp</span>
	<span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">stktopsp</span> = <span style="color:#a6e22e">sp</span>
	<span style="color:#75715e">// 设置pc，被调度时第一条指令的位置，将pc设置为goexit函数一个偏移量的位置(goexit函数第二条指令)
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// 这里把pc设置为goexit函数的第二条指令的作用就是，伪装成goexit函数调用的fn函数，当fn执行完跳回goexit函数继续做退出需要的操作
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">pc</span> = <span style="color:#a6e22e">funcPC</span>(<span style="color:#a6e22e">goexit</span>) <span style="color:#f92672">+</span> <span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">PCQuantum</span> <span style="color:#75715e">// +PCQuantum so that previous instruction is in same function
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">g</span> = <span style="color:#a6e22e">guintptr</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">newg</span>))
	<span style="color:#a6e22e">gostartcallfn</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">sched</span>, <span style="color:#a6e22e">fn</span>)
</code></pre></div><p>判断一下goroutine的函数是否为空，然后调用gostartcall</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">gostartcallfn</span>(<span style="color:#a6e22e">gobuf</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">gobuf</span>, <span style="color:#a6e22e">fv</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">funcval</span>) {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">fn</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">fv</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">fn</span> = <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">fv</span>.<span style="color:#a6e22e">fn</span>)
	} <span style="color:#66d9ef">else</span> {
		<span style="color:#a6e22e">fn</span> = <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">funcPC</span>(<span style="color:#a6e22e">nilfunc</span>))
	}
	<span style="color:#a6e22e">gostartcall</span>(<span style="color:#a6e22e">gobuf</span>, <span style="color:#a6e22e">fn</span>, <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">fv</span>))
}
</code></pre></div><ol>
<li>获取sp，现在新goroutine的栈上之后本身的函数，sp指向函数的第一个参数</li>
<li>将sp指向pc里面的指令地址，也就是goexit的第二条指令，然后重新设置新goroutinesp地址</li>
<li>这时候pc才指向goroutine自己的函数</li>
</ol>
<p>gostartcall的主要作用就是将goexit入栈，然后设置goroutine的pc指向自身函数，伪装成是goexit调用的自身函数，当自身函数执行完时返回goexit清理线程，大概就是下面这样</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">goexit</span>() {
	<span style="color:#a6e22e">goroutine自身函数</span>()
	<span style="color:#a6e22e">清理现场</span>()	
}

</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">gostartcall</span>(<span style="color:#a6e22e">buf</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">gobuf</span>, <span style="color:#a6e22e">fn</span>, <span style="color:#a6e22e">ctxt</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>) {
	<span style="color:#a6e22e">sp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">buf</span>.<span style="color:#a6e22e">sp</span>
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">RegSize</span> &gt; <span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">PtrSize</span> {
		<span style="color:#a6e22e">sp</span> <span style="color:#f92672">-=</span> <span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">PtrSize</span>
		<span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#66d9ef">uintptr</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">sp</span>)) = <span style="color:#ae81ff">0</span>
	}
	<span style="color:#75715e">// 预留返回值空间
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">sp</span> <span style="color:#f92672">-=</span> <span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">PtrSize</span>
	<span style="color:#75715e">// sp指向pc指令的位置，前边已经将goexit第二条指令的地址放入pc
</span><span style="color:#75715e"></span>	<span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#66d9ef">uintptr</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">sp</span>)) = <span style="color:#a6e22e">buf</span>.<span style="color:#a6e22e">pc</span> 
	<span style="color:#75715e">// 然后设置sp
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">buf</span>.<span style="color:#a6e22e">sp</span> = <span style="color:#a6e22e">sp</span>
	<span style="color:#75715e">// 这时候的pc才是goroutine的函数
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">buf</span>.<span style="color:#a6e22e">pc</span> = uintptr(<span style="color:#a6e22e">fn</span>)
	<span style="color:#a6e22e">buf</span>.<span style="color:#a6e22e">ctxt</span> = <span style="color:#a6e22e">ctxt</span>
}
</code></pre></div><p>然后再回到newproc函数，剩下的就是设置goroutine的状态，然后把goroutine放入p的待执行队列中</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">	<span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">gopc</span> = <span style="color:#a6e22e">callerpc</span> <span style="color:#75715e">// 用于traceback
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">ancestors</span> = <span style="color:#a6e22e">saveAncestors</span>(<span style="color:#a6e22e">callergp</span>)
	<span style="color:#75715e">// newg的函数从哪里开始执行依赖于sched.pc 不依赖于startpc
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">startpc</span> = <span style="color:#a6e22e">fn</span>.<span style="color:#a6e22e">fn</span>
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">curg</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">labels</span> = <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">curg</span>.<span style="color:#a6e22e">labels</span>
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">isSystemGoroutine</span>(<span style="color:#a6e22e">newg</span>, <span style="color:#66d9ef">false</span>) {
		<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Xadd</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">ngsys</span>, <span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
	}
	<span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">gcscanvalid</span> = <span style="color:#66d9ef">false</span>
	<span style="color:#75715e">// 设置newg状态为_Grunnable, 到这里newg就可以运行了
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">casgstatus</span>(<span style="color:#a6e22e">newg</span>, <span style="color:#a6e22e">_Gdead</span>, <span style="color:#a6e22e">_Grunnable</span>)

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_p_</span>.<span style="color:#a6e22e">goidcache</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">_p_</span>.<span style="color:#a6e22e">goidcacheend</span> {
		<span style="color:#a6e22e">_p_</span>.<span style="color:#a6e22e">goidcache</span> = <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Xadd64</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">goidgen</span>, <span style="color:#a6e22e">_GoidCacheBatch</span>)
		<span style="color:#a6e22e">_p_</span>.<span style="color:#a6e22e">goidcache</span> <span style="color:#f92672">-=</span> <span style="color:#a6e22e">_GoidCacheBatch</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
		<span style="color:#a6e22e">_p_</span>.<span style="color:#a6e22e">goidcacheend</span> = <span style="color:#a6e22e">_p_</span>.<span style="color:#a6e22e">goidcache</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">_GoidCacheBatch</span>
	}
	<span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">goid</span> = int64(<span style="color:#a6e22e">_p_</span>.<span style="color:#a6e22e">goidcache</span>)
	<span style="color:#a6e22e">_p_</span>.<span style="color:#a6e22e">goidcache</span><span style="color:#f92672">++</span>
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">raceenabled</span> {
		<span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">racectx</span> = <span style="color:#a6e22e">racegostart</span>(<span style="color:#a6e22e">callerpc</span>)
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">trace</span>.<span style="color:#a6e22e">enabled</span> {
		<span style="color:#a6e22e">traceGoCreate</span>(<span style="color:#a6e22e">newg</span>, <span style="color:#a6e22e">newg</span>.<span style="color:#a6e22e">startpc</span>)
	}
	<span style="color:#75715e">// 将newg加入p的待运行队列
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">runqput</span>(<span style="color:#a6e22e">_p_</span>, <span style="color:#a6e22e">newg</span>, <span style="color:#66d9ef">true</span>)

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Load</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">npidle</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Load</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">nmspinning</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">mainStarted</span> {
		<span style="color:#a6e22e">wakep</span>()
	}
	<span style="color:#75715e">// 取消m的固定
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">releasem</span>(<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>)
}
</code></pre></div><p>总结一下创建第一个goroutine执行runtime.main的过程(只是创建啊，整个调度这时候还是没有跑起来)
<img src="/images/creat_goroutine_main.png" alt="create_goroutine_main"></p>
<h2 id="24-调度循环">2.4 调度循环</h2>
<p>我们再返回runtime·rt0_go继续看，总结一下到目前为止已经准备好的事情</p>
<ol>
<li>将m0与主线程绑定了(将m0结构体设为主线程的私有变量)</li>
<li>创建了g0，并且与m0绑定</li>
<li>创建了procs个p并且初始化，将allp[0]与m0绑定，形成初步的GMP模型(g0,m0,p0)</li>
<li>创建了一个执行runtime.main(不是代码里的main.main，runtime.main会做加载init函数等操作然后调用main.main)的goroutine并且放入了p0的待运行队列</li>
</ol>
<p>接下来就是调度循环了，调用runtime.mstart，这个函数就是调度循环，除非程序退出否则永远阻塞住</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">	<span style="color:#75715e">// start this M
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// 运行runtime.mstart这个函数会阻塞住，运行结束的时候就是程序退出的时候
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">CALL</span>	<span style="color:#a6e22e">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">mstart</span>(<span style="color:#a6e22e">SB</span>)

	<span style="color:#a6e22e">CALL</span>	<span style="color:#a6e22e">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">abort</span>(<span style="color:#a6e22e">SB</span>)	<span style="color:#75715e">// mstart should never return
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">RET</span>

	<span style="color:#75715e">// Prevent dead-code elimination of debugCallV1, which is
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// intended to be called by debuggers.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#960050;background-color:#1e0010">$</span><span style="color:#a6e22e">runtime</span><span style="color:#960050;background-color:#1e0010">·</span><span style="color:#a6e22e">debugCallV1</span>(<span style="color:#a6e22e">SB</span>), <span style="color:#a6e22e">AX</span>
	<span style="color:#a6e22e">RET</span>
</code></pre></div><ul>
<li>runtime.mstart</li>
</ul>
<ol>
<li>获取了当前所在goroutine(初始化时代码都是在g0上执行的)</li>
<li>初始化栈保护</li>
<li>调用mstart1
go/src/runtime/proc.go, line 1146</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">mstart</span>() {
	<span style="color:#a6e22e">_g_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getg</span>() <span style="color:#75715e">// 获取g0
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">osStack</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">stack</span>.<span style="color:#a6e22e">lo</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#75715e">// g0.stack.lo在前边已经初始化过了，所以osStack = false
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">osStack</span> {
		<span style="color:#a6e22e">size</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">stack</span>.<span style="color:#a6e22e">hi</span>
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">size</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
			<span style="color:#a6e22e">size</span> = <span style="color:#ae81ff">8192</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">StackGuardMultiplier</span>
		}
		<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">stack</span>.<span style="color:#a6e22e">hi</span> = uintptr(<span style="color:#a6e22e">noescape</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">size</span>)))
		<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">stack</span>.<span style="color:#a6e22e">lo</span> = <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">stack</span>.<span style="color:#a6e22e">hi</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">size</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1024</span>
	}
	<span style="color:#75715e">// 初始化栈保护
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">stackguard0</span> = <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">stack</span>.<span style="color:#a6e22e">lo</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">_StackGuard</span>
	<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">stackguard1</span> = <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">stackguard0</span>
	<span style="color:#75715e">// 开始m0开始运行
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">mstart1</span>()

	<span style="color:#75715e">// Exit this thread.
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">GOOS</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;windows&#34;</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">GOOS</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;solaris&#34;</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">GOOS</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;illumos&#34;</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">GOOS</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;plan9&#34;</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">GOOS</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;darwin&#34;</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">GOOS</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;aix&#34;</span> {
		<span style="color:#a6e22e">osStack</span> = <span style="color:#66d9ef">true</span>
	}
	<span style="color:#a6e22e">mexit</span>(<span style="color:#a6e22e">osStack</span>)
}
</code></pre></div><ul>
<li>runtime.mstart1</li>
</ul>
<ol>
<li>保存g0的指令指针和栈指针，保存这两个值是理解调度循环的关键，mstart1执行完之后，g0继续执行指令，不会再返回来了，保存了指令和栈指针之后，g0要继续执行指令的时候，就会又从上面开始执行</li>
<li>做一些初始化工作</li>
<li>调用schedule开始调度</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">mstart1</span>() {
	<span style="color:#75715e">// 获取当前goroutine g0
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">_g_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getg</span>()

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_g_</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">g0</span> {
		<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;bad runtime·mstart&#34;</span>)
	}

	<span style="color:#75715e">// save函数保存了g0再次运行时(循环调度下一次回头)调度相关信息
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">save</span>(<span style="color:#a6e22e">getcallerpc</span>(), <span style="color:#a6e22e">getcallersp</span>())
	<span style="color:#75715e">// asminit
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">asminit</span>()
	<span style="color:#75715e">// 信号相关初始化
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">minit</span>()

	<span style="color:#75715e">// 初始化时m == m0，mstartm0也是信号相关的初始化
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span> <span style="color:#f92672">==</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">m0</span> {
		<span style="color:#a6e22e">mstartm0</span>()
	}

	<span style="color:#75715e">// 初始化时fn == ni
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">fn</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">mstartfn</span>; <span style="color:#a6e22e">fn</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">fn</span>()
	}

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span> <span style="color:#f92672">!=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">m0</span> {
		<span style="color:#a6e22e">acquirep</span>(<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">nextp</span>.<span style="color:#a6e22e">ptr</span>())
		<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">nextp</span> = <span style="color:#ae81ff">0</span>
	}
	<span style="color:#75715e">// 开始调度
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">schedule</span>()
}
</code></pre></div><ul>
<li>runtime.schedule</li>
</ul>
<p>调度开始了，m要找gorutine放到cpu上执行了</p>
<ol>
<li>每调度61次(具体为啥是61有待思考)，就从全局的goroutine列表中选goroutine</li>
<li>如果上一步没找到，就从m对应的p的缓存里找</li>
<li>如果上一步还没有找到，就调findrunnable从其他线程窃取goroutine，如果发现有就窃取一半放到自己的p缓存中，如果都没有就说明真的没有待运行的goroutine了，就陷入睡眠一直阻塞在findrunnable函数，等待被唤醒</li>
<li>直到有goroutine需要执行了，就调用execute执行goroutine</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">schedule</span>() {
	<span style="color:#75715e">// 获得g0
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">_g_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getg</span>()

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">locks</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
		<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;schedule: holding locks&#34;</span>)
	}

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">lockedg</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
		<span style="color:#a6e22e">stoplockedm</span>()
		<span style="color:#a6e22e">execute</span>(<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">lockedg</span>.<span style="color:#a6e22e">ptr</span>(), <span style="color:#66d9ef">false</span>) <span style="color:#75715e">// Never returns.
</span><span style="color:#75715e"></span>	}

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">incgo</span> {
		<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;schedule: in cgo&#34;</span>)
	}

<span style="color:#a6e22e">top</span>:
	<span style="color:#75715e">// 等待gc
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">gcwaiting</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
		<span style="color:#a6e22e">gcstopm</span>()
		<span style="color:#66d9ef">goto</span> <span style="color:#a6e22e">top</span>
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>().<span style="color:#a6e22e">runSafePointFn</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
		<span style="color:#a6e22e">runSafePointFn</span>()
	}

	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">gp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">g</span>
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">inheritTime</span> <span style="color:#66d9ef">bool</span>

	<span style="color:#a6e22e">tryWakeP</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">false</span>
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">trace</span>.<span style="color:#a6e22e">enabled</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">trace</span>.<span style="color:#a6e22e">shutdown</span> {
		<span style="color:#a6e22e">gp</span> = <span style="color:#a6e22e">traceReader</span>()
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">gp</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			<span style="color:#a6e22e">casgstatus</span>(<span style="color:#a6e22e">gp</span>, <span style="color:#a6e22e">_Gwaiting</span>, <span style="color:#a6e22e">_Grunnable</span>)
			<span style="color:#a6e22e">traceGoUnpark</span>(<span style="color:#a6e22e">gp</span>, <span style="color:#ae81ff">0</span>)
			<span style="color:#a6e22e">tryWakeP</span> = <span style="color:#66d9ef">true</span>
		}
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">gp</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">gcBlackenEnabled</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
		<span style="color:#a6e22e">gp</span> = <span style="color:#a6e22e">gcController</span>.<span style="color:#a6e22e">findRunnableGCWorker</span>(<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>())
		<span style="color:#a6e22e">tryWakeP</span> = <span style="color:#a6e22e">tryWakeP</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">gp</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span>
	}
	<span style="color:#75715e">// 先从全局队列中获取，每61次调度都会从全局队列中获取goroutine
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">gp</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>().<span style="color:#a6e22e">schedtick</span><span style="color:#f92672">%</span><span style="color:#ae81ff">61</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">runqsize</span> &gt; <span style="color:#ae81ff">0</span> {
			<span style="color:#a6e22e">lock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">lock</span>)
			<span style="color:#a6e22e">gp</span> = <span style="color:#a6e22e">globrunqget</span>(<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>(), <span style="color:#ae81ff">1</span>)
			<span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">lock</span>)
		}
	}
	<span style="color:#75715e">// 如果还空就从本地队列中获取
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">gp</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">gp</span>, <span style="color:#a6e22e">inheritTime</span> = <span style="color:#a6e22e">runqget</span>(<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>())
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">gp</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">spinning</span> {
			<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;schedule: spinning with local work&#34;</span>)
		}
	}
	<span style="color:#75715e">// 如果本地也没有就调用findrunnable从其他线程偷一个过来，直到偷过来在运行
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">gp</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">gp</span>, <span style="color:#a6e22e">inheritTime</span> = <span style="color:#a6e22e">findrunnable</span>() <span style="color:#75715e">// blocks until work is available
</span><span style="color:#75715e"></span>	}

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">spinning</span> {
		<span style="color:#a6e22e">resetspinning</span>()
	}

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">disable</span>.<span style="color:#a6e22e">user</span> <span style="color:#f92672">&amp;&amp;</span> !<span style="color:#a6e22e">schedEnabled</span>(<span style="color:#a6e22e">gp</span>) {
		<span style="color:#a6e22e">lock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">lock</span>)
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">schedEnabled</span>(<span style="color:#a6e22e">gp</span>) {
			<span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">lock</span>)
		} <span style="color:#66d9ef">else</span> {
			<span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">disable</span>.<span style="color:#a6e22e">runnable</span>.<span style="color:#a6e22e">pushBack</span>(<span style="color:#a6e22e">gp</span>)
			<span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">disable</span>.<span style="color:#a6e22e">n</span><span style="color:#f92672">++</span>
			<span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">lock</span>)
			<span style="color:#66d9ef">goto</span> <span style="color:#a6e22e">top</span>
		}
	}

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">tryWakeP</span> {
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Load</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">npidle</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Load</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">nmspinning</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
			<span style="color:#a6e22e">wakep</span>()
		}
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">lockedm</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
		<span style="color:#a6e22e">startlockedm</span>(<span style="color:#a6e22e">gp</span>)
		<span style="color:#66d9ef">goto</span> <span style="color:#a6e22e">top</span>
	}
	
	<span style="color:#75715e">// 执行这个goroutine
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">execute</span>(<span style="color:#a6e22e">gp</span>, <span style="color:#a6e22e">inheritTime</span>)
}
</code></pre></div><h2 id="25-触发调度">2.5 触发调度</h2>
<p>触发调度地方大致有:</p>
<ol>
<li>主动挂起</li>
<li>系统调用</li>
<li>协作式调度</li>
<li>正常退出</li>
</ol>
<ul>
<li>
<p>proc.go:1208 runtime.mstart1(调度开始)</p>
</li>
<li>
<p>主动挂起</p>
</li>
<li>
<p>proc.go:2610 runtime.park_m
在上一章内容里讲过<a href="https://www.cnblogs.com/wuwangchuxin0924/p/13022386.html">golang channel源码阅读</a>，当goroutine接收一个channel为空且为阻塞的时候，goroutine会调用goparkunlock使goroutine陷入睡眠，等待send端调用goready函数唤醒函数，主动挂起就是这种情况，当goroutine由于某些条件在等待时，就会主动挂起，不放回待运行队列，等待被唤醒</p>
</li>
</ul>
<p>各种阻塞条件 -&gt; runtime.gopark() -&gt; runtime.park_m() -&gt; runtime.schedule</p>
<ol>
<li>获取当前所在m，并且固定m</li>
<li>获取当前程序所在goroutine</li>
<li>设置锁状态以及阻塞原因</li>
<li>调用runtime.park_m挂起goroutine</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">gopark</span>(<span style="color:#a6e22e">unlockf</span> <span style="color:#66d9ef">func</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">g</span>, <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>) <span style="color:#66d9ef">bool</span>, <span style="color:#a6e22e">lock</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>, <span style="color:#a6e22e">reason</span> <span style="color:#a6e22e">waitReason</span>, <span style="color:#a6e22e">traceEv</span> <span style="color:#66d9ef">byte</span>, <span style="color:#a6e22e">traceskip</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">reason</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">waitReasonSleep</span> {
		<span style="color:#a6e22e">checkTimeouts</span>() <span style="color:#75715e">// timeouts may expire while two goroutines keep the scheduler busy
</span><span style="color:#75715e"></span>	}
	<span style="color:#a6e22e">mp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">acquirem</span>()
	<span style="color:#a6e22e">gp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">mp</span>.<span style="color:#a6e22e">curg</span>
	<span style="color:#a6e22e">status</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">readgstatus</span>(<span style="color:#a6e22e">gp</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">status</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">_Grunning</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">status</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">_Gscanrunning</span> {
		<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;gopark: bad g status&#34;</span>)
	}
	<span style="color:#a6e22e">mp</span>.<span style="color:#a6e22e">waitlock</span> = <span style="color:#a6e22e">lock</span>
	<span style="color:#a6e22e">mp</span>.<span style="color:#a6e22e">waitunlockf</span> = <span style="color:#a6e22e">unlockf</span>
	<span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">waitreason</span> = <span style="color:#a6e22e">reason</span>
	<span style="color:#a6e22e">mp</span>.<span style="color:#a6e22e">waittraceev</span> = <span style="color:#a6e22e">traceEv</span>
	<span style="color:#a6e22e">mp</span>.<span style="color:#a6e22e">waittraceskip</span> = <span style="color:#a6e22e">traceskip</span>
	<span style="color:#a6e22e">releasem</span>(<span style="color:#a6e22e">mp</span>)
	<span style="color:#75715e">// can&#39;t do anything that might move the G between Ms here.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">mcall</span>(<span style="color:#a6e22e">park_m</span>)
}
</code></pre></div><ol>
<li>获取当前goroutine</li>
<li>将goroutine状态设置为Gwaiting</li>
<li>重新调度</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">park_m</span>(<span style="color:#a6e22e">gp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">g</span>) {
	<span style="color:#a6e22e">_g_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getg</span>()

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">trace</span>.<span style="color:#a6e22e">enabled</span> {
		<span style="color:#a6e22e">traceGoPark</span>(<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">waittraceev</span>, <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">waittraceskip</span>)
	}

	<span style="color:#a6e22e">casgstatus</span>(<span style="color:#a6e22e">gp</span>, <span style="color:#a6e22e">_Grunning</span>, <span style="color:#a6e22e">_Gwaiting</span>)
	<span style="color:#a6e22e">dropg</span>()

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">fn</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">waitunlockf</span>; <span style="color:#a6e22e">fn</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">fn</span>(<span style="color:#a6e22e">gp</span>, <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">waitlock</span>)
		<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">waitunlockf</span> = <span style="color:#66d9ef">nil</span>
		<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">waitlock</span> = <span style="color:#66d9ef">nil</span>
		<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ok</span> {
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">trace</span>.<span style="color:#a6e22e">enabled</span> {
				<span style="color:#a6e22e">traceGoUnpark</span>(<span style="color:#a6e22e">gp</span>, <span style="color:#ae81ff">2</span>)
			}
			<span style="color:#a6e22e">casgstatus</span>(<span style="color:#a6e22e">gp</span>, <span style="color:#a6e22e">_Gwaiting</span>, <span style="color:#a6e22e">_Grunnable</span>)
			<span style="color:#a6e22e">execute</span>(<span style="color:#a6e22e">gp</span>, <span style="color:#66d9ef">true</span>) <span style="color:#75715e">// Schedule it back, never returns.
</span><span style="color:#75715e"></span>		}
	}
	<span style="color:#a6e22e">schedule</span>()
}
</code></pre></div><ul>
<li>
<p>协作式调度</p>
</li>
<li>
<p>proc.go:2625 runtime.goschedImpl(协作式调度)</p>
</li>
</ul>
<ol>
<li>主动让出cpu，这个情况不会挂起goroutine，而是放回队列，等待下次调度，这个函数(GoSched)被暴露出去，可以调用，例如，线上有这种情况，写log是异步的，但由于机器磁盘老旧性能不佳，所以当log goroutine运行时还是会过多的占用cpu，这时候可以调用GoSched适当降低当前goroutine优先级</li>
</ol>
<p>runtime.Gosched -&gt; runtime.gosched_m -&gt; runtime.goschedImpl runtime.schedule</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// Gosched continuation on g0.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">gosched_m</span>(<span style="color:#a6e22e">gp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">g</span>) {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">trace</span>.<span style="color:#a6e22e">enabled</span> {
		<span style="color:#a6e22e">traceGoSched</span>()
	}
	<span style="color:#a6e22e">goschedImpl</span>(<span style="color:#a6e22e">gp</span>)
}
</code></pre></div><ol start="2">
<li>调度保护，当调度器发现goroutine处于禁止的状态时就会主动调度让出cpu</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// goschedguarded is a forbidden-states-avoided version of gosched_m
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">goschedguarded_m</span>(<span style="color:#a6e22e">gp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">g</span>) {

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">locks</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">mallocing</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">preemptoff</span> <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>().<span style="color:#a6e22e">status</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">_Prunning</span> {
		<span style="color:#a6e22e">gogo</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">gp</span>.<span style="color:#a6e22e">sched</span>) <span style="color:#75715e">// never return
</span><span style="color:#75715e"></span>	}

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">trace</span>.<span style="color:#a6e22e">enabled</span> {
		<span style="color:#a6e22e">traceGoSched</span>()
	}
	<span style="color:#a6e22e">goschedImpl</span>(<span style="color:#a6e22e">gp</span>)
}
</code></pre></div><ol start="3">
<li>发生抢占，例如当一个goroutine运行时间过长但不像等待channel那样阻塞，一直有事情做时，其他goroutine可能会抢占cpu</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">gopreempt_m</span>(<span style="color:#a6e22e">gp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">g</span>) {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">trace</span>.<span style="color:#a6e22e">enabled</span> {
		<span style="color:#a6e22e">traceGoPreempt</span>()
	}
	<span style="color:#a6e22e">goschedImpl</span>(<span style="color:#a6e22e">gp</span>)
}

</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">goschedImpl</span>(<span style="color:#a6e22e">gp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">g</span>) {
	<span style="color:#a6e22e">status</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">readgstatus</span>(<span style="color:#a6e22e">gp</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">status</span><span style="color:#f92672">&amp;^</span><span style="color:#a6e22e">_Gscan</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">_Grunning</span> {
		<span style="color:#a6e22e">dumpgstatus</span>(<span style="color:#a6e22e">gp</span>)
		<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;bad g status&#34;</span>)
	}
	<span style="color:#a6e22e">casgstatus</span>(<span style="color:#a6e22e">gp</span>, <span style="color:#a6e22e">_Grunning</span>, <span style="color:#a6e22e">_Grunnable</span>)
	<span style="color:#a6e22e">dropg</span>()
	<span style="color:#a6e22e">lock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">lock</span>)
	<span style="color:#a6e22e">globrunqput</span>(<span style="color:#a6e22e">gp</span>)
	<span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">lock</span>)

	<span style="color:#a6e22e">schedule</span>()
}
</code></pre></div><ul>
<li>
<p>非main goroutine结束</p>
</li>
<li>
<p>proc.go:2704,2727 runtime.goexit0(goroutine正常执行完)
非main goroutine结束后会继续调度，这个是正常继续下一次调度不做过多介绍</p>
</li>
<li>
<p>系统调用</p>
</li>
<li>
<p>proc.go:3141 runtime.exitsyscall0(系统调用)</p>
</li>
</ul>
<p>runtime·exitsyscall -&gt; runtime·exitsyscall0 -&gt; runtime.schedule</p>
<p>我们来看下系统调用的过程</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">syscall_syscall</span>(<span style="color:#a6e22e">fn</span>, <span style="color:#a6e22e">a1</span>, <span style="color:#a6e22e">a2</span>, <span style="color:#a6e22e">a3</span> <span style="color:#66d9ef">uintptr</span>) (<span style="color:#a6e22e">r1</span>, <span style="color:#a6e22e">r2</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">uintptr</span>) {
	<span style="color:#a6e22e">entersyscall</span>()
	<span style="color:#a6e22e">libcCall</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">funcPC</span>(<span style="color:#a6e22e">syscall</span>)), <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">fn</span>))
	<span style="color:#a6e22e">exitsyscall</span>()
	<span style="color:#66d9ef">return</span>
}
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">syscall</span>()
</code></pre></div><p>首先会调用runtime.entersyscall获取当前的指令位置和栈指针，然后调用reentersyscall做goroutine进入系统调用之前的准备</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">entersyscall</span>() {
	<span style="color:#a6e22e">reentersyscall</span>(<span style="color:#a6e22e">getcallerpc</span>(), <span style="color:#a6e22e">getcallersp</span>())
}
</code></pre></div><ol>
<li>禁止线程抢占防止出现栈不一致的情况</li>
<li>保证当前函数不会触发栈调整(golang进程的栈初始2k，然后动态调整)</li>
<li>设置goroutine状态为Gsyscall</li>
<li>将goroutine的P暂时和M分离，并且设置P状态为Psyscall</li>
<li>释放锁</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">reentersyscall</span>(<span style="color:#a6e22e">pc</span>, <span style="color:#a6e22e">sp</span> <span style="color:#66d9ef">uintptr</span>) {
	<span style="color:#75715e">// 获得当前goroutine
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">_g_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getg</span>()

	<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">locks</span><span style="color:#f92672">++</span>

	<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">stackguard0</span> = <span style="color:#a6e22e">stackPreempt</span>
	<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">throwsplit</span> = <span style="color:#66d9ef">true</span>

	<span style="color:#75715e">// Leave SP around for GC and traceback.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">save</span>(<span style="color:#a6e22e">pc</span>, <span style="color:#a6e22e">sp</span>)
	<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">syscallsp</span> = <span style="color:#a6e22e">sp</span>
	<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">syscallpc</span> = <span style="color:#a6e22e">pc</span>
	<span style="color:#a6e22e">casgstatus</span>(<span style="color:#a6e22e">_g_</span>, <span style="color:#a6e22e">_Grunning</span>, <span style="color:#a6e22e">_Gsyscall</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">syscallsp</span> &lt; <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">stack</span>.<span style="color:#a6e22e">lo</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">stack</span>.<span style="color:#a6e22e">hi</span> &lt; <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">syscallsp</span> {
		<span style="color:#a6e22e">systemstack</span>(<span style="color:#66d9ef">func</span>() {
			print(<span style="color:#e6db74">&#34;entersyscall inconsistent &#34;</span>, <span style="color:#a6e22e">hex</span>(<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">syscallsp</span>), <span style="color:#e6db74">&#34; [&#34;</span>, <span style="color:#a6e22e">hex</span>(<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">stack</span>.<span style="color:#a6e22e">lo</span>), <span style="color:#e6db74">&#34;,&#34;</span>, <span style="color:#a6e22e">hex</span>(<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">stack</span>.<span style="color:#a6e22e">hi</span>), <span style="color:#e6db74">&#34;]\n&#34;</span>)
			<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;entersyscall&#34;</span>)
		})
	}

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">trace</span>.<span style="color:#a6e22e">enabled</span> {
		<span style="color:#a6e22e">systemstack</span>(<span style="color:#a6e22e">traceGoSysCall</span>)
		<span style="color:#a6e22e">save</span>(<span style="color:#a6e22e">pc</span>, <span style="color:#a6e22e">sp</span>)
	}

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Load</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">sysmonwait</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
		<span style="color:#a6e22e">systemstack</span>(<span style="color:#a6e22e">entersyscall_sysmon</span>)
		<span style="color:#a6e22e">save</span>(<span style="color:#a6e22e">pc</span>, <span style="color:#a6e22e">sp</span>)
	}

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>().<span style="color:#a6e22e">runSafePointFn</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
		<span style="color:#a6e22e">systemstack</span>(<span style="color:#a6e22e">runSafePointFn</span>)
		<span style="color:#a6e22e">save</span>(<span style="color:#a6e22e">pc</span>, <span style="color:#a6e22e">sp</span>)
	}

	<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">syscalltick</span> = <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>().<span style="color:#a6e22e">syscalltick</span>
	<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">sysblocktraced</span> = <span style="color:#66d9ef">true</span>
	<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">mcache</span> = <span style="color:#66d9ef">nil</span>
	<span style="color:#a6e22e">pp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>()
	<span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">m</span> = <span style="color:#ae81ff">0</span>
	<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">oldp</span>.<span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">pp</span>)
	<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span> = <span style="color:#ae81ff">0</span>
	<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Store</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">pp</span>.<span style="color:#a6e22e">status</span>, <span style="color:#a6e22e">_Psyscall</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">gcwaiting</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
		<span style="color:#a6e22e">systemstack</span>(<span style="color:#a6e22e">entersyscall_gcwait</span>)
		<span style="color:#a6e22e">save</span>(<span style="color:#a6e22e">pc</span>, <span style="color:#a6e22e">sp</span>)
	}

	<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">locks</span><span style="color:#f92672">--</span>
}
</code></pre></div><p>然后就进入系统调用</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">...</span>
</code></pre></div><ol>
<li>获得goroutine</li>
<li>线程加锁</li>
<li>调exitsyscallfast替当前goroutine找一个P
<ol>
<li>如果原P处于Psyscall就让这个P接管，否则的话进行2)</li>
<li>否则的话就找空闲的P，有的话就调用exitsyscall0继续调度，否则的话进行3)</li>
<li>将goroutine设置为Grunning，加入全局队列，调用Gosched()继续调度</li>
</ol>
</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">exitsyscall</span>() {
	<span style="color:#a6e22e">_g_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getg</span>()

	<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">locks</span><span style="color:#f92672">++</span> <span style="color:#75715e">// see comment in entersyscall
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">getcallersp</span>() &gt; <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">syscallsp</span> {
		<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;exitsyscall: syscall frame is no longer valid&#34;</span>)
	}

	<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">waitsince</span> = <span style="color:#ae81ff">0</span>
	<span style="color:#a6e22e">oldp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">oldp</span>.<span style="color:#a6e22e">ptr</span>()
	<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">oldp</span> = <span style="color:#ae81ff">0</span>
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">exitsyscallfast</span>(<span style="color:#a6e22e">oldp</span>) {
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">mcache</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
			<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;lost mcache&#34;</span>)
		}
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">trace</span>.<span style="color:#a6e22e">enabled</span> {
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">oldp</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>() <span style="color:#f92672">||</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">syscalltick</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>().<span style="color:#a6e22e">syscalltick</span> {
				<span style="color:#a6e22e">systemstack</span>(<span style="color:#a6e22e">traceGoStart</span>)
			}
		}
		<span style="color:#75715e">// There&#39;s a cpu for us, so we can run.
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>().<span style="color:#a6e22e">syscalltick</span><span style="color:#f92672">++</span>
		<span style="color:#75715e">// We need to cas the status and scan before resuming...
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">casgstatus</span>(<span style="color:#a6e22e">_g_</span>, <span style="color:#a6e22e">_Gsyscall</span>, <span style="color:#a6e22e">_Grunning</span>)

		<span style="color:#75715e">// Garbage collector isn&#39;t running (since we are),
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// so okay to clear syscallsp.
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">syscallsp</span> = <span style="color:#ae81ff">0</span>
		<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">locks</span><span style="color:#f92672">--</span>
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">preempt</span> {
			<span style="color:#75715e">// restore the preemption request in case we&#39;ve cleared it in newstack
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">stackguard0</span> = <span style="color:#a6e22e">stackPreempt</span>
		} <span style="color:#66d9ef">else</span> {
			<span style="color:#75715e">// otherwise restore the real _StackGuard, we&#39;ve spoiled it in entersyscall/entersyscallblock
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">stackguard0</span> = <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">stack</span>.<span style="color:#a6e22e">lo</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">_StackGuard</span>
		}
		<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">throwsplit</span> = <span style="color:#66d9ef">false</span>

		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">disable</span>.<span style="color:#a6e22e">user</span> <span style="color:#f92672">&amp;&amp;</span> !<span style="color:#a6e22e">schedEnabled</span>(<span style="color:#a6e22e">_g_</span>) {
			<span style="color:#75715e">// Scheduling of this goroutine is disabled.
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">Gosched</span>()
		}

		<span style="color:#66d9ef">return</span>
	}

	<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">sysexitticks</span> = <span style="color:#ae81ff">0</span>
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">trace</span>.<span style="color:#a6e22e">enabled</span> {
		<span style="color:#75715e">// Wait till traceGoSysBlock event is emitted.
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// This ensures consistency of the trace (the goroutine is started after it is blocked).
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">oldp</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">oldp</span>.<span style="color:#a6e22e">syscalltick</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">syscalltick</span> {
			<span style="color:#a6e22e">osyield</span>()
		}
		<span style="color:#75715e">// We can&#39;t trace syscall exit right now because we don&#39;t have a P.
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// Tracing code can invoke write barriers that cannot run without a P.
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// So instead we remember the syscall exit time and emit the event
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// in execute when we have a P.
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">sysexitticks</span> = <span style="color:#a6e22e">cputicks</span>()
	}

	<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">locks</span><span style="color:#f92672">--</span>

	<span style="color:#75715e">// Call the scheduler.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">mcall</span>(<span style="color:#a6e22e">exitsyscall0</span>)

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">mcache</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;lost mcache&#34;</span>)
	}

	<span style="color:#75715e">// Scheduler returned, so we&#39;re allowed to run now.
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// Delete the syscallsp information that we left for
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// the garbage collector during the system call.
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// Must wait until now because until gosched returns
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// we don&#39;t know for sure that the garbage collector
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// is not running.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">syscallsp</span> = <span style="color:#ae81ff">0</span>
	<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">ptr</span>().<span style="color:#a6e22e">syscalltick</span><span style="color:#f92672">++</span>
	<span style="color:#a6e22e">_g_</span>.<span style="color:#a6e22e">throwsplit</span> = <span style="color:#66d9ef">false</span>
}
</code></pre></div><p><a href="https://www.cnblogs.com/abozhang/p/10766628.html">参考资料go语言调度器源代码情景分析</a></p>

    </div>
  </article>
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: 'a60f22cd3c5d7e6aafa8',
        clientSecret: 'db8f7c66f2e8e20275173155975b749870291c5b',
        repo: 'journey-c.github.io',
        owner: 'journey-c',
        admin: ['journey-c'],
        id: 'goroutine 源码阅读',
        distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
</script>

  

  
</main>

      <footer class="footer">
        <ul class="footer-links">
          <li>
            <p>Copyright @ 2020-<script>document.write(new Date().getFullYear())</script> <a class="footer-links-kudos" href="https://github.com/journey-c">Journey-C</a>.
    </p>
          </li>
        </ul>
      </footer>

    </div>

    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-S162K82BSE"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-S162K82BSE');
</script>


    <script type=text/javascript async src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$']],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(),
            i;
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
    MathJax.Hub.Config({
        TeX: {
            equationNumbers: {
                autoNumber: "AMS"
            }
        }
    });
    </script>
  </body>
</html>

