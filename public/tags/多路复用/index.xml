<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>多路复用 on Journey-C</title>
    <link>https://journey-c.github.io/tags/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</link>
    <description>Recent content in 多路复用 on Journey-C</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 20 Dec 2020 21:58:31 +0800</lastBuildDate>
    
	<atom:link href="https://journey-c.github.io/tags/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Linux的I/O多路复用机制</title>
      <link>https://journey-c.github.io/io-multiplexing/</link>
      <pubDate>Sun, 20 Dec 2020 21:58:31 +0800</pubDate>
      
      <guid>https://journey-c.github.io/io-multiplexing/</guid>
      <description>1. 文件系统简介 Linux平台万物皆文件，这句话实际是在夸Linux出色的虚拟文件系统，Linux将所有设备抽象为文件，与设备的数据交互抽象为文件的I/O。
Linux的虚拟文件系统大概分为四块：
 超级块   文件系统(ext3,ext4以及windows上的NTFS、FAT32、FAT16等) 内核结构对应super_block，对应操作对象super_operations。   索引节点   操作系统以块为单位对磁盘操作(块是扇区大小的整数倍)。索引节点记录了文件在磁盘上所有的物理块(文件内容)，以及其他信心(更新时间，操作时间等)。 内核结构对应inode，对应操作对象inode_operations。   目录项   可以理解为文件的路径(不是目录，Linux上目录也是文件)，进程操作文件时通过目录项找到实际文件。 内核结构对应dentry，对应操作对象dentry_operations。   文件   由进程打开的文件。 内核结构对应file，对应操作对象file_operations  通常服务里例如socket，pipe等对象的read，write实际就是file对应的file_operations的操作，而本文讲解I/O相关事情。
2. 几种I/O模型 2.1 Blocking I/O  传统的阻塞I/O，对一个文件描述符操作(FD)时，如果操作没有响应就会一直等待，直到内核有反馈。缺点就是单线程一次只能操作一个FD。  2.2 Nonblocking I/O  非阻塞I/O，对FD操作时，如果内核没反馈不会一直等待。非阻塞I/O会将所有FD放入FD set，一直轮询所有FD，直到有反馈的。缺点就是每次轮询时没有事件的FD也会被操作，浪费CPU。  2.3 Signal Driven I/O  信号驱动I/O的基本原理就是首先注册signal handler，当FD有事件到来时，内核会像进程发送信号，然后应用进程执行signal handler。缺点就是，编程难度高，信号处理起来复杂。  2.4 Asynchronous I/O  异步I/O和信号驱动I/O都是异步的，区别是:信号驱动I/O是FD满足条件时内核通知应用程序可以进行I/O了，而异步I/O是应用程序将I/O操作交给内核，当内核做完之后再通知应用程序I/O做完了。缺点是异步的并发量不好控制。  2.5 I/O Multiplexing  多路复用实际不是一个技术而是一个理念，在I/O多路复用之前就有通讯线路的频分复用和时分复用，大概就是合理的安排每个单位使用资源的时间和位置，看起来所有单位一起在使用原本只能允许少量单位同时使用的资源。 Linux的I/O多路复用机制就是本文要讲的内容了。I/O多路复用就是将所有的FD注册到内核，然后当哪个FD可用时，那个会通知应用程序可用。  应用程序使用Linux提供的I/O多路复用机制都是通过系统调用使用的。最初Linux只提供了Select，在哪个服务端fd使用数量普遍不高的年代是够用的，后来随着网络的发展，1024个FD的限制已经不够用了，所以Linux提供了Poll，Poll只优化了存储结构，Select使用BitMap来存储FD，Poll使用数组来存储FD，不再限制数量，但是遍历时间复杂度还是$O(lg^N)$。终于在Linux 2.</description>
    </item>
    
  </channel>
</rss>