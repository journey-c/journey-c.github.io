<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>journey-c</title>
  
  <subtitle>journey-c</subtitle>
  <link href="https://journey-c.github.io/atom.xml" rel="self"/>
  
  <link href="https://journey-c.github.io/"/>
  <updated>2021-01-01T15:37:20.038Z</updated>
  <id>https://journey-c.github.io/</id>
  
  <author>
    <name>journey-c</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>为什么redis有多个数据库?</title>
    <link href="https://journey-c.github.io/2021/01/01/why-redis-has-multiple-databases/"/>
    <id>https://journey-c.github.io/2021/01/01/why-redis-has-multiple-databases/</id>
    <published>2021-01-01T15:37:20.038Z</published>
    <updated>2021-01-01T15:37:20.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><a href="https://zh.wikipedia.org/wiki/Redis">Redis</a>是一个开源内存数据库，在今天几乎每个服务端程序员都会或多或少的使用到。但是很少有人会注意到一个Redis实例并不是只有一个数据库。</p><h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><p>Redis实例使用<a href="https://github.com/redis/redis/blob/25214bd7dc2f4c995d76020e95180eb4e6d51672/src/server.h#L1055">redisServer</a>结构体表示，结构体成员变量中的<a href="https://github.com/redis/redis/blob/25214bd7dc2f4c995d76020e95180eb4e6d51672/src/server.h#L1068">redisDb *db;</a>是redisServer用来存储用户存入的键值。(默认有16个，通过配置文件中databases配置。每个客户端可以通过<code>SELECT index</code>命令选择要访问的数据库)</p><p><a href="https://github.com/redis/redis/blob/25214bd7dc2f4c995d76020e95180eb4e6d51672/src/server.h#L1068">redisDb *db</a>成员变量如下图最右边方框。</p><p><img src="/images/server_data_structure.png" alt="server"></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="数据分块优化查询速度"><a href="#数据分块优化查询速度" class="headerlink" title="数据分块优化查询速度?"></a>数据分块优化查询速度?</h2><p>将数据分块添加多级索引，但是找了很多地方发现每个db都是独立的，而且客户端对单个数据库操作时不会访问其他数据库，并且其他客户端无关操作例如RDB、AOF持久化操作也不会将各db关联起来。</p><p>并且redisdb中的dict本身就会在数据增多时对数据进行rehash，所以这个可能大概率不存在。</p><h2 id="对数据进行分类"><a href="#对数据进行分类" class="headerlink" title="对数据进行分类?"></a>对数据进行分类?</h2><p>redis本身是一个nosql数据库，想查询部分特征的数据本身操作会非常复杂，所以可能作者想用户可以根据需要将不同数据存入不同的db，但是db本身不支持自定义名称，只有编号，用户如果想将数据分类只能记住db的编号，每次访问数据时先用<code>SELECT index</code>命令切换数据库然后再操作。这个可能性很高，但也说服力不强。</p><p>因为实在没有想到其他的可能，所以我开始在网上找一下其他同行对此的见解，意外的搜到了作者一封邮件…</p><p><img src="/images/mail.jpeg" alt="mail"></p><p>原来作者最初的想法很多，但最后觉得很鸡肋，由于要保持向下兼容，所以就保留了这个功能。虽然实际生产中Redis实例很少会用到多个DB，但每个DB大概1m左右也不是十分耗费资源，所以无伤大雅。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/Redis&quot;&gt;Redis&lt;/a&gt;是一个开源内存数据库，在今天几乎每个服务端程序员都会或多或少的使用到。但是很少有人会注意到一个Redis实例并不是只有一个数据库。&lt;/p&gt;
&lt;h1 id=&quot;设计&quot;&gt;&lt;a href=&quot;#设计&quot; class=&quot;headerlink&quot; title=&quot;设计&quot;&gt;&lt;/a&gt;设计&lt;/h1&gt;&lt;p&gt;Redis实例使用&lt;a href=&quot;https://github.com/redis/redis/blob/25214bd7dc2f4c995d76020e95180eb4e6d51672/src/server.h#L1055&quot;&gt;redisServer&lt;/a&gt;结构体表示，结构体成员变量中的&lt;a href=&quot;https://github.com/redis/redis/blob/25214bd7dc2f4c995d76020e95180eb4e6d51672/src/server.h#L1068&quot;&gt;redisDb *db;&lt;/a&gt;是redisServer用来存储用户存入的键值。(默认有16个，通过配置文件中databases配置。每个客户端可以通过&lt;code&gt;SELECT index&lt;/code&gt;命令选择要访问的数据库)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/redis/redis/blob/25214bd7dc2f4c995d76020e95180eb4e6d51672/src/server.h#L1068&quot;&gt;redisDb *db&lt;/a&gt;成员变量如下图最右边方框。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/server_data_structure.png&quot; alt=&quot;server&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h1&gt;&lt;h2 id=&quot;数据分块优化查询速度&quot;&gt;&lt;a href=&quot;#数据分块优化查询速度&quot; class=&quot;headerlink&quot; title=&quot;数据分块优化查询速度?&quot;&gt;&lt;/a&gt;数据分块优化查询速度?&lt;/h2&gt;&lt;p&gt;将数据分块添加多级索引，但是找了很多地方发现每个db都是独立的，而且客户端对单个数据库操作时不会访问其他数据库，并且其他客户端无关操作例如RDB、AOF持久化操作也不会将各db关联起来。&lt;/p&gt;
&lt;p&gt;并且redisdb中的dict本身就会在数据增多时对数据进行rehash，所以这个可能大概率不存在。&lt;/p&gt;</summary>
    
    
    
    
    <category term="redis" scheme="https://journey-c.github.io/tags/redis/"/>
    
    <category term="无用的冷知识" scheme="https://journey-c.github.io/tags/%E6%97%A0%E7%94%A8%E7%9A%84%E5%86%B7%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux的I/O多路复用机制</title>
    <link href="https://journey-c.github.io/2020/12/20/IO-multiplexing/"/>
    <id>https://journey-c.github.io/2020/12/20/IO-multiplexing/</id>
    <published>2020-12-20T11:59:26.030Z</published>
    <updated>2020-12-30T02:57:32.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-文件系统简介"><a href="#1-文件系统简介" class="headerlink" title="1. 文件系统简介"></a>1. 文件系统简介</h1><p>Linux平台万物皆文件，这句话实际是在夸Linux出色的虚拟文件系统，Linux将所有设备抽象为文件，与设备的数据交互抽象为文件的I/O。</p><p><img src="/images/file.png" alt="file"></p><p>Linux的虚拟文件系统大概分为四块：</p><ul><li>超级块</li></ul><ol><li>文件系统(ext3,ext4以及windows上的NTFS、FAT32、FAT16等)</li><li>内核结构对应<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/fs.h#L1415">super_block</a>，对应操作对象<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/fs.h#L1921">super_operations</a>。</li></ol><ul><li>索引节点</li></ul><ol><li>操作系统以块为单位对磁盘操作(块是扇区大小的整数倍)。索引节点记录了文件在磁盘上所有的物理块(文件内容)，以及其他信心(更新时间，操作时间等)。</li><li>内核结构对应<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/fs.h#L615">inode</a>，对应操作对象<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/fs.h#L1843">inode_operations</a>。</li></ol><ul><li>目录项</li></ul><ol><li>可以理解为文件的路径(不是目录，Linux上目录也是文件)，进程操作文件时通过目录项找到实际文件。</li><li>内核结构对应<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/dcache.h#L89">dentry</a>，对应操作对象<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/dcache.h#L135">dentry_operations</a>。</li></ol><ul><li>文件</li></ul><ol><li>由进程打开的文件。</li><li>内核结构对应<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/fs.h#L921">file</a>，对应操作对象<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/fs.h#L1801">file_operations</a></li></ol><p>通常服务里例如socket，pipe等对象的read，write实际就是file对应的file_operations的操作，而本文讲解I/O相关事情。</p><h1 id="2-几种I-O模型"><a href="#2-几种I-O模型" class="headerlink" title="2. 几种I/O模型"></a>2. 几种I/O模型</h1><h2 id="2-1-Blocking-I-O"><a href="#2-1-Blocking-I-O" class="headerlink" title="2.1 Blocking I/O"></a>2.1 Blocking I/O</h2><ul><li>传统的阻塞I/O，对一个文件描述符操作(FD)时，如果操作没有响应就会一直等待，直到内核有反馈。缺点就是单线程一次只能操作一个FD。</li></ul><p><img src="/images/io_block.jpeg" alt="io_block"></p><h2 id="2-2-Nonblocking-I-O"><a href="#2-2-Nonblocking-I-O" class="headerlink" title="2.2 Nonblocking I/O"></a>2.2 Nonblocking I/O</h2><ul><li>非阻塞I/O，对FD操作时，如果内核没反馈不会一直等待。非阻塞I/O会将所有FD放入FD set，一直轮询所有FD，直到有反馈的。缺点就是每次轮询时没有事件的FD也会被操作，浪费CPU。</li></ul><p><img src="/images/io_noblock.jpeg" alt="io_noblock"></p><h2 id="2-3-Signal-Driven-I-O"><a href="#2-3-Signal-Driven-I-O" class="headerlink" title="2.3 Signal Driven I/O"></a>2.3 Signal Driven I/O</h2><ul><li>信号驱动I/O的基本原理就是首先注册signal handler，当FD有事件到来时，内核会像进程发送信号，然后应用进程执行signal handler。缺点就是，编程难度高，信号处理起来复杂。</li></ul><p><img src="/images/io_signal.jpeg" alt="io_signal"></p><h2 id="2-4-Asynchronous-I-O"><a href="#2-4-Asynchronous-I-O" class="headerlink" title="2.4 Asynchronous I/O"></a>2.4 Asynchronous I/O</h2><ul><li>异步I/O和信号驱动I/O都是异步的，区别是:信号驱动I/O是FD满足条件时内核通知应用程序可以进行I/O了，而异步I/O是应用程序将I/O操作交给内核，当内核做完之后再通知应用程序I/O做完了。缺点是异步的并发量不好控制。</li></ul><p><img src="/images/io_async.jpeg" alt="io_async"></p><h2 id="2-5-I-O-Multiplexing"><a href="#2-5-I-O-Multiplexing" class="headerlink" title="2.5 I/O Multiplexing"></a>2.5 I/O Multiplexing</h2><ul><li>多路复用实际不是一个技术而是一个理念，在I/O多路复用之前就有通讯线路的频分复用和时分复用，大概就是合理的安排每个单位使用资源的时间和位置，看起来所有单位一起在使用原本只能允许少量单位同时使用的资源。</li><li>Linux的I/O多路复用机制就是本文要讲的内容了。I/O多路复用就是将所有的FD注册到内核，然后当哪个FD可用时，那个会通知应用程序可用。</li></ul><p><img src="/images/io_multi.jpeg" alt="io_multi"></p><p>应用程序使用Linux提供的I/O多路复用机制都是通过<a href="/2020/11/27/what-is-system-call">系统调用</a>使用的。最初Linux只提供了Select，在哪个服务端fd使用数量普遍不高的年代是够用的，后来随着网络的发展，1024个FD的限制已经不够用了，所以Linux提供了Poll，Poll只优化了存储结构，Select使用BitMap来存储FD，Poll使用数组来存储FD，不再限制数量，但是遍历时间复杂度还是$O(lg^N)$。终于在Linux 2.5.44版本，epoll闪亮登场，这是现在普遍使用的I/O多路复用机制。</p><h1 id="3-Select"><a href="#3-Select" class="headerlink" title="3. Select"></a>3. Select</h1><h2 id="3-1-使用"><a href="#3-1-使用" class="headerlink" title="3.1 使用"></a>3.1 使用</h2><p>Select是Linux最初提供的I/O多路复用函数。下面是libc库使用select的调用接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</span><br><span class="line">void FD_SET(int fd, fd_set *set);</span><br><span class="line">void FD_CLR(int fd, fd_set *set);</span><br><span class="line">int  FD_ISSET(int fd, fd_set *set);</span><br><span class="line">void FD_ZERO(fd_set *set);</span><br></pre></td></tr></table></figure><p>Select总共三部分参数</p><ol><li>传入FD(文件描述符)最大的+1</li><li>传入的FD，分三类<ul><li>1). 监听读</li><li>2). 监听写</li><li>3). 监听异常</li></ul></li><li>如果一直没有满足条件的fd，最多等多久(超时时间)</li></ol><p>select用一个<code>__FD_SETSIZE</code>位的BitMap表示输入参数，<code>__FD_SETSIZE</code>默认为1024。因为没有1024位那么长的数，所以用一个数组表示，因为数组元素地址连续，所以实际就是一个1024位的数，比如第1位为1，表示这次输入有fd1(标准输出fd)。这个地方也限制了<code>select最多支持1024个fd，并且fd的号码不能大于等于1024。</code></p><p><img src="/images/fd_set.png" alt="fd_set"></p><p>解释完fd_set的构造，FD_SET、FD_CLR等操作也就明白了，FD_SET(d, s)就是d是几号fd就将s的第几位置1，其他的类似。</p><h2 id="3-2-实现"><a href="#3-2-实现" class="headerlink" title="3.2 实现"></a>3.2 实现</h2><p>Linux的select函数是通过系统调用的机制提供给用户，我们来一起看一下Select的流程:</p><ol><li>系统调用函数入口在<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L722">SYSCALL_DEFINE5</a>，可能是历史原因想保留这个接口，所以这个函数没做事情直接调用了<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L700">kern_select</a>。</li><li>Select传入的时间是一个相对时间，<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L700">kern_select</a>判断如果时间参数不为空的话，就调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L273">poll_select_set_timeout</a>将相对时间转化为绝对时间(准确的几点几分几秒)，然后就调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L621">core_sys_select</a></li><li><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L621">core_sys_select</a>主要的工作就是为Select工作分配资源空间。<ul><li>获取<a href="https://en.wikipedia.org/wiki/Read-copy-update">rcu锁</a>，check一下第一个参数n是不是比进程最大可打开文件描述符数还大，如果还大的话修正n为最大可打开文件描述符数。释放<a href="https://en.wikipedia.org/wiki/Read-copy-update">rcu锁</a>，rcu实际就是延迟更新，读操作不需要获取锁，只需要标记一下还有用户在读。写操作时拷贝一份数据，更新副本，当所有没有读者读旧数据的时候再将副本数据更新到原始数据上。</li><li>接下来就是给输入的三个变量fds.in, fds.out, fds.ex，保存结果的三个变量(fds.res_in, fds.res_out, fds.res_ex)分配存储空间，先从<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L630">栈</a>分配，栈空间不够时从<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L658">堆</a>分配。</li><li>资源分配结束后就调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L476">do_select</a>开始真正的检查每个FD是否可用。</li><li><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L476">do_select</a>是select的核心，流程如下: <ul><li>首先调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L419">max_select_fd</a>找出传入FD的最大值+1，比较一下参数n是不是比最大FD+1还大，如果是就修正n为最大FD+1(<code>这里之所以总是将n修正为最大值+1，是因为do_select遍历范围是[0,n)</code>)，顺便检查下，传入的FD是不是有已关闭或者未打开的，如果有就报错<code>EBADF</code>:<ul><li>传入fd_set是long的数组，openfiles也是long的数组，因为之前n根据线程最大打开文件数修正过，所以通过(n/(long的位数))可以最高位可以比较的数组下表，然后fd_set数组的那一位根据(n % (long的位数))来去掉不满足条件的FD</li><li>然后就从最高位开始fd_set和open_file做AND操作，第一个匹配的就是最大FD。</li><li><img src="/images/max_select_fd.png" alt="max_select_fd"></li></ul></li><li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L121">poll_initwait</a>初始化<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L103">poll_wqueues</a>(维护select/poll任务的主要struct)，并且将<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L221">__pollwait</a>注册为<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L43">poll_table</a>的proc函数，file_operations-&gt;poll会调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L48">poll_wait</a>将此时所在线程(task)放入队列，poll_wait对调用__poll_wait，这个_poll_wait此时注册的函数。主要作用就是将任务放入队列，以及做一些其他任务。</li><li>如果timeout不为空，调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L236">poll_schedule_timeout</a>设置超时时间。</li><li>重复遍历所有fd_set:<ul><li>这个循环是个死循环，跳出条件为:<ul><li>超时时间到(如果设置了超时时间)。</li><li>线程被唤醒。</li><li>当前线程被信号唤醒。</li></ul></li><li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/file.h#L63">fdget</a>获取fd对应的file结构体。</li><li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L86">vfs_poll</a>，获取file的事件mask，如果有in，out，ex就放入对应结果的fd_set中。<ul><li><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L86">vfs_poll</a>最终会调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/fs.h#L1801">file_operations</a>的poll函数获取FD的事件状态mask，vfs_poll会调用file_operations-&gt;poll函数检查FD的事件，如果没有就调用poll_wait将线程放入等待队列。</li></ul></li><li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/file.h#L43">fdput</a>释放fd对应file结构体。</li><li>如果本次遍历一个有事件的FD也没有就调用cond_resched出让CPU，并且把线程状态设为INTERRUPTIBLE(睡眠可打断状态)，休眠直到被唤醒。</li><li>等到有<a href="#event_callback">事件回调</a>，就会重新遍历FD集合这次肯定有事件了，如果超时或者被信号唤醒也有相应操作。</li></ul></li></ul></li><li><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L476">do_select</a>将可用FD返回之后，调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L688">set_fd_set</a>拷贝回用户空间。</li><li>如果传入参数的BitsMap一开始是分配在堆上的就释放调。</li></ul></li><li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L297">poll_select_finish</a>将剩余时间拷贝回用户空间。</li></ol><h2 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3 小结"></a>3.3 小结</h2><p>select的流程简单来讲就是，将FD通过BitsMap传入内核，轮询所有的FD通过调用file-&gt;poll函数查询是否有对应事件，没有就将task加入FD对应file的待唤醒队列，等待事件来临被唤醒。(例如网卡来数据了)</p><p><img src="/images/select_process.png" alt="select_process"></p><ol><li>select使用BitsMap来传入和接受FD，每次调用都会在用户空间和内核空间之间拷贝。</li><li>select的BitsMap限制只能监听FD 0~1023。</li><li>轮询的方式监听所有FD，$O(n)$的复杂度</li></ol><h1 id="4-Poll"><a href="#4-Poll" class="headerlink" title="4. Poll"></a>4. Poll</h1><h2 id="4-1-使用"><a href="#4-1-使用" class="headerlink" title="4.1 使用"></a>4.1 使用</h2><p>随着互联网的发展Select 1024个FD的限制已经不满足众多服务了，于是出现了Poll，不再用BitsMap来传入FD，取而代之用动态数组传入FD，但获取事件状态的方式还是轮询。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int poll(struct pollfd *fds, nfds_t nfds, int timeout);</span><br><span class="line">struct pollfd &#123;</span><br><span class="line">    int   fd;         &#x2F;* file descriptor *&#x2F;</span><br><span class="line">    short events;     &#x2F;* requested events *&#x2F;</span><br><span class="line">    short revents;    &#x2F;* returned events *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>1.fds: 传入fd集合，由pollfd构成<ul><li><ol><li>fd: 文件描述符</li></ol></li><li><ol start="2"><li>events: 监听事件</li></ol></li><li><ol start="3"><li>revents: 返回FD是因为什么事件返回的</li></ol></li></ul></li><li>2.nfds: fds的长度</li><li>3.timeout: 超时时间，单位毫秒</li></ul><h2 id="4-2-实现"><a href="#4-2-实现" class="headerlink" title="4.2 实现"></a>4.2 实现</h2><p>Poll和Select的入口都在<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c">fs/select.c</a>中，下面我们来看一下Poll内核实现的流程:</p><ol><li>Poll的入口在<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L1057">SYSCALL_DEFINE3</a>，<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L1057">SYSCALL_DEFINE3</a>的主要工作是将timeout由相对时间转化为绝对时间。然后调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L970">do_sys_poll</a></li><li><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L970">do_sys_poll</a>流程:<ul><li>检查nfds是否超过进程最大可打开文件数，如果是就报错-EINVAL。</li><li>给输入参数分配空间再从用户空间拷贝过来，先试图在栈上分配，如果不够再从堆上分配。</li><li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L121">poll_initwait</a>初始化poll_wqueues(和select一样)，然后调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L881">do_poll</a>，do_poll主要流程为:<ul><li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L75">select_estimate_accuracy</a>设置过期时间。</li><li>然后就轮训所有的FD，调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L851">do_pollfd</a>检查FD的事件。do_pollfd也是调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L86">vfs_poll</a>来检测FD事件的，如果没有就将线程放入对应FD的等待队列等待被激活，自己休眠。(和select一样)</li></ul></li><li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L138">poll_freewait</a>释放刚刚初始化的poll_wqueues。</li><li>调用<code>__put_user</code>将结果拷贝回用户空间。</li><li>如果最开始参数是在堆上分配的，就释放内存。</li></ul></li></ol><h2 id="4-3-小结"><a href="#4-3-小结" class="headerlink" title="4.3 小结"></a>4.3 小结</h2><p>poll和select差不多，区别就是BitsMap换成了链表，FD数量只受poll可用内核内存大小限制。</p><p><img src="/images/poll_process.png" alt="poll_process"></p><ol><li>poll监听FD数量不再有限制(除线程本身限制外)，但是每次调用poll还是要将FD集合拷贝到内核态，完成后再拷贝回来。</li><li>监听所有FD的方式还是轮训，$O(n)$的复杂度。</li></ol><h1 id="5-Epoll"><a href="#5-Epoll" class="headerlink" title="5. Epoll"></a>5. Epoll</h1><h2 id="5-1-使用"><a href="#5-1-使用" class="headerlink" title="5.1 使用"></a>5.1 使用</h2><p>正因为select和poll有着各自的缺点，所以linux 2.5.44版本提供了新的I/O复用机制Epoll，在后续的版本中继续做了很多优化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct epoll_event &#123;</span><br><span class="line">    uint32_t     events;      &#x2F;* Epoll events *&#x2F;</span><br><span class="line">    epoll_data_t data;        &#x2F;* User data variable *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line">typedef union epoll_data &#123;</span><br><span class="line">    void        *ptr;</span><br><span class="line">    int          fd;</span><br><span class="line">    uint32_t     u32;</span><br><span class="line">    uint64_t     u64;</span><br><span class="line">&#125; epoll_data_t;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建用于epoll工作的FD</span><br><span class="line">int epoll_create(int size);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对事件操作：增、删等</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等待事件</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);  </span><br></pre></td></tr></table></figure><ul><li><p>epoll_create</p><ul><li>size: 监听fd的数量，Linux 2.6.8就去掉了这个参数，因为要兼容，所以留着这个参数，但实际内核没用。</li></ul></li><li><p>epoll_ctl</p><ul><li>epfd: epoll对应的FD</li><li>op: 操作码，增(EPOLL_CTL_ADD),删(EPOLL_CTL_DEL),改(EPOLL_CTL_MOD)</li><li>fd: 对epoll操作的源FD，例如要添加删除修改的FD</li><li>event: 要监听的事件</li></ul></li><li><p>epoll_wait</p><ul><li>epfd: epoll对应的FD</li><li>events: 要等待的事件数组</li><li>maxevents: 监听事件数量</li><li>timeout: 超时时间，单位毫秒</li></ul></li></ul><h2 id="5-2-实现"><a href="#5-2-实现" class="headerlink" title="5.2 实现"></a>5.2 实现</h2><h3 id="5-2-1-epoll-create"><a href="#5-2-1-epoll-create" class="headerlink" title="5.2.1 epoll_create"></a>5.2.1 epoll_create</h3><ol><li>epoll_create的入口在<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L2088">SYSCALL_DEFINE1</a>，这个函数只是简单的检查了一下size是否为0，epoll_create的size参数随便填只要大于0即可，不使用的。然后调用了<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L2040">do_epoll_create</a>对epoll_create操作统一处理。</li><li><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L2040">do_epoll_create</a>流程如下:<ul><li>检查一下flags除了EPOLL_CLOEXEC，还有没有其他的flag</li><li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1006">ep_alloc</a>申请一个<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L181">eventpoll</a>结构，这是存储epoll所有数据的数据结构。</li><li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/file.c#L561">get_unused_fd_flags</a>根据flags申请一个本进程最小未使用的fd。</li><li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/anon_inodes.c#L74">anon_inode_getfile</a>创建一个对应匿名inode的file，file的私有数据存的是eventpoll结构体。inode在VFS中对应一个文件，记录了此文件在磁盘那些块以及文件各种信息，匿名inode就是将此文件的dentry(目录项)删掉了，在文件系统中一般是通过dentry(目录项)来查找使用文件，这样其他进程就用不了这个文件。相当于创建一个临时文件。</li><li><img src="/images/anonymous_inode.png" alt="anonymous_inode"></li><li>现在file(由进程打开的文件)有了，fd有了，把file和fd的关系放入本进程的open_files中，就相当于本进程打开了这个文件。</li></ul></li></ol><h3 id="5-2-2-epoll-ctl"><a href="#5-2-2-epoll-ctl" class="headerlink" title="5.2.2 epoll_ctl"></a>5.2.2 epoll_ctl</h3><ol><li>epoll_ctl的入口在<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L2272">SYSCALL_DEFINE4</a>，首先根据op选择要不要从用户空间拷贝参数(只要不是DEL都需要拷贝)，之后就调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L2108">do_epoll_ctl</a>做主要的工作了。</li><li><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L2108">do_epoll_ctl</a>主要流程如下:<ul><li>参数获取:<ul><li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/file.h#L63">fdget</a>根据epfd获得epoll对应的file(epoll_create时创建的)，根据参数传入的fd获取对应的file。</li></ul></li><li>参数 :<ul><li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L81">file_can_poll</a>判断该文件支不支持poll函数，实际就是判断该文件对应的file_operation的poll函数为不为空。</li><li>判断系统支不支持autosleep功能，如果支持且用户也传入了EPOLLWAKEUP标志，就调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/uapi/linux/eventpoll.h#L83">ep_take_care_of_epollwakeup</a>将标志加到事件中，否则就将EPOLLWAKEUP事件丢弃。</li><li>check一下要操作的fd是不是epfd(操作自己epoll的fd)和epfd是不是一个epoll fd。</li><li>EPOLLEXCLUSIVE(since Linux 3.5)是一个FD被多个epoll监听时，当这个FD事件来临只有一个epoll会被唤起(避免惊群效应)。而epoll只允许add的时传入不允许mod时传入，这里就是check一下这种情况。</li><li>处理一种Epoll A包含Epoll B的FD，Epoll B也包含Epoll A的FD的情况，这时候如果其中一个FD有了事件，那么两个Epoll会循环被唤醒。</li></ul></li><li>接下来就是核心操作:<ul><li>根据file地址和fd大小 调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1041">ep_find</a> 查找传入fd是否在eventpoll结构体中的rbtree(存储所有监听的fd)已存在。rbtree的key就是<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L107">epoll_filefd</a>，比较规则，先比较file的地址，相同的话在比较fd的大小。</li><li>如果是ADD就调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1490">ep_insert</a>:<ul><li>当前用用户的epoll_watch和<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1502">max_user_watches</a>检查是否还有可用空间，内核给每个用户的epoll可以用空间限制为syscall可使用空间的$1/25$。</li><li>从缓存中创建一个新的epitem(<a href="/2020/10/22/red-black-tree">红黑树</a>的value)。</li><li>初始化rdllink(满足事件链表)，fllink(链接fd对应的file链表)，pwqlist(poll等待队列)。</li><li>初始化epitem的参数，调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L322">ep_set_ffd</a>根据file，fd生成<a href="/2020/10/22/red-black-tree">红黑树</a>的key(struct epoll_filefd)等。</li><li>向插入fd对应file的epoll事件链表(f_ep_links)中新增事件。</li><li>将epitem插入<a href="/2020/10/22/red-black-tree">红黑树</a>。</li><li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L75">init_poll_funcptr</a>注册poll回调函数<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1309">ep_ptable_queue_proc</a>。在前select一节有描述。这里回调函数<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1309">ep_ptable_queue_proc</a>除了将task放入FD对应file的等待队列之外，事件来临还会调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1204">ep_poll_callback</a>函数。</li><li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L877">ep_item_poll</a><ul><li>如果不是epoll的FD就调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L86">vfs_poll</a>-&gt;file_operations.poll查询FD事件如果有就返回，没有就插入等待队列。</li><li>如果是epoll的FD，就调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L677">ep_scan_ready_list</a>将epoll的rdllist(已就绪的FD)传入用户空间。</li></ul></li><li>如果有事件的话并且之前不在就绪链表rdllist，就放入就绪链表</li></ul></li><li>如果是DEL就调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L767">ep_remove</a>:<ul><li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L618">ep_unregister_pollwait</a>注销epoll_add时注册的file对应的poll_wait函数。</li><li>从各链表中删除。</li><li>从<a href="/2020/10/22/red-black-tree">红黑树</a>中删除。</li></ul></li><li>如果是MOD就调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1622">ep_modify</a>:<ul><li>修改FD事件。</li><li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L877">ep_item_poll</a>查询是否修改后有事件，有的话就放入rdllist就绪链表。</li></ul></li></ul></li></ul></li></ol><h3 id="5-2-3-epoll-wait"><a href="#5-2-3-epoll-wait" class="headerlink" title="5.2.3 epoll_wait"></a>5.2.3 epoll_wait</h3><ol><li>epoll_wait入口在<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L2330">SYSCALL_DEFINE4</a>，之后调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L2288">do_epoll_wait</a></li><li><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L2288">do_epoll_wait</a>主要流程:<ul><li>检查参数，参数是否正确，返回结果地址是否正确，要操作的epollfd是否正确。</li><li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1818">ep_poll</a><ul><li>如果有timeout不为零，就将时间转化为绝对时间，如果为0就检查一下当前就绪队列是否为空，如果有事件直接返回，没有事件就返回空。</li><li>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L375">ep_events_available</a>检查当前有无就绪FD，有就直接返回，或者当前file_operations-&gt;poll函数正忙就等等，看工作完有没有。</li><li>如果没有就进入死循环，和select一样，将task设为TASK_INTERRUPTIBLE，等待被唤醒或被信号唤醒或超时。</li><li>直到被唤醒依然调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L375">ep_events_available</a>检查有没有就绪FD，有的话就调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1778">ep_send_events</a>将结果传回用户空间。<ul><li><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1778">ep_send_events</a>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L677">ep_scan_ready_list</a>扫描rdllist链表并且调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1694">ep_send_events_proc</a>将事件发回用户空间，如果FD的使用的epoll的模式为EPOLLET(水平触发)发送完之后重新被加入rdllist链表，等待下次epoll_wait时，如果fd在rdllink中且已经不可读了就不再加入rdllist中了。</li><li>发送会用户空间之后，将因为rdllist发送时加锁而没加入的事件(放入了ovflist)加入rdllist。</li></ul></li></ul></li></ul></li></ol><h2 id="5-3-小结"><a href="#5-3-小结" class="headerlink" title="5.3 小结"></a>5.3 小结</h2><p>select和poll的模式都是，一次将参数拷贝到内核空间，等有结果了再一次拷贝出去，类似无状态服务。而epoll则只是在epoll_ctl(ADD)时将数据拷入，epoll_wait时在将数据拷出，多次复用没有其他数据拷贝，大大节省了数据拷贝。epoll采用<a href="/2020/10/22/red-black-tree">红黑树</a>存储所有被监听的FD是的查找删除时间复杂度由$O(N)$缩短为$O(log^N)$。</p><p><img src="/images/epoll_process.png" alt="epoll_process"></p><ol><li>epoll_create创建eventpoll结构。</li><li>epoll_ctl:<ul><li><ol><li>ADD检查FD事件，有就加入rdllist队列，没有就将task放入FD对应file的待唤醒列表，将FD加入<a href="/2020/10/22/red-black-tree">红黑树</a>维护。</li></ol></li><li><ol start="2"><li>DEL从eventpoll的各个资源中删除。</li></ol></li><li><ol start="3"><li>MOD修改事件，并再次检查FD事件，有就加入rdllist队列，没有就将task放入FD对应file的待唤醒列表并且注册事件回调函数——有事件来临就加入rdllist。</li></ol></li></ul></li><li>epoll_wait检查rdllist有没有已经就绪的FD，没有就等待时间来临唤醒，有事件就返回用户空间，并且清空rdllist链表，如果FD是EPOLLLET模式的就重新加入rdllist链表中，等待下次epoll_wait看情况清理。</li></ol><h1 id="6-select、poll、epoll对比"><a href="#6-select、poll、epoll对比" class="headerlink" title="6. select、poll、epoll对比"></a>6. select、poll、epoll对比</h1><table><thead><tr><th>名称</th><th>监听FD数量</th><th>数据拷贝</th><th>操作复杂度</th></tr></thead><tbody><tr><td>select</td><td>1024</td><td>每次操作从用户空间拷入内核空间然后拷出</td><td>$O(N)$</td></tr><tr><td>poll</td><td>内核限制sys内存大小</td><td>每次操作从用户空间拷入内核空间然后拷出</td><td>$O(N)$</td></tr><tr><td>epoll</td><td>内核限制sys内存大小</td><td>ADD时拷贝一次，epoll_wait时利用MMAP和用户共享空间，直接拷贝数据到用户控件</td><td>$O(1)$</td></tr></tbody></table><p><span id = "event_callback"></span></p><h1 id="7-事件回调"><a href="#7-事件回调" class="headerlink" title="7. 事件回调"></a>7. 事件回调</h1><p>select/poll/epoll最后都会调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L86">vfs_poll</a>，检查FD是否有相应事件。<br><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L86">vfs_poll</a>的核心流程就是:</p><ul><li>先检查FD对应的file目前是否已有事件，如果没有则将当前task(linux中线程进程都是task)加入到file的wait_queue，然后就让出CPU，等待被激活。</li><li>当file对应的设备有事件来临时，会激活file的wait_queue中所有等待的task(将task从等待态变为运行态，重新加入到调度列表中)。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CPU1                CPU2</span><br><span class="line">sys_select          receive packet</span><br><span class="line">...                 ...</span><br><span class="line">__add_wait_queue    update tp-&gt;rcv_nxt</span><br><span class="line">...                 ...</span><br><span class="line">tp-&gt;rcv_nxt check   sock_def_readable</span><br><span class="line">...                 &#123;</span><br><span class="line">schedule               rcu_read_lock();</span><br><span class="line">                       wq &#x3D; rcu_dereference(sk-&gt;sk_wq);</span><br><span class="line">                       if (wq &amp;&amp; waitqueue_active(&amp;wq-&gt;wait))</span><br><span class="line">                           wake_up_interruptible(&amp;wq-&gt;wait)</span><br><span class="line">                       ...</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="7-1-流程"><a href="#7-1-流程" class="headerlink" title="7.1 流程"></a>7.1 流程</h2><p>下面我们以socket为例，分析一下事件是如何回调的。</p><p>设备驱动层主要做的事情是，网卡作为一个硬件，当收到网络包的时候如何通知操作系统。没错，是硬件中断，硬件和操作系统打交道的方式基本都是硬件中断。而网卡与内核交互采用了硬件中断+下半部（主要是拷贝数据太耗时，放在中断处理程序中不妥）</p><ul><li>设备给中断控制器引脚发送信号。</li><li>中断控制器收到后给CPU发送信号。</li><li>CPU收到信号后产生中断，根据中断号在中断向量表中执行内核实现的中断处理程序。(执行程序实际就是已经与内核通讯了)<br><img src="/images/event_driver.png" alt="event_driver"></li></ul><p>以intel的ixgb网卡为例。</p><ol><li>网卡程序初始化时调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L116">ixgb_init_module</a>注册驱动<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L92">ixgb_driver</a>，并且调用驱动的probe函数<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L359">ixgb_probe</a>。</li><li><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L359">ixgb_probe</a>中与本文相关的有:<ul><li><ol><li>创建一个<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/netdevice.h#L1863">struct net_device</a>表示网络设备。</li></ol></li><li><ol start="2"><li>设置网卡的相关操作<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L331">ixgb_netdev_ops</a>，其中ndo_open函数是网卡激活时执行的函数，对应ixgb网卡的<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L593">ixgb_open</a>函数。调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L6600">netif_napi_add</a>为这个网络设备注册一个轮询 poll 函数 <a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L1752">ixgb_clean</a>，将来一旦出现网络包的时候，就是要通过它来轮询了。</li></ol></li><li><ol start="3"><li><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L593">ixgb_open</a>中调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L171">ixgb_up</a>注册硬件中断，类型为IRQF_SHARED，中断设备名字ixgb，并且中断处理程序为<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L1721">ixgb_intr</a></li></ol></li></ul></li><li>当网卡有数据来临时，网卡给中断控制器发送信号，中断控制器给CPU发送信号，CPU执行对应的中断处理函数<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L1721">ixgb_intr</a><ul><li><ol><li><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L1721">ixgb_intr</a>中调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L6281">__napi_schedule</a>和<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L4240">___napi_schedule</a>将设备标记，触发软件中断NET_RX_SOFTIRQ，软件中断号对应的中断处理函数为<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L6735">net_rx_action</a></li></ol></li><li><ol start="2"><li><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L6735">net_rx_action</a>调用napi_poll轮询所有的网络设备，napi_poll调用网卡注册是注册的poll函数<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L1752">ixgb_clean</a></li></ol></li><li><ol start="3"><li><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L1752">ixgb_clean</a>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L1929">ixgb_clean_rx_irq</a>读取数据并将数据存放到struct sk_buff中，然后调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L5553">netif_receive_skb</a>处理二层的数据。</li></ol></li></ul></li><li>从<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L5553">netif_receive_skb</a>开始处理二层的数据，调用链<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L5478">netif_receive_skb_internal</a>-&gt;<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L5380">__netif_receive_skb</a>-&gt;<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L5079">__netif_receive_skb_core</a><ul><li><ol><li><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L5079">__netif_receive_skb_core</a>中根据协议头将数据交给三层对应的协议栈。</li></ol></li></ul></li><li>现在就开始处理三层的数据里，假如当前的包是一个IPv4的包，数据就会流向<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/ip_input.c#L530">ip_rcv</a><ul><li><ol><li><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/ip_input.c#L530">ip_rcv</a>中得到IP的报头，然后调用NF_HOOK判断路由，不是本机的包就发走，是本机的包就调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/ip_input.c#L414">ip_rcv_finish</a></li></ol></li><li><ol start="2"><li><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/ip_input.c#L414">ip_rcv_finish</a>调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/ip_input.c#L314">ip_rcv_finish_core</a>然后根据IP报头中的协议把数据交给四层的协议栈。</li></ol></li></ul></li><li>千辛万苦数据终于来到了四层，假如当前是一个TCP包的话。会调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/tcp_ipv4.c#L1886">tcp_v4_rcv</a><ul><li><ol><li><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/tcp_ipv4.c#L1886">tcp_v4_rcv</a>根据IP以及tcp报头内容在<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/tcp_ipv4.c#L91">tcp_hashinfo</a> (<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/net/inet_hashtables.h#L124">inet_hashinfo</a>)找到对应socket</li></ol></li><li><ol start="2"><li>接下来根据socket的不同状态进行处理，socket根据情况进入三个不同队列，这一步主要是先将包找个地方放一下，赶紧离开中断状态。<ul><li><ol><li>backlog 当前没有用户在读数据，就将socket 放入backlog中，离开软件中断状态(到之前为止一直在软件中断中)</li></ol></li><li><ol start="2"><li>prequeue 如果当前有用户在读数据，且一个窗口的包还没收集完就放入prequeue</li></ol></li><li><ol start="3"><li>sk_receive_queue 当一个窗口的包准确收集完了，就放入sk_receive_queue中，用户可读取了。</li></ol></li></ul></li></ol></li><li><ol start="3"><li>当一个窗口的包准确收集完之后，就会调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/tcp_input.c#L4849">tcp_data_queue</a>将数据放入sk_receive_queue，然后调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/tcp_input.c#L4837">tcp_data_ready</a>，在调用sock的sk_data_ready函数<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/sock.c#L2901">sock_def_readable</a>，<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/sock.c#L2901">sock_def_readable</a>会唤醒之前因为调用file_operations.poll为阻塞的进程或线程。</li></ol></li></ul></li><li>这就到了咱们最关心的问题了，<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/tcp_input.c#L4837">tcp_data_ready</a>唤醒的是哪些task。</li></ol><h2 id="7-2-流程图"><a href="#7-2-流程图" class="headerlink" title="7.2 流程图"></a>7.2 流程图</h2><p><img src="/images/net_callback.png" alt="net_callback"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-文件系统简介&quot;&gt;&lt;a href=&quot;#1-文件系统简介&quot; class=&quot;headerlink&quot; title=&quot;1. 文件系统简介&quot;&gt;&lt;/a&gt;1. 文件系统简介&lt;/h1&gt;&lt;p&gt;Linux平台万物皆文件，这句话实际是在夸Linux出色的虚拟文件系统，Linux将所有设备抽象为文件，与设备的数据交互抽象为文件的I/O。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/file.png&quot; alt=&quot;file&quot;&gt;&lt;/p&gt;
&lt;p&gt;Linux的虚拟文件系统大概分为四块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;超级块&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;文件系统(ext3,ext4以及windows上的NTFS、FAT32、FAT16等)&lt;/li&gt;
&lt;li&gt;内核结构对应&lt;a href=&quot;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/fs.h#L1415&quot;&gt;super_block&lt;/a&gt;，对应操作对象&lt;a href=&quot;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/fs.h#L1921&quot;&gt;super_operations&lt;/a&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;索引节点&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;操作系统以块为单位对磁盘操作(块是扇区大小的整数倍)。索引节点记录了文件在磁盘上所有的物理块(文件内容)，以及其他信心(更新时间，操作时间等)。&lt;/li&gt;
&lt;li&gt;内核结构对应&lt;a href=&quot;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/fs.h#L615&quot;&gt;inode&lt;/a&gt;，对应操作对象&lt;a href=&quot;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/fs.h#L1843&quot;&gt;inode_operations&lt;/a&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;目录项&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;可以理解为文件的路径(不是目录，Linux上目录也是文件)，进程操作文件时通过目录项找到实际文件。&lt;/li&gt;
&lt;li&gt;内核结构对应&lt;a href=&quot;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/dcache.h#L89&quot;&gt;dentry&lt;/a&gt;，对应操作对象&lt;a href=&quot;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/dcache.h#L135&quot;&gt;dentry_operations&lt;/a&gt;。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="linux" scheme="https://journey-c.github.io/tags/linux/"/>
    
    <category term="I/O多路复用" scheme="https://journey-c.github.io/tags/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>系统调用</title>
    <link href="https://journey-c.github.io/2020/11/27/what-is-system-call/"/>
    <id>https://journey-c.github.io/2020/11/27/what-is-system-call/</id>
    <published>2020-11-27T03:50:46.009Z</published>
    <updated>2020-11-29T13:50:16.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1 .简介"></a>1 .简介</h1><p>系统调用就是操作系统提供给用户态应用与硬件交互的一组接口。在用户空间和硬件之间添加一个中间层(系统调用)主要的作用有:</p><ol><li>为用户空间提供抽象接口，用户不需要关心硬件种类介质等。</li><li>保障系统的稳定和安全，避免用户错误的使用硬件危害系统或者窃取其他进程的资源。</li><li>由于Linux进程都是运行在虚拟系统中，如果操作系统对用户访问硬件一无所知，就几乎无法实现多任务和虚拟内存。</li></ol><p><img src="/images/unix_arch.jpeg" alt="unix_arch"></p><div>    <center>图片来源<a href="https://www.amazon.com/Advanced-Programming-UNIX-Environment-3rd/dp/0321637739">《Advanced Programming in the UNIX Environment, 3rd Edition》</a></center></div><h1 id="2-三种使用系统调用方式"><a href="#2-三种使用系统调用方式" class="headerlink" title="2. 三种使用系统调用方式"></a>2. 三种使用系统调用方式</h1><p><img src="/images/syscall_method.png" alt="syscall_method"></p><h2 id="2-1-软件中断"><a href="#2-1-软件中断" class="headerlink" title="2.1 软件中断"></a>2.1 软件中断</h2><p><img src="/images/interrupt.png" alt="interrupt"></p><p>没有外界打扰的情况下处理器会一直执行给定指令，中断就是打断处理器的执行并且告诉他先执行另一段指令，执行完毕再接着执行中断前的指令。从中断指令发出的对象可以分为硬件中断和软件中断。</p><ul><li>硬件中断就是硬件通过传输电信号到中断控制器的输入引脚，中断控制器收到电信号之后会给处理器发送一个电信号，处理器一经检测到电信号之后就中断当前工作转而处理中断。之后会通知操作系统已经产生中断，进而操作系统可以处理这个中断了。</li><li>软件中断就是处理器执行特定指令时触发的中断，之后也会通知操作系统。</li><li>除了系统调用，还有中断下半部tasklet也是用软件中断实现的。</li></ul><p>在x86的机器上可以使用$INT$指令触发软件中断，Linux早期的时候就是使用软件中断来处理系统调用，中断号为128。<br>软件中断执行系统调用的流程为:</p><ol><li>用户将中断号放入$eax$寄存器，前六个参数按顺序放入$ebx$、$ecx$、$edx$、$esi$、$edi$、$ebp$寄存器，六个以上的情况，需要把所有参数放在用户空间的一段连续内存中(类似用struct传参)，然后将指向该内存区域的指针放入$ebx$中。</li><li>执行$int$ 0x80指令，处理器在中断向量表(<a href="https://en.wikipedia.org/wiki/Interrupt_descriptor_table">IDT</a>)中查找对应的中端处理程序，执行中断处理程序(操作系统由ring3进入ring0)<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/arch/x86/entry/entry_32.S#L1052">entry_INT80_32</a>:<ul><li>a. 调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/arch/x86/entry/entry_32.S#L1056">SAVE_ALL</a>将当前上下文保存到内核栈，然后调用<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/arch/x86/entry/common.c#L84">do_int80_syscall_32</a>。</li><li>b. <a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/arch/x86/entry/common.c#L84">do_int80_syscall_32</a> 从用户空间进入内核空间然后调用 <a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/arch/x86/entry/common.c#L72">do_syscall_32_irqs_on</a>，退出内核空间返回用户空间。</li><li>c. <a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/arch/x86/entry/common.c#L72">do_syscall_32_irqs_on</a> 检查系统调用号，从系统调用表<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/arch/x86/entry/syscall_32.c#L18">ia32_sys_call_table</a> <a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/arch/x86/entry/syscalls/syscall_32.tbl">syscall_32.tbl</a>中找出对应函数，并且将参数传给对应系统调用函数，唤起软件中断，将返回值放入$eax$寄存器。</li><li>d. 从内核栈恢复上下文。</li></ul></li></ol><p><img src="/images/interrupt_call.png" alt="interrupt_call"><br>下面就是一个通过软件中断调用write系统调用的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">global _start</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">_start:</span><br><span class="line">    mov eax,4      ; system call number</span><br><span class="line">    mov ebx,1      ; args 1: fd&#x3D;1(STDOUT)</span><br><span class="line">    mov ecx,msg    ; args 2: &quot;Hello World!&quot;</span><br><span class="line">    mov edx,msglen ; args 3: len(&quot;Hello World!&quot;)</span><br><span class="line">    int 0x80       ; soft interrupt</span><br><span class="line">    mov eax,1      ; syscall exit number</span><br><span class="line">    mov ebx,0      ; args 1: 0 (exit(0))</span><br><span class="line">    int 0x80       ; soft interrupt</span><br><span class="line"></span><br><span class="line">section .rodata</span><br><span class="line">    msg: db &quot;Hello, World!&quot;, 10</span><br><span class="line">    msglen: equ $ - msg </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nasm -g -f elf64 -o sys_call.o sys_call.s</span><br><span class="line">ld -o sys_call sys_call.o</span><br></pre></td></tr></table></figure><h2 id="2-2-汇编指令"><a href="#2-2-汇编指令" class="headerlink" title="2.2 汇编指令"></a>2.2 汇编指令</h2><p>由于中断实现的系统调用在个别处理器上表现非常差，Linux在较新版本上使用了intel和amd上实现的快速系统调用指令syscall/sysret(64)和sysenter/sysexit(32)。这也是目前最常用的系统调用方式。<br><img src="/images/asm.png" alt="asm"></p><p>具体流程为: </p><ol><li>cpu初始化<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/arch/x86/kernel/cpu/common.c#L1869">cpu_init</a> 调用 <a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/arch/x86/kernel/cpu/common.c#L1702">syscall_init</a></li><li><a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/arch/x86/kernel/cpu/common.c#L1702">syscall_init</a> 将系统调用处理函数<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/arch/x86/entry/entry_64.S#L95">entry_SYSCALL_64</a>和<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/arch/x86/entry/entry_32.S#L903">entry_SYSENTER_32</a>注册到<a href="https://en.wikipedia.org/wiki/Model-specific_register">MSR</a>寄存器，<a href="https://en.wikipedia.org/wiki/Model-specific_register">MSR</a>寄存器是用于控制CPU运行、功能开关、调试、跟踪程序执行、监测CPU性能等方面的寄存器。</li><li>触发系统调用后，它会在<a href="https://en.wikipedia.org/wiki/Model-specific_register">MSR</a>中读取需要执行的函数然后执行。</li><li>剩余流程和软件中断方式差不多。</li></ol><p><img src="/images/asm_call.png" alt="asm_call"></p><h2 id="2-3-vDOS"><a href="#2-3-vDOS" class="headerlink" title="2.3 vDOS"></a>2.3 vDOS</h2><p>Linux平台的用户使用系统调用的方式大多是通过<a href="https://www.gnu.org/software/libc/">libc</a>, 由于<a href="https://www.gnu.org/software/libc/">libc</a>库要兼容BSD，SysV Windows等平台，所以每当Linux新增系统调用时，<a href="https://www.gnu.org/software/libc/">libc</a>库都要间隔一段时间才会支持。并且有的用户升级Linux时并不会顺带升级<a href="https://www.gnu.org/software/libc/">libc</a>，导致双方都带有沉重历史包袱。</p><p>后来Linux实现了快速系统调用vsyscall，内核提供.so通过动态链接直接map到进程空间里供用户使用，但是vsyscall有一个风险点——map 的起始地址固定（0xffffffffff600000)，有潜在的安全风险。</p><p>为了改善vsyscall的局限性，设计了<a href="https://en.wikipedia.org/wiki/VDSO">vDSO</a>。但为了兼容vsyscall现在还保留着。</p><p>vDSO利用<a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">ASLR</a>增强里安全性，随机地址。</p><p>可以看到Linux中的进程大多包含vDSO的动态库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ldd &#x2F;bin&#x2F;cat </span><br><span class="line">linux-vdso.so.1 &#x3D;&gt;  (0x00007ffc03be0000)</span><br><span class="line">libc.so.6 &#x3D;&gt; &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6 (0x00007f52236dd000)</span><br><span class="line">&#x2F;lib64&#x2F;ld-linux-x86-64.so.2 (0x00007f5223aa7000)</span><br></pre></td></tr></table></figure><p>但是并不存在实际的.so文件，vsyscall以及vDOS将系统调用变为函数调用，并把他们映射到用户空间，明显的提高了系统调用的性能。<br>Linux 2.6时，vsyscall就支持了clock_gettime, gettimeofday, time。<a href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/arch/x86/entry/vdso/vdso.lds.S">vdso.lds.S</a></p><p><img src="/images/vdso.jpeg" alt="vdso"></p><p>看到这里的时候突然想到，刚参加工作的时候一位前辈和我说获取时间可以不使用系统调用，当时一脸懵逼，现在想想确实知道的太少。一些知识不是需要多高的智商才能学到，而是就摆在那，看了就不知道，不看就不知道。</p><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>系统调用是用户和硬件交互的媒介</p><ol><li>软中断实现是最初Linux实现系统调用方式，但现在还有使用的方式，例如golang在一些架构上系统调用还是使用软中断的方式，因为golang团队在做基准测试的时候发现，软中断方式和快速指令方式效率差不多。<a href="https://go-review.googlesource.com/c/go/+/16996/">runtime, syscall: use int $0x80 to invoke syscalls on android/386</a></li><li>快速汇编指令，intel和amd专门用于系统调用的指令。</li><li>vsyscall和vDSO通过动态库的方式。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1 .简介&quot;&gt;&lt;/a&gt;1 .简介&lt;/h1&gt;&lt;p&gt;系统调用就是操作系统提供给用户态应用与硬件交互的一组接口。在用户空间和硬件之间添加一个中间层(系统调用)主要的作用有:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为用户空间提供抽象接口，用户不需要关心硬件种类介质等。&lt;/li&gt;
&lt;li&gt;保障系统的稳定和安全，避免用户错误的使用硬件危害系统或者窃取其他进程的资源。&lt;/li&gt;
&lt;li&gt;由于Linux进程都是运行在虚拟系统中，如果操作系统对用户访问硬件一无所知，就几乎无法实现多任务和虚拟内存。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;/images/unix_arch.jpeg&quot; alt=&quot;unix_arch&quot;&gt;&lt;/p&gt;
&lt;div&gt;
    &lt;center&gt;图片来源&lt;a href=&quot;https://www.amazon.com/Advanced-Programming-UNIX-Environment-3rd/dp/0321637739&quot;&gt;《Advanced Programming in the UNIX Environment, 3rd Edition》&lt;/a&gt;&lt;/center&gt;
&lt;/div&gt;

&lt;h1 id=&quot;2-三种使用系统调用方式&quot;&gt;&lt;a href=&quot;#2-三种使用系统调用方式&quot; class=&quot;headerlink&quot; title=&quot;2. 三种使用系统调用方式&quot;&gt;&lt;/a&gt;2. 三种使用系统调用方式&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/syscall_method.png&quot; alt=&quot;syscall_method&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-1-软件中断&quot;&gt;&lt;a href=&quot;#2-1-软件中断&quot; class=&quot;headerlink&quot; title=&quot;2.1 软件中断&quot;&gt;&lt;/a&gt;2.1 软件中断&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/interrupt.png&quot; alt=&quot;interrupt&quot;&gt;&lt;/p&gt;
&lt;p&gt;没有外界打扰的情况下处理器会一直执行给定指令，中断就是打断处理器的执行并且告诉他先执行另一段指令，执行完毕再接着执行中断前的指令。从中断指令发出的对象可以分为硬件中断和软件中断。&lt;/p&gt;</summary>
    
    
    
    
    <category term="操作系统" scheme="https://journey-c.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="linux" scheme="https://journey-c.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>博客重新装修美化</title>
    <link href="https://journey-c.github.io/2020/11/26/sketch/the-first-sketch/"/>
    <id>https://journey-c.github.io/2020/11/26/sketch/the-first-sketch/</id>
    <published>2020-11-26T13:27:32.322Z</published>
    <updated>2020-11-27T06:39:05.324Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/yiheyuan_hu.jpeg" alt="yangguo"><br>从最开始的新浪博客，到迁移到博客园，再到现在的静态blog。</p><a id="more"></a><p>今年开始一直想给博客换个地方，一来写的东西本地没有，总觉得不方便，二来博客园不好看…哈哈哈哈哈。</p><p>十月初的时候恰好看到了kuangbin大佬的新博客，突然有种“这就是我想要的”感觉，所以就开始做一个静态blog，一开始的方案是hexo+next，但是看了一周左右视觉疲劳了，全是next。所以开始找简约的主题，简单到极致才好。</p><p>最后的版本也看到了，主页只有文章标题，所有的都在一页，一眼看完方便至极，没有花里胡哨的东西。</p><p>以后写的东西基本都会发在这里了～</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/yiheyuan_hu.jpeg&quot; alt=&quot;yangguo&quot;&gt;&lt;br&gt;从最开始的新浪博客，到迁移到博客园，再到现在的静态blog。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>如何使用vim作为golang和cxx开发IDE</title>
    <link href="https://journey-c.github.io/2020/11/19/how-to-use-vim-as-golang-and-cxx-development-ide/"/>
    <id>https://journey-c.github.io/2020/11/19/how-to-use-vim-as-golang-and-cxx-development-ide/</id>
    <published>2020-11-19T14:42:39.886Z</published>
    <updated>2020-11-19T16:33:26.228Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作为一个初学者，很多同学的路子都是这样的：费劲心思装好windows和Linux双系统，看着Linux界面难看，开始找美化软件的工具；美化好了，安装好了g++，因为gedit不好用，sublimetext、atom好用但是不太方便编译，然后陷入vim还是emacs的抉择；最终决定用vim，打印了一张vim键盘图开始学习，略为抱怨门槛高；入门之后发现写代码确实快了很多，为了更快，更美观，开始折腾vim的插件，学习怎么打tag等等等等…感觉万事具备，只欠好好学c++了，发现需要学习g++的编译连接，库文件，多个源文件，大工程，然后开始学习makefile的写法…从此越跑越偏，后来突然发现python看起来简单，要不学python吧。后来又觉得python似乎找工作不占很大优势，转而学java。后来又觉得javascript更简单，所以搞前端吧。然后发现还需要学html、css、数据库、日新月异的新框架…一本书，《c++从入门到放弃》。</p></blockquote><h1 id="1-最终成品"><a href="#1-最终成品" class="headerlink" title="1. 最终成品"></a>1. 最终成品</h1><p>先给大家看看成品的样子<br><img src="/images/vim_0.jpeg" alt="vim_0.jpg"></p><h1 id="2-所见即所得"><a href="#2-所见即所得" class="headerlink" title="2. 所见即所得"></a>2. 所见即所得</h1><p>折腾vim大概有四五年的时间了，下面总结了想要将vim作为主开发工具需要的条件。</p><table><thead><tr><th>类别</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>开发</td><td>代码跳转</td><td>✔</td></tr><tr><td></td><td>查看引用</td><td>✔</td></tr><tr><td></td><td>代码补全</td><td>✔</td></tr><tr><td></td><td>查找替换</td><td>✔</td></tr><tr><td></td><td>变量、函数更名</td><td>✔</td></tr><tr><td>辅助</td><td>文件目录</td><td>✔</td></tr><tr><td></td><td>函数目录</td><td>✔</td></tr><tr><td></td><td>注释</td><td>✔</td></tr><tr><td></td><td>全局搜索文件</td><td>✔</td></tr><tr><td></td><td>全局搜索关键词</td><td>✔</td></tr><tr><td></td><td>补全括号</td><td>✔</td></tr><tr><td>美化</td><td>主题</td><td>✔</td></tr><tr><td></td><td>状态栏</td><td>✔</td></tr><tr><td></td><td>Git信息</td><td>✔</td></tr><tr><td></td><td>启动页美化</td><td>✔</td></tr></tbody></table><h2 id="2-1-准备"><a href="#2-1-准备" class="headerlink" title="2.1 准备"></a>2.1 准备</h2><p>很多插件在neo-vim下支持更好，但是寡人是个念旧的人，所以一直用【<em>VIM - Vi IMproved 8.2</em>】<br>所以在开始配置之前，需要准备vim 8.0以上版本并且支持python3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;vim&#x2F;vim.git</span><br><span class="line">cd vim</span><br><span class="line">.&#x2F;configure --with-features&#x3D;huge \</span><br><span class="line">--enable-multibyte \</span><br><span class="line">--enable-python3interp&#x3D;yes \</span><br><span class="line">--with-python3-config-dir&#x3D;[你机器上python3的路径] \</span><br><span class="line">--enable-gui&#x3D;gtk2 \</span><br><span class="line">--enable-cscope \</span><br><span class="line">--prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;vim</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>如果不知道python3的路径，可以用whereis python3找一下。<br>最终下面的效果就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ vim --version</span><br><span class="line">VIM - Vi IMproved 8.2 (2019 Dec 12, compiled May 26 2020 06:16:44)</span><br><span class="line">macOS version</span><br><span class="line">...</span><br><span class="line">+comments          +linebreak         +python3           +visualextra</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="2-2-插件管理"><a href="#2-2-插件管理" class="headerlink" title="2.2 插件管理"></a>2.2 插件管理</h2><p>现在最通用的插件管理插件就是<a href="https://github.com/junegunn/vim-plug">vim-plug</a>了，支持异步安装更新。</p><ul><li><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fLo ~&#x2F;.vim&#x2F;autoload&#x2F;plug.vim --create-dirs \</span><br><span class="line">    https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;junegunn&#x2F;vim-plug&#x2F;master&#x2F;plug.vim</span><br></pre></td></tr></table></figure></li><li><p>使用<br>想安装某个插件只需要在.vimrc里配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">call plug#begin(&#39;~&#x2F;.vim&#x2F;plugged&#39;)</span><br><span class="line">    Plug &#39;scrooloose&#x2F;nerdtree&#39;                          &quot; 目录树</span><br><span class="line">    Plug &#39;scrooloose&#x2F;nerdcommenter&#39;                     &quot; 注释</span><br><span class="line">    Plug &#39;vim-airline&#x2F;vim-airline&#39;                      &quot; Vim状态栏插件，包括显示行号，列号，文件类型，文件名，以及Git状态</span><br><span class="line">    Plug &#39;tpope&#x2F;vim-fugitive&#39;                           &quot; 显示git分支</span><br><span class="line">    Plug &#39;Yggdroot&#x2F;LeaderF&#39;, &#123; &#39;tag&#39;: &#39;v1.22&#39;, &#39;do&#39;: &#39;.&#x2F;install.sh&#39; &#125;   &quot; 全局搜索</span><br><span class="line">    Plug &#39;fatih&#x2F;vim-go&#39;, &#123; &#39;do&#39;: &#39;:GoUpdateBinaries&#39; &#125;  &quot; vim-go</span><br><span class="line">    Plug &#39;yianwillis&#x2F;vimcdoc&#39;                           &quot; 中文文档</span><br><span class="line">    Plug &#39;neoclide&#x2F;coc.nvim&#39;, &#123;&#39;branch&#39;: &#39;release&#39;&#125;     &quot; 补全</span><br><span class="line">    Plug &#39;octol&#x2F;vim-cpp-enhanced-highlight&#39;             &quot; C++高亮</span><br><span class="line">    Plug &#39;mhinz&#x2F;vim-startify&#39;                           &quot; 启动界面</span><br><span class="line">call plug#end()</span><br></pre></td></tr></table></figure><p>然后在vim的NORMAL状态(按ESC)下执行<code>:PlugInstall</code>即可完成插件的安装。<br><img src="/images/vim_1.jpeg" alt="vim_1"></p></li></ul><p>插件更新的命令为<code>:PlugUpdate</code><br>vim-plug更新的命令为<code>:PlugUpgrade</code></p><h2 id="2-3-开发"><a href="#2-3-开发" class="headerlink" title="2.3 开发"></a>2.3 开发</h2><h3 id="2-3-1-插件安装"><a href="#2-3-1-插件安装" class="headerlink" title="2.3.1 插件安装"></a>2.3.1 插件安装</h3><p>vim代码跳转、查看引用、代码补全、变量更名功能现在流行的解决方案都是基于微软提出的<a href="https://microsoft.github.io/language-server-protocol/">LSP协议</a>进行开发，我使用的插件是<a href="https://github.com/neoclide/coc.nvim">coc-nvim</a>是目前比较好的LSP客户端插件。</p><p>coc-nvim基于nodejs开发，所以首先安装nodejs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sL install-node.now.sh&#x2F;lts | bash</span><br></pre></td></tr></table></figure><p>使用vim-plug安装coc-nvim</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">call plug#begin(&#39;~&#x2F;.vim&#x2F;plugged&#39;)</span><br><span class="line">    Plug &#39;fatih&#x2F;vim-go&#39;, &#123; &#39;do&#39;: &#39;:GoUpdateBinaries&#39; &#125;  &quot; vim-go</span><br><span class="line">    Plug &#39;neoclide&#x2F;coc.nvim&#39;, &#123;&#39;branch&#39;: &#39;release&#39;&#125;     &quot; 补全</span><br><span class="line">call plug#end()</span><br></pre></td></tr></table></figure><p>因为<a href="https://github.com/fatih/vim-go">vim-go</a>针对go开发定制了特别多功能，所以通常会连着vim-go一起安装。</p><ul><li><p>vim-go<br>安装完之后需要到vim里执行<code>:GoInstallBinaries</code>安装vim-go需要的一些go工具(gopls，goimports等，可能需要科学上网)</p></li><li><p>coc-nvim<br>安装完需要到vim里用coc-nvim配置golang和cxx环境，<code>:CocInstall coc-go</code> <code>:CocInstall coc-clangd</code><br><img src="/images/vim_3.jpeg" alt="vim_3"></p></li></ul><h3 id="2-3-2-插件配置"><a href="#2-3-2-插件配置" class="headerlink" title="2.3.2 插件配置"></a>2.3.2 插件配置</h3><p>安装完需要配置一下，下面是vim-go的配置，coc-nvim配置太长了，附录里有完整配置可以参考。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&quot; vim-go &#123;</span><br><span class="line"></span><br><span class="line">let g:go_fmt_command&#x3D;&quot;goimports&quot; &quot; 格式化将默认的 gofmt 替换</span><br><span class="line">let g:go_info_mode&#x3D;&#39;gopls&#39;</span><br><span class="line">let g:go_def_mode&#x3D;&#39;gopls&#39;</span><br><span class="line">let g:go_rename_command&#x3D;&#39;gopls&#39;  &quot; 重命名变量</span><br><span class="line">let g:go_referrers_mode&#x3D;&#39;gopls&#39;</span><br><span class="line"></span><br><span class="line">&quot; 美化类</span><br><span class="line">let g:go_autodetect_gopath&#x3D;1</span><br><span class="line">let g:go_list_type&#x3D;&quot;quickfix&quot;</span><br><span class="line">let g:go_version_warning&#x3D;1</span><br><span class="line">let g:go_highlight_types&#x3D;1</span><br><span class="line">let g:go_highlight_fields&#x3D;1</span><br><span class="line">let g:go_highlight_functions&#x3D;1</span><br><span class="line">let g:go_highlight_function_calls&#x3D;1</span><br><span class="line">let g:go_highlight_operators&#x3D;1</span><br><span class="line">let g:go_highlight_extra_types&#x3D;1</span><br><span class="line">let g:go_highlight_methods&#x3D;1</span><br><span class="line">let g:go_highlight_generate_tags&#x3D;1</span><br><span class="line">let g:go_highlight_function_parameters &#x3D; 1</span><br><span class="line">let g:go_highlight_build_constraints &#x3D; 1</span><br><span class="line"></span><br><span class="line">let g:godef_split&#x3D;2</span><br><span class="line"></span><br><span class="line">&quot; push quickfix window always to the bottom</span><br><span class="line">autocmd FileType qf wincmd J</span><br><span class="line"></span><br><span class="line">&quot; &#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-3-LSP安装"><a href="#2-3-3-LSP安装" class="headerlink" title="2.3.3 LSP安装"></a>2.3.3 LSP安装</h3><p>coc-nvim是基于<a href="https://microsoft.github.io/language-server-protocol/">LSP协议</a>开发的，所以要安装go和cxx的LSP服务器</p><ul><li><p>go<br>golang 有官方出的gopls，上面步骤里面vim-go已经给安装好了，只需要配置下环境变量即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH&#x3D;$PATH:$GOPATH&#x2F;bin:$HOME&#x2F;.cargo&#x2F;bin</span><br></pre></td></tr></table></figure><p>在终端直接输入gopls有反应即可</p></li><li><p>clangd<br>cpp和c的补全跳转等功能向来没有完美解决方案，小编用的是<a href="https://clangd.llvm.org/">clangd</a> + <a href="https://github.com/rizsotto/Bear">bear</a><br>clangd最为cxx的LSP，bear用于生成编译数据库compile_commands.json<br>注意: mac用户使用bear需要关闭SIP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">安装bear(centos下没装成功过)</span><br><span class="line"></span><br><span class="line">ubuntu:</span><br><span class="line">sudo apt-install bear</span><br><span class="line"></span><br><span class="line">mac:</span><br><span class="line">brew install bear</span><br></pre></td></tr></table></figure><p>clangd安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~&#x2F;.vim&#x2F;LSP&#x2F;bin</span><br><span class="line">cd ~&#x2F;.vim&#x2F;LSP</span><br><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;clangd&#x2F;clangd&#x2F;releases&#x2F;download&#x2F;11.0.0&#x2F;clangd-linux-11.0.0.zip # ubuntu</span><br><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;clangd&#x2F;clangd&#x2F;releases&#x2F;download&#x2F;11.0.0&#x2F;clangd-mac-11.0.0.zip   # mac os</span><br><span class="line"></span><br><span class="line">解压完，将bin目录下的clangd放到~&#x2F;.vim&#x2F;LSP&#x2F;bin下</span><br><span class="line">设置环境变量</span><br><span class="line">export PATH&#x3D;$PATH:$GOPATH&#x2F;bin:$HOME&#x2F;.vim&#x2F;LSP&#x2F;bin</span><br></pre></td></tr></table></figure><p>在终端输入clangd有反应即可<br>下面就可以愉快的开发golang和cxx了</p></li></ul><h3 id="2-3-4-快捷键"><a href="#2-3-4-快捷键" class="headerlink" title="2.3.4 快捷键"></a>2.3.4 快捷键</h3><table><thead><tr><th>功能</th><th>快捷键</th></tr></thead><tbody><tr><td>查看引用</td><td>leader键+gr或者:GoReferrers</td></tr><tr><td>跳转</td><td>gd</td></tr><tr><td>变量重命名</td><td>leader键+rn或者:GoRename</td></tr><tr><td>查找替换</td><td>%s/要查找的/要替换的/g</td></tr><tr><td>代码补全</td><td>自动的</td></tr><tr><td>查看channel读写情况</td><td>:GoChannelPeers</td></tr></tbody></table><h3 id="2-3-5-效果"><a href="#2-3-5-效果" class="headerlink" title="2.3.5 效果"></a>2.3.5 效果</h3><p><img src="/images/vim_5.jpeg" alt="vim_5"></p><h2 id="2-4-辅助"><a href="#2-4-辅助" class="headerlink" title="2.4 辅助"></a>2.4 辅助</h2><h3 id="2-4-1-目录树和注释"><a href="#2-4-1-目录树和注释" class="headerlink" title="2.4.1 目录树和注释"></a>2.4.1 目录树和注释</h3><p>目录插件: <a href="https://github.com/preservim/nerdtree">nerdtree</a><br>注释插件: <a href="https://github.com/scrooloose/nerdcommenter">nerdcommenter</a></p><ul><li><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">call plug#begin(&#39;~&#x2F;.vim&#x2F;plugged&#39;)</span><br><span class="line">    Plug &#39;scrooloose&#x2F;nerdtree&#39;                          &quot; 目录树</span><br><span class="line">    Plug &#39;scrooloose&#x2F;nerdcommenter&#39;                     &quot; 注释</span><br><span class="line">call plug#end()</span><br></pre></td></tr></table></figure></li><li><p>配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&quot; NERDTree &#123;</span><br><span class="line"></span><br><span class="line">nmap &lt;leader&gt;n :NERDTreeToggle&lt;CR&gt;</span><br><span class="line">&quot; map &lt;F4&gt; :NERDTreeToggle&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">&quot;设置NERDTree的宽度</span><br><span class="line">let NERDTreeWinSize&#x3D;30</span><br><span class="line">let g:NERDTreeWinPos&#x3D;&#39;left&#39;</span><br><span class="line"></span><br><span class="line">let g:NERDTreeShowIgnoredStatus&#x3D;1</span><br><span class="line"></span><br><span class="line">let g:NERDTreeDirArrowExpandable &#x3D; &#39;+&#39;</span><br><span class="line">let g:NERDTreeDirArrowCollapsible &#x3D; &#39;-&#39;</span><br><span class="line"></span><br><span class="line">&quot; &#125;</span><br><span class="line"></span><br><span class="line">&quot; nerdcommenter &#123;</span><br><span class="line"></span><br><span class="line">let g:NERDSpaceDelims&#x3D;1 &quot; 注释后加空格</span><br><span class="line"></span><br><span class="line">&quot; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>快捷键</p></li></ul><table><thead><tr><th>功能</th><th>快捷键</th></tr></thead><tbody><tr><td>打开关闭目录</td><td>leader键+n</td></tr><tr><td>注释</td><td>leader键+c</td></tr></tbody></table><h3 id="2-4-2-补全括号"><a href="#2-4-2-补全括号" class="headerlink" title="2.4.2 补全括号"></a>2.4.2 补全括号</h3><p>在vim执行<code>:CocInstall coc-pairs</code></p><h3 id="2-4-3-全局搜索"><a href="#2-4-3-全局搜索" class="headerlink" title="2.4.3 全局搜索"></a>2.4.3 全局搜索</h3><p>插件: <a href="https://github.com/Yggdroot/LeaderF">LeaderF</a></p><ul><li><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call plug#begin(&#39;~&#x2F;.vim&#x2F;plugged&#39;)</span><br><span class="line">    Plug &#39;Yggdroot&#x2F;LeaderF&#39;, &#123; &#39;tag&#39;: &#39;v1.22&#39;, &#39;do&#39;: &#39;.&#x2F;install.sh&#39; &#125;   &quot; 全局搜索</span><br><span class="line">call plug#end()</span><br></pre></td></tr></table></figure></li><li><p>配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot; LeaderF &#123;</span><br><span class="line"></span><br><span class="line">let g:Lf_ShortcutF&#x3D;&#39;&lt;C-P&gt;&#39;</span><br><span class="line">&quot; let g:Lf_ShowDevIcons&#x3D;0</span><br><span class="line"></span><br><span class="line">&quot; &#125;</span><br></pre></td></tr></table></figure></li><li><p>快捷键</p></li></ul><table><thead><tr><th>功能</th><th>快捷键</th></tr></thead><tbody><tr><td>文件搜索</td><td>leader键+p或者:LeaderfFile</td></tr><tr><td>函数目录</td><td>:LeaderfFunction</td></tr><tr><td>已打开文件跳转</td><td>:LeaderfBuffer</td></tr><tr><td>变量搜索</td><td>::LeaderfRgInteractive</td></tr></tbody></table><ul><li>成品图<br><img src="/images/vim_2.jpeg" alt="vim_2"></li></ul><h2 id="2-5-美化"><a href="#2-5-美化" class="headerlink" title="2.5 美化"></a>2.5 美化</h2><h3 id="2-5-1-主题"><a href="#2-5-1-主题" class="headerlink" title="2.5.1 主题"></a>2.5.1 主题</h3><p><a href="https://github.com/joshdick/onedark.vim">onedark</a></p><ul><li>安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call plug#begin(&#39;~&#x2F;.vim&#x2F;plugged&#39;)</span><br><span class="line">    Plug &#39;joshdick&#x2F;onedark.vim&#39;</span><br><span class="line">call plug#end()</span><br></pre></td></tr></table></figure></li><li>配置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&quot; Colorscheme &#123;</span><br><span class="line"></span><br><span class="line">&quot; 语法高亮</span><br><span class="line">syntax  on</span><br><span class="line"></span><br><span class="line">&quot; 文件类型带上颜色</span><br><span class="line">syntax  enable</span><br><span class="line"></span><br><span class="line">&quot; 文件类型探测 使用缩进文件</span><br><span class="line">filetype plugin indent on</span><br><span class="line"></span><br><span class="line">set background&#x3D;light</span><br><span class="line"></span><br><span class="line">&quot; 设置主题</span><br><span class="line">colorscheme onedark</span><br><span class="line"></span><br><span class="line">&quot; Set the vertical split character to  a space (there is a single space after &#39;\ &#39;)</span><br><span class="line">set fillchars+&#x3D;vert:\ </span><br><span class="line">highlight VertSplit ctermbg&#x3D;236 ctermfg&#x3D;236</span><br><span class="line"></span><br><span class="line">&quot; &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-5-2-状态栏"><a href="#2-5-2-状态栏" class="headerlink" title="2.5.2 状态栏"></a>2.5.2 状态栏</h3><p><a href="https://github.com/vim-airline/vim-airline">vim-airline</a></p><ul><li><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call plug#begin(&#39;~&#x2F;.vim&#x2F;plugged&#39;)</span><br><span class="line">    Plug &#39;vim-airline&#x2F;vim-airline&#39;</span><br><span class="line">call plug#end()</span><br></pre></td></tr></table></figure></li><li><p>配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&quot; vim-airline &#123;</span><br><span class="line"></span><br><span class="line">if !exists(&#39;g:airline_symbols&#39;)</span><br><span class="line">    let g:airline_symbols&#x3D;&#123;&#125;</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">let airline#extensions#tabline#ignore_bufadd_pat &#x3D;</span><br><span class="line">            \ &#39;\c\vgundo|undotree|vimfiler|tagbar|nerd_tree&#39;</span><br><span class="line">let g:airline#extensions#tabline#keymap_ignored_filetypes &#x3D;</span><br><span class="line">            \ [&#39;vimfiler&#39;, &#39;nerdtree&#39;]</span><br><span class="line"></span><br><span class="line">let g:airline#extensions#tabline#left_sep &#x3D; &#39;&#39;</span><br><span class="line">let g:airline#extensions#tabline#left_alt_sep &#x3D; &#39;&#39;</span><br><span class="line">let g:airline#extensions#tabline#right_sep &#x3D; &#39;&#39;</span><br><span class="line">let g:airline#extensions#tabline#right_alt_sep &#x3D; &#39;&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let g:airline_left_sep &#x3D; &#39;&#39;</span><br><span class="line">let g:airline_left_alt_sep &#x3D; &#39;&#39;</span><br><span class="line">let g:airline_right_sep &#x3D; &#39;&#39;</span><br><span class="line">let g:airline_right_alt_sep &#x3D; &#39;&#39;</span><br><span class="line">let g:airline_symbols.branch &#x3D; &#39;&#39;</span><br><span class="line">let g:airline_symbols.readonly &#x3D; &#39;&#39;</span><br><span class="line">let g:airline_symbols.linenr &#x3D; &#39;☰&#39;</span><br><span class="line">let g:airline_symbols.maxlinenr &#x3D; &#39;&#39;</span><br><span class="line">let g:airline_symbols.dirty&#x3D;&#39;⚡&#39;</span><br><span class="line"></span><br><span class="line">&quot; let g:airline_theme&#x3D;&#39;jellybeans&#39;</span><br><span class="line">let g:airline#extensions#tabline#formatter &#x3D; &#39;unique_tail&#39;</span><br><span class="line">&quot; &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-5-3-GIT信息和启动页"><a href="#2-5-3-GIT信息和启动页" class="headerlink" title="2.5.3 GIT信息和启动页"></a>2.5.3 GIT信息和启动页</h3><p><a href="https://github.com/tpope/vim-fugitive">vim-fugitive</a><br><a href="https://github.com/mhinz/vim-startify">vim-startify</a></p><ul><li><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">call plug#begin(&#39;~&#x2F;.vim&#x2F;plugged&#39;)</span><br><span class="line">    Plug &#39;tpope&#x2F;vim-fugitive&#39;                           &quot; 显示git分支</span><br><span class="line">    Plug &#39;mhinz&#x2F;vim-startify&#39;                           &quot; 启动界面</span><br><span class="line">call plug#end()</span><br></pre></td></tr></table></figure></li><li><p>效果<br><img src="/images/vim_4.jpeg" alt="vim_4"></p></li></ul><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="完整配置"><a href="#完整配置" class="headerlink" title="完整配置"></a>完整配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br></pre></td><td class="code"><pre><span class="line">&quot; Common config &#123;</span><br><span class="line"></span><br><span class="line">&quot; 设置行号</span><br><span class="line">set number</span><br><span class="line"></span><br><span class="line">&quot; 不生成备份文件</span><br><span class="line">set nobackup </span><br><span class="line"></span><br><span class="line">&quot; 不创建临时交换文件</span><br><span class="line">set noswapfile     </span><br><span class="line"></span><br><span class="line">&quot; 右下角显示光标位置</span><br><span class="line">set ruler</span><br><span class="line"></span><br><span class="line">&quot; 查找不区分大小写</span><br><span class="line">set ignorecase</span><br><span class="line"></span><br><span class="line">&quot; 查找高亮</span><br><span class="line">set hlsearch</span><br><span class="line"></span><br><span class="line">&quot; 启用256色</span><br><span class="line">&quot; set t_Co&#x3D;16</span><br><span class="line"></span><br><span class="line">&quot; 不兼容VI</span><br><span class="line">set nocompatible</span><br><span class="line"></span><br><span class="line">&quot; 设置保存历史(命令, 查找模式的历史</span><br><span class="line">set history&#x3D;1024</span><br><span class="line"></span><br><span class="line">&quot; 右下角显示未完成的命令 </span><br><span class="line">set showcmd</span><br><span class="line"></span><br><span class="line">&quot; 再输入部分查找模式时显示相应的匹配点 </span><br><span class="line">set incsearch</span><br><span class="line"></span><br><span class="line">&quot; 使用UTF-8编码</span><br><span class="line">set encoding&#x3D;utf-8</span><br><span class="line"></span><br><span class="line">&quot; 所在行高亮</span><br><span class="line">&quot; set cursorcolumn</span><br><span class="line">set cursorline</span><br><span class="line"></span><br><span class="line">&quot; 相对行号</span><br><span class="line">&quot; set relativenumber</span><br><span class="line"></span><br><span class="line">&quot; 使用鼠标</span><br><span class="line">&quot; set mouse&#x3D;a</span><br><span class="line"></span><br><span class="line">&quot; 显示TAB键</span><br><span class="line">&quot; set list</span><br><span class="line"></span><br><span class="line">&quot; 自动保存</span><br><span class="line">&quot; set autowrite</span><br><span class="line"></span><br><span class="line">&quot; 设置n个字自动换行</span><br><span class="line">&quot; set textwidth&#x3D;n</span><br><span class="line"></span><br><span class="line">set foldmethod&#x3D;syntax</span><br><span class="line"></span><br><span class="line">set nofoldenable</span><br><span class="line"></span><br><span class="line">&quot; 设置leader键</span><br><span class="line">let mapleader&#x3D;&quot;\&lt;space&gt;&quot;</span><br><span class="line"></span><br><span class="line">&quot; 恢复光标位置</span><br><span class="line">if has(&quot;autocmd&quot;)</span><br><span class="line">    au BufReadPost * if line(&quot;&#39;\&quot;&quot;) &gt; 1 &amp;&amp; line(&quot;&#39;\&quot;&quot;) &lt;&#x3D; line(&quot;$&quot;) | exe &quot;normal! g&#39;\&quot;&quot; | endif</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">&quot; 右侧打开内置terminal</span><br><span class="line">nmap &lt;leader&gt;t :rightbelow vert term&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">&quot; &#125;</span><br><span class="line"></span><br><span class="line">&quot; Plugin Management &#123;</span><br><span class="line"></span><br><span class="line">filetype off</span><br><span class="line">call plug#begin(&#39;~&#x2F;.vim&#x2F;plugged&#39;)</span><br><span class="line">    Plug &#39;scrooloose&#x2F;nerdtree&#39;                          &quot; 目录树</span><br><span class="line">    Plug &#39;scrooloose&#x2F;nerdcommenter&#39;                     &quot; 注释</span><br><span class="line">    Plug &#39;vim-airline&#x2F;vim-airline&#39;                      &quot; Vim状态栏插件，包括显示行号，列号，文件类型，文件名，以及Git状态</span><br><span class="line">    Plug &#39;tpope&#x2F;vim-fugitive&#39;                           &quot; 显示git分支</span><br><span class="line">    Plug &#39;Yggdroot&#x2F;LeaderF&#39;, &#123; &#39;tag&#39;: &#39;v1.22&#39;, &#39;do&#39;: &#39;.&#x2F;install.sh&#39; &#125;   &quot; 全局搜索</span><br><span class="line">    Plug &#39;fatih&#x2F;vim-go&#39;, &#123; &#39;do&#39;: &#39;:GoUpdateBinaries&#39; &#125;  &quot; vim-go</span><br><span class="line">    Plug &#39;yianwillis&#x2F;vimcdoc&#39;                           &quot; 中文文档</span><br><span class="line">    Plug &#39;neoclide&#x2F;coc.nvim&#39;, &#123;&#39;branch&#39;: &#39;release&#39;&#125;     &quot; 补全</span><br><span class="line">    Plug &#39;octol&#x2F;vim-cpp-enhanced-highlight&#39;             &quot; C++高亮</span><br><span class="line">    Plug &#39;mhinz&#x2F;vim-startify&#39;                           &quot; 启动界面</span><br><span class="line">call plug#end()</span><br><span class="line"></span><br><span class="line">&quot; coc-nvim &#123;</span><br><span class="line"></span><br><span class="line">&quot; TextEdit might fail if hidden is not set.</span><br><span class="line">set hidden</span><br><span class="line"></span><br><span class="line">&quot; Some servers have issues with backup files, see #649.</span><br><span class="line">set nobackup</span><br><span class="line">set nowritebackup</span><br><span class="line"></span><br><span class="line">&quot; Give more space for displaying messages.</span><br><span class="line">set cmdheight&#x3D;1</span><br><span class="line"></span><br><span class="line">&quot; Having longer updatetime (default is 4000 ms &#x3D; 4 s) leads to noticeable</span><br><span class="line">&quot; delays and poor user experience.</span><br><span class="line">set updatetime&#x3D;300</span><br><span class="line"></span><br><span class="line">&quot; Don&#39;t pass messages to |ins-completion-menu|.</span><br><span class="line">set shortmess+&#x3D;c</span><br><span class="line"></span><br><span class="line">&quot; Always show the signcolumn, otherwise it would shift the text each time</span><br><span class="line">&quot; diagnostics appear&#x2F;become resolved.</span><br><span class="line">if has(&quot;patch-8.1.1564&quot;)</span><br><span class="line">  &quot; Recently vim can merge signcolumn and number column into one</span><br><span class="line">  set signcolumn&#x3D;number</span><br><span class="line">else</span><br><span class="line">  set signcolumn&#x3D;yes</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">&quot; Use tab for trigger completion with characters ahead and navigate.</span><br><span class="line">&quot; NOTE: Use command &#39;:verbose imap &lt;tab&gt;&#39; to make sure tab is not mapped by</span><br><span class="line">&quot; other plugin before putting this into your config.</span><br><span class="line">inoremap &lt;silent&gt;&lt;expr&gt; &lt;TAB&gt;</span><br><span class="line">      \ pumvisible() ? &quot;\&lt;C-n&gt;&quot; :</span><br><span class="line">      \ &lt;SID&gt;check_back_space() ? &quot;\&lt;TAB&gt;&quot; :</span><br><span class="line">      \ coc#refresh()</span><br><span class="line">inoremap &lt;expr&gt;&lt;S-TAB&gt; pumvisible() ? &quot;\&lt;C-p&gt;&quot; : &quot;\&lt;C-h&gt;&quot;</span><br><span class="line"></span><br><span class="line">function! s:check_back_space() abort</span><br><span class="line">  let col &#x3D; col(&#39;.&#39;) - 1</span><br><span class="line">  return !col || getline(&#39;.&#39;)[col - 1]  &#x3D;~# &#39;\s&#39;</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">&quot; Use &lt;c-space&gt; to trigger completion.</span><br><span class="line">if has(&#39;nvim&#39;)</span><br><span class="line">  inoremap &lt;silent&gt;&lt;expr&gt; &lt;c-space&gt; coc#refresh()</span><br><span class="line">else</span><br><span class="line">  inoremap &lt;silent&gt;&lt;expr&gt; &lt;c-@&gt; coc#refresh()</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">&quot; Use &lt;cr&gt; to confirm completion, &#96;&lt;C-g&gt;u&#96; means break undo chain at current</span><br><span class="line">&quot; position. Coc only does snippet and additional edit on confirm.</span><br><span class="line">&quot; &lt;cr&gt; could be remapped by other vim plugin, try &#96;:verbose imap &lt;CR&gt;&#96;.</span><br><span class="line">if exists(&#39;*complete_info&#39;)</span><br><span class="line">  inoremap &lt;expr&gt; &lt;cr&gt; complete_info()[&quot;selected&quot;] !&#x3D; &quot;-1&quot; ? &quot;\&lt;C-y&gt;&quot; : &quot;\&lt;C-g&gt;u\&lt;CR&gt;&quot;</span><br><span class="line">else</span><br><span class="line">  inoremap &lt;expr&gt; &lt;cr&gt; pumvisible() ? &quot;\&lt;C-y&gt;&quot; : &quot;\&lt;C-g&gt;u\&lt;CR&gt;&quot;</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">&quot; Use &#96;[g&#96; and &#96;]g&#96; to navigate diagnostics</span><br><span class="line">&quot; Use &#96;:CocDiagnostics&#96; to get all diagnostics of current buffer in location list.</span><br><span class="line">nmap &lt;silent&gt; [g &lt;Plug&gt;(coc-diagnostic-prev)</span><br><span class="line">nmap &lt;silent&gt; ]g &lt;Plug&gt;(coc-diagnostic-next)</span><br><span class="line"></span><br><span class="line">&quot; GoTo code navigation.</span><br><span class="line">nmap &lt;silent&gt; gd &lt;Plug&gt;(coc-definition)</span><br><span class="line">nmap &lt;silent&gt; gy &lt;Plug&gt;(coc-type-definition)</span><br><span class="line">nmap &lt;silent&gt; gi &lt;Plug&gt;(coc-implementation)</span><br><span class="line">nmap &lt;silent&gt; gr &lt;Plug&gt;(coc-references)</span><br><span class="line"></span><br><span class="line">&quot; Use K to show documentation in preview window.</span><br><span class="line">nnoremap &lt;silent&gt; K :call &lt;SID&gt;show_documentation()&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">function! s:show_documentation()</span><br><span class="line">  if (index([&#39;vim&#39;,&#39;help&#39;], &amp;filetype) &gt;&#x3D; 0)</span><br><span class="line">    execute &#39;h &#39;.expand(&#39;&lt;cword&gt;&#39;)</span><br><span class="line">  else</span><br><span class="line">    call CocActionAsync(&#39;doHover&#39;)</span><br><span class="line">  endif</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">&quot; Highlight the symbol and its references when holding the cursor.</span><br><span class="line">autocmd CursorHold * silent call CocActionAsync(&#39;highlight&#39;)</span><br><span class="line"></span><br><span class="line">&quot; Symbol renaming.</span><br><span class="line">nmap &lt;leader&gt;rn &lt;Plug&gt;(coc-rename)</span><br><span class="line"></span><br><span class="line">&quot; Formatting selected code.</span><br><span class="line">xmap &lt;leader&gt;f  &lt;Plug&gt;(coc-format-selected)</span><br><span class="line">nmap &lt;leader&gt;f  &lt;Plug&gt;(coc-format-selected)</span><br><span class="line"></span><br><span class="line">augroup mygroup</span><br><span class="line">  autocmd!</span><br><span class="line">  &quot; Setup formatexpr specified filetype(s).</span><br><span class="line">  autocmd FileType typescript,json setl formatexpr&#x3D;CocAction(&#39;formatSelected&#39;)</span><br><span class="line">  &quot; Update signature help on jump placeholder.</span><br><span class="line">  autocmd User CocJumpPlaceholder call CocActionAsync(&#39;showSignatureHelp&#39;)</span><br><span class="line">augroup end</span><br><span class="line"></span><br><span class="line">&quot; Applying codeAction to the selected region.</span><br><span class="line">&quot; Example: &#96;&lt;leader&gt;aap&#96; for current paragraph</span><br><span class="line">xmap &lt;leader&gt;a  &lt;Plug&gt;(coc-codeaction-selected)</span><br><span class="line">nmap &lt;leader&gt;a  &lt;Plug&gt;(coc-codeaction-selected)</span><br><span class="line"></span><br><span class="line">&quot; Remap keys for applying codeAction to the current buffer.</span><br><span class="line">nmap &lt;leader&gt;ac  &lt;Plug&gt;(coc-codeaction)</span><br><span class="line">&quot; Apply AutoFix to problem on the current line.</span><br><span class="line">nmap &lt;leader&gt;qf  &lt;Plug&gt;(coc-fix-current)</span><br><span class="line"></span><br><span class="line">&quot; Map function and class text objects</span><br><span class="line">&quot; NOTE: Requires &#39;textDocument.documentSymbol&#39; support from the language server.</span><br><span class="line">xmap if &lt;Plug&gt;(coc-funcobj-i)</span><br><span class="line">omap if &lt;Plug&gt;(coc-funcobj-i)</span><br><span class="line">xmap af &lt;Plug&gt;(coc-funcobj-a)</span><br><span class="line">omap af &lt;Plug&gt;(coc-funcobj-a)</span><br><span class="line">xmap ic &lt;Plug&gt;(coc-classobj-i)</span><br><span class="line">omap ic &lt;Plug&gt;(coc-classobj-i)</span><br><span class="line">xmap ac &lt;Plug&gt;(coc-classobj-a)</span><br><span class="line">omap ac &lt;Plug&gt;(coc-classobj-a)</span><br><span class="line"></span><br><span class="line">&quot; Use CTRL-S for selections ranges.</span><br><span class="line">&quot; Requires &#39;textDocument&#x2F;selectionRange&#39; support of language server.</span><br><span class="line">nmap &lt;silent&gt; &lt;C-s&gt; &lt;Plug&gt;(coc-range-select)</span><br><span class="line">xmap &lt;silent&gt; &lt;C-s&gt; &lt;Plug&gt;(coc-range-select)</span><br><span class="line"></span><br><span class="line">&quot; Add &#96;:Format&#96; command to format current buffer.</span><br><span class="line">command! -nargs&#x3D;0 Format :call CocAction(&#39;format&#39;)</span><br><span class="line"></span><br><span class="line">&quot; Add &#96;:Fold&#96; command to fold current buffer.</span><br><span class="line">command! -nargs&#x3D;? Fold :call     CocAction(&#39;fold&#39;, &lt;f-args&gt;)</span><br><span class="line"></span><br><span class="line">&quot; Add &#96;:OR&#96; command for organize imports of the current buffer.</span><br><span class="line">command! -nargs&#x3D;0 OR   :call     CocAction(&#39;runCommand&#39;, &#39;editor.action.organizeImport&#39;)</span><br><span class="line"></span><br><span class="line">&quot; Add (Neo)Vim&#39;s native statusline support.</span><br><span class="line">&quot; NOTE: Please see &#96;:h coc-status&#96; for integrations with external plugins that</span><br><span class="line">&quot; provide custom statusline: lightline.vim, vim-airline.</span><br><span class="line">&quot; set statusline^&#x3D;%&#123;coc#status()&#125;%&#123;get(b:,&#39;coc_current_function&#39;,&#39;&#39;)&#125;</span><br><span class="line"></span><br><span class="line">&quot; Mappings for CoCList</span><br><span class="line">&quot; Show all diagnostics.</span><br><span class="line">nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;a  :&lt;C-u&gt;CocList diagnostics&lt;cr&gt;</span><br><span class="line">&quot; Manage extensions.</span><br><span class="line">nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;e  :&lt;C-u&gt;CocList extensions&lt;cr&gt;</span><br><span class="line">&quot; Show commands.</span><br><span class="line">nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;c  :&lt;C-u&gt;CocList commands&lt;cr&gt;</span><br><span class="line">&quot; Find symbol of current document.</span><br><span class="line">nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;o  :&lt;C-u&gt;CocList outline&lt;cr&gt;</span><br><span class="line">&quot; Search workspace symbols.</span><br><span class="line">nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;s  :&lt;C-u&gt;CocList -I symbols&lt;cr&gt;</span><br><span class="line">&quot; Do default action for next item.</span><br><span class="line">nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;j  :&lt;C-u&gt;CocNext&lt;CR&gt;</span><br><span class="line">&quot; Do default action for previous item.</span><br><span class="line">nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;k  :&lt;C-u&gt;CocPrev&lt;CR&gt;</span><br><span class="line">&quot; Resume latest coc list.</span><br><span class="line">nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;p  :&lt;C-u&gt;CocListResume&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">&quot; &#125;</span><br><span class="line"></span><br><span class="line">&quot; Colorscheme &#123;</span><br><span class="line"></span><br><span class="line">&quot; 语法高亮</span><br><span class="line">syntax  on</span><br><span class="line"></span><br><span class="line">&quot; 文件类型带上颜色</span><br><span class="line">syntax  enable</span><br><span class="line"></span><br><span class="line">&quot; 文件类型探测 使用缩进文件</span><br><span class="line">filetype plugin indent on</span><br><span class="line"></span><br><span class="line">set background&#x3D;light</span><br><span class="line"></span><br><span class="line">&quot; 设置主题</span><br><span class="line">colorscheme onedark</span><br><span class="line"></span><br><span class="line">&quot; Set the vertical split character to  a space (there is a single space after &#39;\ &#39;)</span><br><span class="line">set fillchars+&#x3D;vert:\ </span><br><span class="line">highlight VertSplit ctermbg&#x3D;236 ctermfg&#x3D;236</span><br><span class="line"></span><br><span class="line">&quot; &#125;</span><br><span class="line"></span><br><span class="line">&quot; vim-go &#123;</span><br><span class="line"></span><br><span class="line">let g:go_fmt_command&#x3D;&quot;goimports&quot; &quot; 格式化将默认的 gofmt 替换</span><br><span class="line">let g:go_info_mode&#x3D;&#39;gopls&#39;</span><br><span class="line">let g:go_def_mode&#x3D;&#39;gopls&#39;</span><br><span class="line">let g:go_rename_command&#x3D;&#39;gopls&#39;  &quot; 重命名变量</span><br><span class="line">let g:go_referrers_mode&#x3D;&#39;gopls&#39;</span><br><span class="line"></span><br><span class="line">let g:go_autodetect_gopath&#x3D;1</span><br><span class="line">let g:go_list_type&#x3D;&quot;quickfix&quot;</span><br><span class="line">let g:go_version_warning&#x3D;1</span><br><span class="line">let g:go_highlight_types&#x3D;1</span><br><span class="line">let g:go_highlight_fields&#x3D;1</span><br><span class="line">let g:go_highlight_functions&#x3D;1</span><br><span class="line">let g:go_highlight_function_calls&#x3D;1</span><br><span class="line">let g:go_highlight_operators&#x3D;1</span><br><span class="line">let g:go_highlight_extra_types&#x3D;1</span><br><span class="line">let g:go_highlight_methods&#x3D;1</span><br><span class="line">let g:go_highlight_generate_tags&#x3D;1</span><br><span class="line">let g:go_highlight_function_parameters &#x3D; 1</span><br><span class="line">let g:go_highlight_build_constraints &#x3D; 1</span><br><span class="line"></span><br><span class="line">let g:godef_split&#x3D;2</span><br><span class="line"></span><br><span class="line">&quot; push quickfix window always to the bottom</span><br><span class="line">autocmd FileType qf wincmd J</span><br><span class="line"></span><br><span class="line">&quot; &#125;</span><br><span class="line"></span><br><span class="line">&quot; LeaderF &#123;</span><br><span class="line"></span><br><span class="line">let g:Lf_ShortcutF&#x3D;&#39;&lt;C-P&gt;&#39;</span><br><span class="line">&quot; let g:Lf_ShowDevIcons&#x3D;0</span><br><span class="line"></span><br><span class="line">&quot; &#125;</span><br><span class="line"></span><br><span class="line">&quot; NERDTree &#123;</span><br><span class="line"></span><br><span class="line">nmap &lt;leader&gt;n :NERDTreeToggle&lt;CR&gt;</span><br><span class="line">&quot; map &lt;F4&gt; :NERDTreeToggle&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">&quot;设置NERDTree的宽度</span><br><span class="line">let NERDTreeWinSize&#x3D;30</span><br><span class="line">let g:NERDTreeWinPos&#x3D;&#39;left&#39;</span><br><span class="line"></span><br><span class="line">let g:NERDTreeShowIgnoredStatus&#x3D;1</span><br><span class="line"></span><br><span class="line">let g:NERDTreeDirArrowExpandable &#x3D; &#39;+&#39;</span><br><span class="line">let g:NERDTreeDirArrowCollapsible &#x3D; &#39;-&#39;</span><br><span class="line">&quot;  *        </span><br><span class="line"></span><br><span class="line">&quot; &#125;</span><br><span class="line"></span><br><span class="line">&quot; vim-airline &#123;</span><br><span class="line"></span><br><span class="line">if !exists(&#39;g:airline_symbols&#39;)</span><br><span class="line">    let g:airline_symbols&#x3D;&#123;&#125;</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">let airline#extensions#tabline#ignore_bufadd_pat &#x3D;</span><br><span class="line">            \ &#39;\c\vgundo|undotree|vimfiler|tagbar|nerd_tree&#39;</span><br><span class="line">let g:airline#extensions#tabline#keymap_ignored_filetypes &#x3D;</span><br><span class="line">            \ [&#39;vimfiler&#39;, &#39;nerdtree&#39;]</span><br><span class="line"></span><br><span class="line">let g:airline#extensions#tabline#left_sep &#x3D; &#39;&#39;</span><br><span class="line">let g:airline#extensions#tabline#left_alt_sep &#x3D; &#39;&#39;</span><br><span class="line">let g:airline#extensions#tabline#right_sep &#x3D; &#39;&#39;</span><br><span class="line">let g:airline#extensions#tabline#right_alt_sep &#x3D; &#39;&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let g:airline_left_sep &#x3D; &#39;&#39;</span><br><span class="line">let g:airline_left_alt_sep &#x3D; &#39;&#39;</span><br><span class="line">let g:airline_right_sep &#x3D; &#39;&#39;</span><br><span class="line">let g:airline_right_alt_sep &#x3D; &#39;&#39;</span><br><span class="line">let g:airline_symbols.branch &#x3D; &#39;&#39;</span><br><span class="line">let g:airline_symbols.readonly &#x3D; &#39;&#39;</span><br><span class="line">let g:airline_symbols.linenr &#x3D; &#39;☰&#39;</span><br><span class="line">let g:airline_symbols.maxlinenr &#x3D; &#39;&#39;</span><br><span class="line">let g:airline_symbols.dirty&#x3D;&#39;⚡&#39;</span><br><span class="line"></span><br><span class="line">&quot; let g:airline_theme&#x3D;&#39;jellybeans&#39;</span><br><span class="line">let g:airline#extensions#tabline#formatter &#x3D; &#39;unique_tail&#39;</span><br><span class="line">&quot; &#125;</span><br><span class="line"></span><br><span class="line">&quot; nerdcommenter &#123;</span><br><span class="line"></span><br><span class="line">let g:NERDSpaceDelims&#x3D;1 &quot; 注释后加空格</span><br><span class="line"></span><br><span class="line">&quot; &#125;</span><br><span class="line"></span><br><span class="line">&quot; Compile &#123;</span><br><span class="line"></span><br><span class="line">command! -nargs&#x3D;0 CodeForces :call RunCXXCodeForces()</span><br><span class="line">command! -nargs&#x3D;0 CxxRun :call RunCPP()</span><br><span class="line">command! -nargs&#x3D;0 ShellRun :call RunSH()</span><br><span class="line"></span><br><span class="line">&quot; shell</span><br><span class="line">func! RunSH()</span><br><span class="line">    exec &quot;w&quot;</span><br><span class="line">    exec &quot;!sh .&#x2F;%&quot;</span><br><span class="line">endfunc</span><br><span class="line"></span><br><span class="line">&quot; CXX</span><br><span class="line">func! RunCPP()</span><br><span class="line">    exec &quot;w&quot;</span><br><span class="line">    exec &quot;!g++ % -std&#x3D;c++17 -o %&lt;&quot;</span><br><span class="line">    exec &quot;! .&#x2F;%&lt;&quot;</span><br><span class="line">endfunc</span><br><span class="line"></span><br><span class="line">&quot; codeforces</span><br><span class="line">func! RunCXXCodeForces()</span><br><span class="line">    exec &quot;w&quot;</span><br><span class="line">    exec &quot;!g++ % -std&#x3D;c++17 -o %&lt;&quot;</span><br><span class="line">    exec &quot;! .&#x2F;%&lt; &lt; in&quot;</span><br><span class="line">endfunc</span><br><span class="line">&quot; &#125;</span><br><span class="line"></span><br><span class="line">&quot; Code Style &#123;</span><br><span class="line"></span><br><span class="line">autocmd FileType cpp,c,yaml exec &quot;:call SetCppFileConfig()&quot; </span><br><span class="line">autocmd FileType go,bash,python,java,html,javascipt,vim,sh,dot exec &quot;:call SetCommonFileConfig()&quot;</span><br><span class="line"></span><br><span class="line">func SetCppFileConfig()</span><br><span class="line">    &quot; 设置tab为2个空格</span><br><span class="line">    set tabstop&#x3D;2</span><br><span class="line"></span><br><span class="line">    &quot; 设置缩进为2个空格</span><br><span class="line">    set shiftwidth&#x3D;2</span><br><span class="line"></span><br><span class="line">    &quot; 用space替代tab的输入</span><br><span class="line">    set expandtab  </span><br><span class="line">endfunc</span><br><span class="line"></span><br><span class="line">func SetCommonFileConfig()</span><br><span class="line">    &quot; 设置tab为4个空格</span><br><span class="line">    set tabstop&#x3D;4</span><br><span class="line"></span><br><span class="line">    &quot; 设置缩进为4个空格</span><br><span class="line">    set shiftwidth&#x3D;4</span><br><span class="line"></span><br><span class="line">    &quot; 用space替代tab的输入</span><br><span class="line">    set expandtab  </span><br><span class="line"></span><br><span class="line">endfunc</span><br><span class="line"></span><br><span class="line">&quot; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nmap &lt;F8&gt; :!dot % -T png -Gsize&#x3D;4,6\! -Gdpi&#x3D;50 -o %&lt;.png &amp;&amp; open %&lt;.png &lt;CR&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;作为一个初学者，很多同学的路子都是这样的：费劲心思装好windows和Linux双系统，看着Linux界面难看，开始找美化软件的工具；美化好了，安装好了g++，因为gedit不好用，sublimetext、atom好用但是不太方便编译，然后陷入vim还是emacs的抉择；最终决定用vim，打印了一张vim键盘图开始学习，略为抱怨门槛高；入门之后发现写代码确实快了很多，为了更快，更美观，开始折腾vim的插件，学习怎么打tag等等等等…感觉万事具备，只欠好好学c++了，发现需要学习g++的编译连接，库文件，多个源文件，大工程，然后开始学习makefile的写法…从此越跑越偏，后来突然发现python看起来简单，要不学python吧。后来又觉得python似乎找工作不占很大优势，转而学java。后来又觉得javascript更简单，所以搞前端吧。然后发现还需要学html、css、数据库、日新月异的新框架…一本书，《c++从入门到放弃》。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;1-最终成品&quot;&gt;&lt;a href=&quot;#1-最终成品&quot; class=&quot;headerlink&quot; title=&quot;1. 最终成品&quot;&gt;&lt;/a&gt;1. 最终成品&lt;/h1&gt;&lt;p&gt;先给大家看看成品的样子&lt;br&gt;&lt;img src=&quot;/images/vim_0.jpeg&quot; alt=&quot;vim_0.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;2-所见即所得&quot;&gt;&lt;a href=&quot;#2-所见即所得&quot; class=&quot;headerlink&quot; title=&quot;2. 所见即所得&quot;&gt;&lt;/a&gt;2. 所见即所得&lt;/h1&gt;&lt;p&gt;折腾vim大概有四五年的时间了，下面总结了想要将vim作为主开发工具需要的条件。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类别&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;开发&lt;/td&gt;
&lt;td&gt;代码跳转&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;查看引用&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;代码补全&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;查找替换&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;变量、函数更名&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;辅助&lt;/td&gt;
&lt;td&gt;文件目录&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;函数目录&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;注释&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;全局搜索文件&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;全局搜索关键词&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;补全括号&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;美化&lt;/td&gt;
&lt;td&gt;主题&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;状态栏&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Git信息&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;启动页美化&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&quot;2-1-准备&quot;&gt;&lt;a href=&quot;#2-1-准备&quot; class=&quot;headerlink&quot; title=&quot;2.1 准备&quot;&gt;&lt;/a&gt;2.1 准备&lt;/h2&gt;&lt;p&gt;很多插件在neo-vim下支持更好，但是寡人是个念旧的人，所以一直用【&lt;em&gt;VIM - Vi IMproved 8.2&lt;/em&gt;】&lt;br&gt;所以在开始配置之前，需要准备vim 8.0以上版本并且支持python3&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git clone https:&amp;#x2F;&amp;#x2F;github.com&amp;#x2F;vim&amp;#x2F;vim.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd vim&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.&amp;#x2F;configure --with-features&amp;#x3D;huge \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	--enable-multibyte \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	--enable-python3interp&amp;#x3D;yes \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	--with-python3-config-dir&amp;#x3D;[你机器上python3的路径] \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	--enable-gui&amp;#x3D;gtk2 \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	--enable-cscope \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	--prefix&amp;#x3D;&amp;#x2F;usr&amp;#x2F;local&amp;#x2F;vim&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;make&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo make install&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果不知道python3的路径，可以用whereis python3找一下。&lt;br&gt;最终下面的效果就可以了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Golang" scheme="https://journey-c.github.io/tags/Golang/"/>
    
    <category term="vim" scheme="https://journey-c.github.io/tags/vim/"/>
    
    <category term="CXX" scheme="https://journey-c.github.io/tags/CXX/"/>
    
  </entry>
  
  <entry>
    <title>Timing wheel心跳机制</title>
    <link href="https://journey-c.github.io/2020/10/29/timing-wheel/"/>
    <id>https://journey-c.github.io/2020/10/29/timing-wheel/</id>
    <published>2020-10-29T10:06:05.371Z</published>
    <updated>2020-11-14T18:29:10.449Z</updated>
    
    <content type="html"><![CDATA[<p>在web服务中，断开空闲连接是一种减少资源浪费的一种手段，由此就有了心跳机制来判断一个连接是否空闲。</p><h1 id="1-一种简单粗暴的方式："><a href="#1-一种简单粗暴的方式：" class="headerlink" title="1. 一种简单粗暴的方式："></a>1. 一种简单粗暴的方式：</h1><ol><li><p>服务端每个连接保存一个最后一次操作的时间戳，每次这个连接对应fd可读时（客户端发来请求），就更新一下时间戳。</p></li><li><p>服务端会起一个定时任务: close掉在时间戳(now – heart_beat)时刻之前的fd。</p></li></ol><p>这种方式需要不断的遍历已有连接，检查是否过期。</p><p>本文介绍的是，George Varghese 和 Tony Lauck 1996 年的论文《Hashed and Hierarchical Timing Wheels: data structures to efficiently implement a timer facility》中提出了一种时间轮(Timing wheel)管理time out事件的方式。</p><h1 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h1><p>下图是一个时间轮模型，假设当前心跳间隔是4S，将时间轮分为4分，每个格子表示当前格子的剩余寿命(s)。<br><img src="/images/time_wheel_1.png"><br>每隔1S，pointer滚动一次，先清理掉0号格子存放的所有连接，然后当前时刻进来的连接放入(heart_beat – 1)号格子格子。</p><h2 id="2-1-例子"><a href="#2-1-例子" class="headerlink" title="2.1 例子"></a>2.1 例子</h2><p>当前时刻conn 1连入，此时conn1剩余寿命3S，放入3号格子<br><img src="/images/time_wheel_2.png"><br>1S后，此时conn1剩余寿命2S<br><img src="/images/time_wheel_3.png"><br>当conn1剩余寿命为0S时，此连接会被清理。如果恰好这一秒conn进行操作了，那么会放入3号格子另一个conn1，如果时间轮上所有的conn1都被清理，那么这个连接会被关闭。</p><h1 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h1><p>C++以及一些指针友好型语言实现比较简单，轮子转动一次格子的指针引用数-1即可，当某个格子指针引用数为0时，代表格子时间到了，会析构掉。<br>事例代码可见: <a href="https://github.com/lyuc0924/basket/tree/master/forward">journey-c(basket网络库)</a>中workthread的实现。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在web服务中，断开空闲连接是一种减少资源浪费的一种手段，由此就有了心跳机制来判断一个连接是否空闲。&lt;/p&gt;
&lt;h1 id=&quot;1-一种简单粗暴的方式：&quot;&gt;&lt;a href=&quot;#1-一种简单粗暴的方式：&quot; class=&quot;headerlink&quot; title=&quot;1. 一种简单粗暴的方式：&quot;&gt;&lt;/a&gt;1. 一种简单粗暴的方式：&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;服务端每个连接保存一个最后一次操作的时间戳，每次这个连接对应fd可读时（客户端发来请求），就更新一下时间戳。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;服务端会起一个定时任务: close掉在时间戳(now – heart_beat)时刻之前的fd。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这种方式需要不断的遍历已有连接，检查是否过期。&lt;/p&gt;
&lt;p&gt;本文介绍的是，George Varghese 和 Tony Lauck 1996 年的论文《Hashed and Hierarchical Timing Wheels: data structures to efficiently implement a timer facility》中提出了一种时间轮(Timing wheel)管理time out事件的方式。&lt;/p&gt;
&lt;h1 id=&quot;2-原理&quot;&gt;&lt;a href=&quot;#2-原理&quot; class=&quot;headerlink&quot; title=&quot;2. 原理&quot;&gt;&lt;/a&gt;2. 原理&lt;/h1&gt;&lt;p&gt;下图是一个时间轮模型，假设当前心跳间隔是4S，将时间轮分为4分，每个格子表示当前格子的剩余寿命(s)。&lt;br&gt;&lt;img src=&quot;/images/time_wheel_1.png&quot;&gt;&lt;br&gt;每隔1S，pointer滚动一次，先清理掉0号格子存放的所有连接，然后当前时刻进来的连接放入(heart_beat – 1)号格子格子。&lt;/p&gt;
&lt;h2 id=&quot;2-1-例子&quot;&gt;&lt;a href=&quot;#2-1-例子&quot; class=&quot;headerlink&quot; title=&quot;2.1 例子&quot;&gt;&lt;/a&gt;2.1 例子&lt;/h2&gt;&lt;p&gt;当前时刻conn 1连入，此时conn1剩余寿命3S，放入3号格子&lt;br&gt;&lt;img src=&quot;/images/time_wheel_2.png&quot;&gt;&lt;br&gt;1S后，此时conn1剩余寿命2S&lt;br&gt;&lt;img src=&quot;/images/time_wheel_3.png&quot;&gt;&lt;br&gt;当conn1剩余寿命为0S时，此连接会被清理。如果恰好这一秒conn进行操作了，那么会放入3号格子另一个conn1，如果时间轮上所有的conn1都被清理，那么这个连接会被关闭。&lt;/p&gt;
&lt;h1 id=&quot;3-实现&quot;&gt;&lt;a href=&quot;#3-实现&quot; class=&quot;headerlink&quot; title=&quot;3. 实现&quot;&gt;&lt;/a&gt;3. 实现&lt;/h1&gt;</summary>
    
    
    
    
    <category term="工程" scheme="https://journey-c.github.io/tags/%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>关于2的n次幂对齐</title>
    <link href="https://journey-c.github.io/2020/10/29/regarding-the-n-th-power-alignment-of-2/"/>
    <id>https://journey-c.github.io/2020/10/29/regarding-the-n-th-power-alignment-of-2/</id>
    <published>2020-10-29T10:03:36.043Z</published>
    <updated>2020-11-14T18:29:05.282Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1. 应用场景"></a>1. 应用场景</h1><p>内存对齐时基本都会求关于n位对齐的向上取整</p><h1 id="2-讲解"><a href="#2-讲解" class="headerlink" title="2. 讲解"></a>2. 讲解</h1><p>go1.13.8 中channel源码中有这样一个变量<a href="https://github.com/golang/go/blob/885099d1550dad8387013c8f35ad3d4ad9f17c66/src/runtime/chan.go#L28">hchansize</a>用来表示hchan(channel对应的实际结构体)所需大小(申请内存空间时，是根据hchansize给hchan申请对应大小的内存空间)，这个变量的值大概就是hchan的size关于maxAlign向上取整下一个较大倍数，看到源码实现时，就感觉真是怪物。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hchanSize = unsafe.Sizeof(hchan&#123;&#125;) + <span class="keyword">uintptr</span>(-<span class="keyword">int</span>(unsafe.Sizeof(hchan&#123;&#125;))&amp;(maxAlign<span class="number">-1</span>))</span><br></pre></td></tr></table></figure><p>为了方便将上述表达式简化为 n + ( (-n) &amp; (a - 1))，n是unsafe.Sizeof(hchan{})，a是maxAlign。等价于 n + (a - (n % a))</p><p><strong>( (-n) &amp; (a - 1) ) 等价 a - (n % a) ?</strong></p><p>向上取整的问题实际可以转化为求出n距离下一个a的倍数差多少，然后n加上这个数就可以。</p><p>当a为2的n次幂时，n % a可以转化为 n &amp; (a - 1)，取模运算就变成了n与(a - 1) AND时能留下多少个1。</p><p>计算机实际计算时是以<a href="https://www.cnblogs.com/wuwangchuxin0924/p/5851067.html">补码</a>进行运算的，-n转化为补码，符号位不变其他位取反转化为反码，然后最低位+1转化为补码，下面分两步讲。</p><p>以n = 3, a = 8为例(实际计算时是8字节，下面用一字节举例):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原码: -n &#x3D; 1000 0011</span><br><span class="line">反码: -n &#x3D; 1111 1100</span><br><span class="line">此时(-n) &amp; (a - 1)实际为 (a - 1) - n % a，而咱们要求的是a - (n % a)</span><br><span class="line">补码：-n &#x3D; 1111 1101</span><br><span class="line">因为-n的反码变补码时最低位要+1，所以刚好(a - 1) - n % a + 1 &#x3D; a - (n % a)</span><br></pre></td></tr></table></figure><p>所以( (-n) &amp; (a - 1) ) 等价 a - (n % a)</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-应用场景&quot;&gt;&lt;a href=&quot;#1-应用场景&quot; class=&quot;headerlink&quot; title=&quot;1. 应用场景&quot;&gt;&lt;/a&gt;1. 应用场景&lt;/h1&gt;&lt;p&gt;内存对齐时基本都会求关于n位对齐的向上取整&lt;/p&gt;
&lt;h1 id=&quot;2-讲解&quot;&gt;&lt;a href=&quot;#2-讲解&quot; class=&quot;headerlink&quot; title=&quot;2. 讲解&quot;&gt;&lt;/a&gt;2. 讲解&lt;/h1&gt;&lt;p&gt;go1.13.8 中channel源码中有这样一个变量&lt;a href=&quot;https://github.com/golang/go/blob/885099d1550dad8387013c8f35ad3d4ad9f17c66/src/runtime/chan.go#L28&quot;&gt;hchansize&lt;/a&gt;用来表示hchan(channel对应的实际结构体)所需大小(申请内存空间时，是根据hchansize给hchan申请对应大小的内存空间)，这个变量的值大概就是hchan的size关于maxAlign向上取整下一个较大倍数，看到源码实现时，就感觉真是怪物。&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hchanSize = unsafe.Sizeof(hchan&amp;#123;&amp;#125;) + &lt;span class=&quot;keyword&quot;&gt;uintptr&lt;/span&gt;(-&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;(unsafe.Sizeof(hchan&amp;#123;&amp;#125;))&amp;amp;(maxAlign&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;为了方便将上述表达式简化为 n + ( (-n) &amp;amp; (a - 1))，n是unsafe.Sizeof(hchan{})，a是maxAlign。等价于 n + (a - (n % a))&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;( (-n) &amp;amp; (a - 1) ) 等价 a - (n % a) ?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;向上取整的问题实际可以转化为求出n距离下一个a的倍数差多少，然后n加上这个数就可以。&lt;/p&gt;
&lt;p&gt;当a为2的n次幂时，n % a可以转化为 n &amp;amp; (a - 1)，取模运算就变成了n与(a - 1) AND时能留下多少个1。&lt;/p&gt;
&lt;p&gt;计算机实际计算时是以&lt;a href=&quot;https://www.cnblogs.com/wuwangchuxin0924/p/5851067.html&quot;&gt;补码&lt;/a&gt;进行运算的，-n转化为补码，符号位不变其他位取反转化为反码，然后最低位+1转化为补码，下面分两步讲。&lt;/p&gt;</summary>
    
    
    
    
    <category term="黑科技" scheme="https://journey-c.github.io/tags/%E9%BB%91%E7%A7%91%E6%8A%80/"/>
    
  </entry>
  
  <entry>
    <title>sync.pool源码阅读</title>
    <link href="https://journey-c.github.io/2020/10/29/sync-pool-read/"/>
    <id>https://journey-c.github.io/2020/10/29/sync-pool-read/</id>
    <published>2020-10-29T09:58:05.192Z</published>
    <updated>2020-11-14T18:33:48.220Z</updated>
    
    <content type="html"><![CDATA[<p>阅读项目代码的时候发现很多地方用到了golang的sync.pool，所以好奇golang的sync.pool底层实现是什么样的，有哪些优化。<br>本文是基于go1.13.8，做讲解。</p><a id="more"></a><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>Pool翻译过来就是池子，主要功能就是: 需要使用某个Object的时候可以从Pool获取，使用完毕再归还，从而减少创建和销毁Object的开销。而本文讲的就是golang中的Pool源码实现。</p><h1 id="2-用法"><a href="#2-用法" class="headerlink" title="2. 用法"></a>2. 用法</h1><p><strong>千万不要想当然的认为put进去的Object和get出来的Object有什么关系，Pool存的Object在GC时会都清理掉</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Book struct &#123;</span><br><span class="line">Name string</span><br><span class="line">Info map[string]string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewBook() interface&#123;&#125; &#123;</span><br><span class="line">return &amp;Book&#123;</span><br><span class="line">Name: &quot;&quot;,</span><br><span class="line">Info: make(map[string]string),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">&#x2F;&#x2F; 创建pool并定义创建object的函数</span><br><span class="line">bookPool :&#x3D; sync.Pool&#123;New:NewBook&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从pool获取object</span><br><span class="line">a :&#x3D; bookPool.Get().(*Book)</span><br><span class="line">a.Name &#x3D; &quot;go&quot;</span><br><span class="line">a.Info[&quot;a&quot;] &#x3D; &quot;b&quot;</span><br><span class="line"></span><br><span class="line">fmt.Println(a)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 放回pool</span><br><span class="line">bookPool.Put(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-结构图"><a href="#3-结构图" class="headerlink" title="3. 结构图"></a>3. 结构图</h1><p><img src="/images/pool.png"></p><h1 id="4-实现细节"><a href="#4-实现细节" class="headerlink" title="4. 实现细节"></a>4. 实现细节</h1><ul><li>Pool实现源码是这两个文件go/src/sync/pool.go, go/src/sync/poolqueue.go</li></ul><h2 id="4-1-数据结构"><a href="#4-1-数据结构" class="headerlink" title="4.1 数据结构"></a>4.1 数据结构</h2><p><strong>从下往上讲一下Pool底层存储是如何实现</strong></p><h3 id="4-1-1-eface"><a href="#4-1-1-eface" class="headerlink" title="4.1.1 eface"></a>4.1.1 eface</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储元素的结构体，类型指针和值指针</span></span><br><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">        typ, val unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pool底层用eface来存储单个Object, 包括typ指针: Object的类型，val指针: Object的值</p><h3 id="4-1-2-poolDequeue"><a href="#4-1-2-poolDequeue" class="headerlink" title="4.1.2 poolDequeue"></a>4.1.2 poolDequeue</h3><p>poolDequeue是一个无锁、固定大小的单生产端多消费端的环形队列，单一producer可以在头部push和pop(可能和传统队列头部只能push的定义不同)，多consumer可以在尾部pop</p><ol><li>headTail:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[hhhhhhhh hhhhhhhh hhhhhhhh hhhhhhhh tttttttt tttttttt tttttttt tttttttt] </span><br><span class="line">1. headTail表示下标，高32位表示头下标，低32位表示尾下标，poolDequeue定义了，head tail的pack和unpack函数方便转化，</span><br><span class="line">实际用的时候都会mod ( len(vals) - 1 ) 来防止溢出</span><br><span class="line">2. head和tail永远只用32位表示，溢出后会从0开始，这也满足循环队列的设计</span><br><span class="line">3. 队列为空的条件  tail &#x3D;&#x3D; head</span><br><span class="line">4. 队列满的条件    (tail+uint32(len(d.vals)))&amp;(1&lt;&lt;dequeueBits-1) &#x3D;&#x3D; head tail加上队列长度和head相等(实际上就是队列已有的空间都有值了,满了)</span><br></pre></td></tr></table></figure><ol start="2"><li>vals:</li></ol><ol><li><p>poolDequeue是被poolChain使用，poolChain使用poolDequeue时<br> a) 初始化vals长度为8，vals长度必须是2的幂<br> b) 当队列满时，vals长度*2，最大扩展到 dequeueLimit = (1 &lt;&lt; 32) / 4 = (1 &lt;&lt; 30)，之后就不会扩展了</p></li><li><p>为什么vals长度必须是2的幂<br> 这是因为go的内存管理策略是将内存分为2的幂大小的链表，申请2的幂大小的内存可以有效减小分配内存的开销</p></li><li><p>为什么dequeueLimit是(1 &lt;&lt; 32) / 4 = 1 &lt;&lt; 30<br> a) dequeueLimit 必须是2的幂(上边解释过)<br> b) head和tail都是32位，最大是1 &lt;&lt; 31，如果都用的话，head和tail就是无符号整型，无符号整型使用的时候会有很多上溢的错误，这类错误是不容易检测的，所以相比之下还不如用31位有符号整型，有错就报出来，结论参考<a href="https://stackoverrun.com/cn/q/10770747">https://stackoverrun.com/cn/q/10770747</a></p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> poolDequeue <span class="keyword">struct</span> &#123;</span><br><span class="line">headTail <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">vals []eface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// poolDequeue成员函数</span></span><br><span class="line"><span class="comment">// 这里的删除操作，是将指针置空，然后让GC来回收内存空间</span></span><br><span class="line">unpack     将headTail分解为head和tail</span><br><span class="line">pack       将head和tail组合成headTail</span><br><span class="line">pushHead   添加元素到队首</span><br><span class="line">popHead    获取并删除队首元素</span><br><span class="line">popTail    获取并删除队尾元素</span><br><span class="line">PushHead   添加元素到队首</span><br><span class="line">PopHead    获取并删除队首元素</span><br><span class="line">PopTail    获取并删除队尾元素</span><br></pre></td></tr></table></figure><h3 id="4-1-3-poolChainElt"><a href="#4-1-3-poolChainElt" class="headerlink" title="4.1.3 poolChainElt"></a>4.1.3 poolChainElt</h3><p>链表的一个节点 Node</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type poolChainElt struct &#123;</span><br><span class="line">poolDequeue</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; next and prev link to the adjacent poolChainElts in this</span><br><span class="line">&#x2F;&#x2F; poolChain.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; next is written atomically by the producer and read</span><br><span class="line">&#x2F;&#x2F; atomically by the consumer. It only transitions from nil to</span><br><span class="line">&#x2F;&#x2F; non-nil.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; prev is written atomically by the consumer and read</span><br><span class="line">&#x2F;&#x2F; atomically by the producer. It only transitions from</span><br><span class="line">&#x2F;&#x2F; non-nil to nil.</span><br><span class="line">next, prev *poolChainElt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-4-poolChain"><a href="#4-1-4-poolChain" class="headerlink" title="4.1.4 poolChain"></a>4.1.4 poolChain</h3><p>poolChain 是动态版的poolDequeue<br>head(poolDequeue)[prev] –&gt; &lt;— <a href="...">next</a>[prev] —&gt; &lt;—[next]tail(poolDequeue)<br>动态的队列，队列每个节点又是一个环形队列(poolDequeue)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">type poolChain struct &#123;</span><br><span class="line">&#x2F;&#x2F; 头指针，只能单一producer操作(push, pop)</span><br><span class="line">head *poolChainElt</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 尾指针，可以被多个consumer pop，必须是原子操作</span><br><span class="line">tail *poolChainElt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; poolChain成员函数</span><br><span class="line">func (c *poolChain) pushHead(val interface&#123;&#125;)</span><br><span class="line">1. 如果head为nil，说明队列现在是空的，那么新建一个节点，将head和tail都指向这个节点</span><br><span class="line">2. 将val push到head的环形队列中，如果push成功了，可以返回了</span><br><span class="line">3. 如果没push成功，则说明head的环形队列满了，就再创建一个两倍head大小的节点[最大(1 &lt;&lt; 32) &#x2F; 4]，</span><br><span class="line">将新节点作为head，并且处理好新head和旧head的next，prev关系</span><br><span class="line">4. 将val push到head的环形队列中</span><br><span class="line"></span><br><span class="line">func (c *poolChain) popHead()</span><br><span class="line">1. 先在head环形队列中popHead试试，如果空了，当前节点就没用了，就删掉当前节点，去prev节点并且把prev节点作为新head再取一值递归下去，</span><br><span class="line">能取到就返回，取不到说明队列空了</span><br><span class="line">func (c *poolChain) popTail()</span><br><span class="line">1. 如果tail为nil，说明队列是空的，直接返回</span><br><span class="line">2. 如果tail非nil，就取取试试，有东西就返回</span><br><span class="line">3. 如果没取出来东西，那么说明tail节点没存东西了，递归去prev节点环形队列中popTail，并且把prev节点作为tail，能取到就返回，取不到就是空了</span><br></pre></td></tr></table></figure><h3 id="4-1-5-poolLocal"><a href="#4-1-5-poolLocal" class="headerlink" title="4.1.5 poolLocal"></a>4.1.5 poolLocal</h3><ol><li>poolLocal是每个调度器(P)存Object的结构体</li><li>private是每个调度器私有的，shared是所有调度器公有的，每个调度器pop时的逻辑是: 先看private，没有在看自己的shared，再没有就去其他调度器的shared偷，再没有才是空</li><li>pad是防止伪共享，参考<a href="https://www.cnblogs.com/cyfonly/p/5800758.html">https://www.cnblogs.com/cyfonly/p/5800758.html</a><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> poolLocal <span class="keyword">struct</span> &#123;</span><br><span class="line">poolLocalInternal</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prevents false sharing on widespread platforms with</span></span><br><span class="line"><span class="comment">// 128 mod (cache line size) = 0 .</span></span><br><span class="line">pad [<span class="number">128</span> - unsafe.Sizeof(poolLocalInternal&#123;&#125;)%<span class="number">128</span>]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Local per-P Pool appendix.</span></span><br><span class="line"><span class="comment">// 当前调度器的内部资源</span></span><br><span class="line"><span class="keyword">type</span> poolLocalInternal <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 当前调度器的私有资源</span></span><br><span class="line">private <span class="keyword">interface</span>&#123;&#125; <span class="comment">// Can be used only by the respective P.</span></span><br><span class="line"><span class="comment">// 所有调度器的公有资源</span></span><br><span class="line">shared  poolChain   <span class="comment">// Local P can pushHead/popHead; any P can popTail.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="4-2-主要函数"><a href="#4-2-主要函数" class="headerlink" title="4.2 主要函数"></a>4.2 主要函数</h2><h3 id="4-2-1-Put"><a href="#4-2-1-Put" class="headerlink" title="4.2.1 Put"></a>4.2.1 Put</h3><p>Put adds x to the pool.</p><ol><li>首先关闭竞争检测，然后会将当前goroutine固定到一个调度器(P)上，且不允许抢占</li><li>从Pool的local中取出来当前goroutine固定到那个调度器(P)对应的poolLocal, 没有就新建</li><li>先判断这个当前调度器(P)专属poolLocal，私有空间是不是空的，如果是把x放到私有空间，并把x置nil</li><li>判断x是否为nil，如果不为空说明私有空间满了，就push到该调度器专属poolLocal的shared head</li><li>允许抢占，开启竞争检测</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Put</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="comment">// 如果put进来的值为空直接返回</span></span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭竞争检测</span></span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line"><span class="keyword">if</span> fastrand()%<span class="number">4</span> == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Randomly drop x on floor.</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">race.ReleaseMerge(poolRaceAddr(x))</span><br><span class="line">race.Disable()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line">l, _ := p.pin()</span><br><span class="line"><span class="keyword">if</span> l.private == <span class="literal">nil</span> &#123;</span><br><span class="line">l.private = x</span><br><span class="line">x = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> x != <span class="literal">nil</span> &#123;</span><br><span class="line">l.shared.pushHead(x)</span><br><span class="line">&#125;</span><br><span class="line">runtime_procUnpin()</span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">race.Enable()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把当前的goroutine固定到调度器(P)，不允许抢占, 返回该调度器(P)对应的poolLocal和调度器(P)ID<br>运行时调度器的三个重要组成部分 — 线程 M、Goroutine G 和调度器 P(负责调度)</p><p>判断pid是否小于[]poolLocal的长度，小于的话就在取出poolLocal[P]返回，否则就去执行pinSlow函数<br>Caller must call runtime_procUnpin() when done with the pool.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">pin</span><span class="params">()</span> <span class="params">(*poolLocal, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 关闭抢占，等这个goroutine工作完，其他goroutine才能获得时间片工作</span></span><br><span class="line">pid := runtime_procPin()</span><br><span class="line"><span class="comment">// In pinSlow we store to local and then to localSize, here we load in opposite order.</span></span><br><span class="line"><span class="comment">// Since we&#x27;ve disabled preemption, GC cannot happen in between.</span></span><br><span class="line"><span class="comment">// Thus here we must observe local at least as large localSize.</span></span><br><span class="line"><span class="comment">// We can observe a newer/larger local, it is fine (we must observe its zero-initialized-ness).</span></span><br><span class="line"></span><br><span class="line">s := atomic.LoadUintptr(&amp;p.localSize) <span class="comment">// load-acquire</span></span><br><span class="line">l := p.local                          <span class="comment">// load-consume</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">uintptr</span>(pid) &lt; s &#123;</span><br><span class="line"><span class="keyword">return</span> indexLocal(l, pid), pid</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p.pinSlow()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当goroutine固定到的调度器(P)没有poolLocal时，pins() 函数就会调用pinSlow() 来重新固定到其他调度器(P)，<br>如果新固定到的调度器(P)还是没有poolLocal，就给该调度器创建一个poolLocal放到Pool的local中</p><ol><li>打开抢占并且pool加锁然后关闭抢占，这里如果不先打开抢占的话，其他goroutine如果之前获得锁了，但不能运行，当前goroutine在获取锁，就会死锁</li><li>如果判断pid和len([]poolLocal)的关系，小于就返回[PID]poolLocal</li><li>如果此Pool的[]poolLocal是空的，就把Pool加到allPools中</li><li>获得当前cpu的数量，创建一个cpu数量大小的[]poolLocal</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">pinSlow</span><span class="params">()</span> <span class="params">(*poolLocal, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">runtime_procUnpin()</span><br><span class="line">allPoolsMu.Lock()</span><br><span class="line"><span class="keyword">defer</span> allPoolsMu.Unlock()</span><br><span class="line">pid := runtime_procPin()</span><br><span class="line"><span class="comment">// poolCleanup won&#x27;t be called while we are pinned.</span></span><br><span class="line">s := p.localSize</span><br><span class="line">l := p.local</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">uintptr</span>(pid) &lt; s &#123;</span><br><span class="line"><span class="keyword">return</span> indexLocal(l, pid), pid</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> p.local == <span class="literal">nil</span> &#123;</span><br><span class="line">allPools = <span class="built_in">append</span>(allPools, p)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// If GOMAXPROCS changes between GCs, we re-allocate the array and lose the old one.</span></span><br><span class="line">size := runtime.GOMAXPROCS(<span class="number">0</span>)</span><br><span class="line">local := <span class="built_in">make</span>([]poolLocal, size)</span><br><span class="line">atomic.StorePointer(&amp;p.local, unsafe.Pointer(&amp;local[<span class="number">0</span>])) <span class="comment">// store-release</span></span><br><span class="line">atomic.StoreUintptr(&amp;p.localSize, <span class="keyword">uintptr</span>(size))         <span class="comment">// store-release</span></span><br><span class="line"><span class="keyword">return</span> &amp;local[pid], pid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-2-Get"><a href="#4-2-2-Get" class="headerlink" title="4.2.2 Get"></a>4.2.2 Get</h3><p>从Pool中获取对象，然后返回，如果Pool为空的就用New来创建<br>不要假设Put进来的对象和Get得到的对象有什么关系</p><ol><li>关掉竞争检测</li><li>将goroutine固定到一个调度器(P), 并获取他的poolLocal和PID</li><li>判断该调度器(P)的poolLocal的私有空间是不是空的，如果是空的，就从该调度器(P)的poolLocal shared空间头<br> pop一下看有没有</li><li>如果没有，就说明该调度器(P)自己的poolLocal没有对象了，就调用getSlow</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Get</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">race.Disable()</span><br><span class="line">&#125;</span><br><span class="line">l, pid := p.pin()</span><br><span class="line">x := l.private</span><br><span class="line">l.private = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Try to pop the head of the local shard. We prefer</span></span><br><span class="line"><span class="comment">// the head over the tail for temporal locality of</span></span><br><span class="line"><span class="comment">// reuse.</span></span><br><span class="line">x, _ = l.shared.popHead()</span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">x = p.getSlow(pid)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">runtime_procUnpin()</span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">race.Enable()</span><br><span class="line"><span class="keyword">if</span> x != <span class="literal">nil</span> &#123;</span><br><span class="line">race.Acquire(poolRaceAddr(x))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &amp;&amp; p.New != <span class="literal">nil</span> &#123;</span><br><span class="line">x = p.New()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>懒获取函数</p><ol><li>取到Pool的localSize和local</li><li>然后遍历其他调度器(P)对应的poolLocal，看看能不能从对应poolLocal中的shared tail中取出对象, 如果能取到，直接返回</li><li>如果取不到就到victim中查询，有就返回，没有调用New创建一个新的Object返回</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">getSlow</span><span class="params">(pid <span class="keyword">int</span>)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="comment">// See the comment in pin regarding ordering of the loads.</span></span><br><span class="line">size := atomic.LoadUintptr(&amp;p.localSize) <span class="comment">// load-acquire</span></span><br><span class="line">locals := p.local                        <span class="comment">// load-consume</span></span><br><span class="line"><span class="comment">// Try to steal one element from other procs.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(size); i++ &#123;</span><br><span class="line">l := indexLocal(locals, (pid+i+<span class="number">1</span>)%<span class="keyword">int</span>(size))</span><br><span class="line"><span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Try the victim cache. We do this after attempting to steal</span></span><br><span class="line"><span class="comment">// from all primary caches because we want objects in the</span></span><br><span class="line"><span class="comment">// victim cache to age out if at all possible.</span></span><br><span class="line">size = atomic.LoadUintptr(&amp;p.victimSize)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">uintptr</span>(pid) &gt;= size &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">locals = p.victim</span><br><span class="line">l := indexLocal(locals, pid)</span><br><span class="line"><span class="keyword">if</span> x := l.private; x != <span class="literal">nil</span> &#123;</span><br><span class="line">l.private = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(size); i++ &#123;</span><br><span class="line">l := indexLocal(locals, (pid+i)%<span class="keyword">int</span>(size))</span><br><span class="line"><span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mark the victim cache as empty for future gets don&#x27;t bother</span></span><br><span class="line"><span class="comment">// with it.</span></span><br><span class="line">atomic.StoreUintptr(&amp;p.victimSize, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="pool-dot"><a href="#pool-dot" class="headerlink" title="pool.dot"></a>pool.dot</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">digraph &#123;</span><br><span class="line">    bgcolor&#x3D;&quot;#C6CFD532&quot;;</span><br><span class="line"></span><br><span class="line">    node [shape&#x3D;record, fontsize&#x3D;&quot;8&quot;, margin&#x3D;&quot;0.04&quot;, height&#x3D;0.2, color&#x3D;gray]</span><br><span class="line">    edge [fontname&#x3D;&quot;Inconsolata, Consolas&quot;, fontsize&#x3D;10, arrowhead&#x3D;normal]</span><br><span class="line"></span><br><span class="line">    pool [shape&#x3D;record,label&#x3D;&quot;&#123;noCopy|&lt;local&gt;local|localSize|&lt;victim&gt;victim|victimSize|New&#125;&quot;,xlabel&#x3D;&quot;Pool&quot;]</span><br><span class="line">    poolLocal[shape&#x3D;record,label&#x3D;&quot;&#123;&lt;poolLocalInternal&gt;poolLocalInternal|pad&#125;&quot;,xlabel&#x3D;&quot;poolLocal&quot;]</span><br><span class="line">    poolLocalInternal[shape&#x3D;record,label&#x3D;&quot;&#123;private|&lt;shared&gt;shared&#125;&quot;,xlabel&#x3D;&quot;poolLocalInternal&quot;]</span><br><span class="line">    poolChain[shape&#x3D;record,label&#x3D;&quot;&#123;&lt;head&gt;head|&lt;tail&gt;tail&#125;&quot;,xlabel&#x3D;&quot;poolChain&quot;]</span><br><span class="line">    poolChainElt[shape&#x3D;record,label&#x3D;&quot;&#123;&lt;poolDequeue&gt;poolDequeue|next|prev&#125;&quot;,xlabel&#x3D;&quot;poolChainElt&quot;]</span><br><span class="line">    poolDequeue[shape&#x3D;record,label&#x3D;&quot;&#123;headTail|&lt;vals&gt;vals&#125;&quot;,xlabel&#x3D;&quot;poolDequeue&quot;]</span><br><span class="line">    eface[shape&#x3D;record,label&#x3D;&quot;&#123;typ|val&#125;&quot;,xlabel&#x3D;&quot;eface&quot;]</span><br><span class="line">    victim[shape&#x3D;record,label&#x3D;&quot;GC的时候，首先把local中每个处理器(P)对应的poolLocal赋给victim，然后清空local，所以victim就是缓存GC前的local&quot;,xlabel&#x3D;&quot;victim&quot;]</span><br><span class="line"></span><br><span class="line">    pool:local -&gt; poolLocal [label&#x3D;&quot;local指针指向[]poolLocal首地址&quot;,rankdir&#x3D;LR]</span><br><span class="line">    poolLocal:poolLocalInternal -&gt; poolLocalInternal</span><br><span class="line">    poolLocalInternal:shared -&gt; poolChain[label&#x3D;&quot;shared是一个队列&quot;]</span><br><span class="line">    poolChain:head -&gt; poolChainElt[label&#x3D;&quot;head和tail是队列的收尾节点指针&quot;]</span><br><span class="line">    poolChain:tail -&gt; poolChainElt</span><br><span class="line">    poolChainElt:poolDequeue -&gt; poolDequeue[label&#x3D;&quot;poolDequeue是一个环形队列&quot;]</span><br><span class="line">    poolDequeue:vals -&gt; eface[label&#x3D;&quot;eface存储Object的结构体，typ和val是Object的类型和值指针&quot;]</span><br><span class="line">    pool:victim -&gt; victim</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;阅读项目代码的时候发现很多地方用到了golang的sync.pool，所以好奇golang的sync.pool底层实现是什么样的，有哪些优化。&lt;br&gt;本文是基于go1.13.8，做讲解。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Golang" scheme="https://journey-c.github.io/tags/Golang/"/>
    
    <category term="源码" scheme="https://journey-c.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>channel 源码阅读</title>
    <link href="https://journey-c.github.io/2020/10/29/channel-read/"/>
    <id>https://journey-c.github.io/2020/10/29/channel-read/</id>
    <published>2020-10-29T09:57:04.167Z</published>
    <updated>2020-11-14T18:38:16.655Z</updated>
    
    <content type="html"><![CDATA[<p>(年初的时候go语言的学习提上了日程，前一篇sync.pool阅读之后，阅读代码进度本该更快些，奈何身体被掏空，所以这篇文章断断续续一个月终于攒起来了。)</p><a id="more"></a><p>[toc]</p><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>channel是golang中用于goroutine之间通讯的数据结构，有以下特点：</p><ol><li>线程安全</li><li>创建channel时返回的是指针，不需要考虑拷贝的问题</li><li>顺序通讯，写入和读出的顺序一致</li></ol><h1 id="2-数据部分"><a href="#2-数据部分" class="headerlink" title="2. 数据部分"></a>2. 数据部分</h1><p><img src="/images/chan.png"></p><p><strong>源码位置go/src/runtime/chan.go</strong></p><h2 id="2-1-hchan"><a href="#2-1-hchan" class="headerlink" title="2.1  hchan"></a>2.1  hchan</h2><p>channel对应的数据结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">qcount   <span class="keyword">uint</span></span><br><span class="line">dataqsiz <span class="keyword">uint</span></span><br><span class="line">buf      unsafe.Pointer</span><br><span class="line">elemsize <span class="keyword">uint16</span></span><br><span class="line">closed   <span class="keyword">uint32</span></span><br><span class="line">elemtype *_type</span><br><span class="line">sendx    <span class="keyword">uint</span></span><br><span class="line">recvx    <span class="keyword">uint</span></span><br><span class="line">recvq    waitq</span><br><span class="line">sendq    waitq</span><br><span class="line"></span><br><span class="line"><span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line"><span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Do not change another G&#x27;s status while holding this lock</span></span><br><span class="line"><span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line"><span class="comment">// with stack shrinking.</span></span><br><span class="line">lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-1-参数意义"><a href="#2-1-1-参数意义" class="headerlink" title="2.1.1 参数意义"></a>2.1.1 参数意义</h3><p>qcount   uint // 表示channel中元素的个数<br>dataqsiz uint // 表示channel的大小长度<br>buf      unsafe.Pointer // 存储元素的环形队列头指针<br>elemsize uint16 // 表示此channel能存储元素的大小<br>closed   uint32 // channel是否关闭了<br>elemtype *_type // 表示此channel能存储元素的类型<br>sendx    uint // 表示发送操作对应buf的下标，超过dataqsiz之后清0（因为是循环队列嘛）<br>recvx    uint // 表示接收操作对应buf的下标<br>recvq    waitq // 等待接收操作的goroutine队列<br>sendq    waitq // 等待发送操作的goroutine队列</p><p>lock mutex // channel的锁</p><h2 id="2-2-waitq"><a href="#2-2-waitq" class="headerlink" title="2.2 waitq"></a>2.2 waitq</h2><p>用来表示等待发送或者接受的goroutine队列（用sudog表示队列一个节点）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type waitq struct &#123;</span><br><span class="line">first *sudog</span><br><span class="line">last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-1-参数意义"><a href="#2-2-1-参数意义" class="headerlink" title="2.2.1 参数意义"></a>2.2.1 参数意义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first goroutine指针，队首指针</span><br><span class="line">last  goroutine指针，队尾指针</span><br></pre></td></tr></table></figure><h3 id="2-2-2-函数"><a href="#2-2-2-函数" class="headerlink" title="2.2.2 函数"></a>2.2.2 函数</h3><h4 id="2-2-2-1-enqueue"><a href="#2-2-2-1-enqueue" class="headerlink" title="2.2.2.1 enqueue"></a>2.2.2.1 enqueue</h4><p>两种情况：</p><ol><li>队列为空，将元素放入队尾将first指针和last指针赋好值</li><li>队列不为空，直接将元素放入队尾</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func (q *waitq) enqueue(sgp *sudog) &#123;</span><br><span class="line">&#x2F;&#x2F; 将goroutine的next置为空</span><br><span class="line">sgp.next &#x3D; nil</span><br><span class="line">x :&#x3D; q.last</span><br><span class="line">if x &#x3D;&#x3D; nil &#123; &#x2F;&#x2F; 如果尾指针为空，说明队列为空，就把这个goroutine放进去</span><br><span class="line">sgp.prev &#x3D; nil</span><br><span class="line">q.first &#x3D; sgp</span><br><span class="line">q.last &#x3D; sgp</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 直接入队列</span><br><span class="line">sgp.prev &#x3D; x</span><br><span class="line">x.next &#x3D; sgp</span><br><span class="line">q.last &#x3D; sgp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-2-dequeue"><a href="#2-2-2-2-dequeue" class="headerlink" title="2.2.2.2 dequeue"></a>2.2.2.2 dequeue</h4><p>从队列头开始遍历</p><ol><li>first指针为空，说明队列为空，则直接返回空</li><li>如果队列只有一个元素了，将元素取出，并且清空first指针和last指针</li><li>队列还有很多元素，直接将first指针对应的元素去除</li><li>最后判断如果这个元素(sudog——在channel中用来表示等待接收或者发送的goroutine的)在select结构中并且select结构有其他接口，就跳过，继续遍历下一个节点。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">func (q *waitq) dequeue() *sudog &#123;</span><br><span class="line">for &#123;</span><br><span class="line">sgp :&#x3D; q.first</span><br><span class="line">if sgp &#x3D;&#x3D; nil &#123; &#x2F;&#x2F; 头指针为空，说明队列为空，直接返回</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line">y :&#x3D; sgp.next</span><br><span class="line">if y &#x3D;&#x3D; nil &#123; &#x2F;&#x2F; 如果next指针为空，说明队列就一个元素了，取出这个就空了，就将队列置空</span><br><span class="line">q.first &#x3D; nil</span><br><span class="line">q.last &#x3D; nil</span><br><span class="line">&#125; else &#123; &#x2F;&#x2F; next不为空，就将next作为队首，将原来的队首返回</span><br><span class="line">y.prev &#x3D; nil</span><br><span class="line">q.first &#x3D; y</span><br><span class="line">sgp.next &#x3D; nil &#x2F;&#x2F; mark as removed (see dequeueSudog)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; if a gogoroutine was put on this queue because of a</span><br><span class="line">&#x2F;&#x2F; select, there is a small window between the gogoroutine</span><br><span class="line">&#x2F;&#x2F; being woken up by a different case and it grabbing the</span><br><span class="line">&#x2F;&#x2F; channel locks. Once it has the lock</span><br><span class="line">&#x2F;&#x2F; it removes itself from the queue, so we won&#39;t see it after that.</span><br><span class="line">&#x2F;&#x2F; We use a flag in the G struct to tell us when someone</span><br><span class="line">&#x2F;&#x2F; else has won the race to signal this gogoroutine but the gogoroutine</span><br><span class="line">&#x2F;&#x2F; hasn&#39;t removed itself from the queue yet.</span><br><span class="line">&#x2F;&#x2F; 如果goroutine处于select结构中并且select有其他出口就跳过这个</span><br><span class="line">if sgp.isSelect &amp;&amp; !atomic.Cas(&amp;sgp.g.selectDone, 0, 1) &#123;</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return sgp</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-sudog"><a href="#2-3-sudog" class="headerlink" title="2.3 sudog"></a>2.3 sudog</h2><p>sudog是在等待对channel发送或者接受的goroutine</p><p><strong>为什么有了goroutine还要有一个sudog？</strong></p><ol><li>因为goroutine和等待的channel是多对多的关系，一个goroutine可能在等待多个channel，一个channel也可能有很多goroutine在等待，所以用sudog表示这个等待中的goroutine</li><li>sudog是channel等待或者接发送链表的一个node</li></ol><p><strong>sudog通过acquireSudog创建，releaseSudog销毁</strong></p><ol><li>在go/src/runtime/proc.go中</li><li>go会维护一个全局的缓存（有锁），然后每个调度器（P）有自己的缓存</li><li>创建sudog时会先从P的缓存中找，没有就到全局缓存中找，在没有才new一个</li><li>销毁sudog的时候先判断P是不是满了，如果满了就将一半缓存放到全局缓存然后再把sudog放到自己缓存</li><li>全局缓存的生存周期时两次GC的间隔，go/src/runtime/mgc.go 中clearpools()函数中可以看到，每次GC都会清理全局缓存</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">type sudog struct &#123;</span><br><span class="line">&#x2F;&#x2F; sudog替哪个goroutine在等待</span><br><span class="line">g *g</span><br><span class="line"></span><br><span class="line">isSelect bool  &#x2F;&#x2F; 是否在select结构中(select可能取消阻塞发送或接收)</span><br><span class="line">next     *sudog &#x2F;&#x2F; 下一个节点</span><br><span class="line">prev     *sudog &#x2F;&#x2F; 上一个节点</span><br><span class="line">elem     unsafe.Pointer &#x2F;&#x2F; data element (may point to stack)</span><br><span class="line"></span><br><span class="line">acquiretime int64 &#x2F;&#x2F; 创建时间</span><br><span class="line">releasetime int64 &#x2F;&#x2F; 释放时间</span><br><span class="line">ticket      uint32</span><br><span class="line">parent      *sudog &#x2F;&#x2F; semaRoot binary tree</span><br><span class="line">waitlink    *sudog &#x2F;&#x2F; g.waiting list or semaRoot</span><br><span class="line">waittail    *sudog &#x2F;&#x2F; semaRoot</span><br><span class="line">c           *hchan &#x2F;&#x2F; channel 在等待哪个channel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-1-创建sudog——acquireSudog"><a href="#2-3-1-创建sudog——acquireSudog" class="headerlink" title="2.3.1 创建sudog——acquireSudog"></a>2.3.1 创建sudog——acquireSudog</h3><p>大概逻辑就是现在当前goroutine所在调度器(P)的缓存中找，如果没有就从全局缓存中找，如果还没有就new一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">func acquireSudog() *sudog &#123;</span><br><span class="line">&#x2F;&#x2F; 获得当前goroutine所在的线程(M)</span><br><span class="line">mp :&#x3D; acquirem()</span><br><span class="line">&#x2F;&#x2F; 获得当前goroutine所在调度器(P)</span><br><span class="line">pp :&#x3D; mp.p.ptr()</span><br><span class="line">if len(pp.sudogcache) &#x3D;&#x3D; 0 &#123; &#x2F;&#x2F; 如果调度器的sudog缓存为空，就从中央缓存找，如果再为空就new一个</span><br><span class="line">lock(&amp;sched.sudoglock)</span><br><span class="line">&#x2F;&#x2F; First, try to grab a batch from central cache.</span><br><span class="line">for len(pp.sudogcache) &lt; cap(pp.sudogcache)&#x2F;2 &amp;&amp; sched.sudogcache !&#x3D; nil &#123;</span><br><span class="line">s :&#x3D; sched.sudogcache</span><br><span class="line">sched.sudogcache &#x3D; s.next</span><br><span class="line">s.next &#x3D; nil</span><br><span class="line">pp.sudogcache &#x3D; append(pp.sudogcache, s)</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;sched.sudoglock)</span><br><span class="line">&#x2F;&#x2F; If the central cache is empty, allocate a new one.</span><br><span class="line">if len(pp.sudogcache) &#x3D;&#x3D; 0 &#123;</span><br><span class="line">pp.sudogcache &#x3D; append(pp.sudogcache, new(sudog))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">n :&#x3D; len(pp.sudogcache)</span><br><span class="line">s :&#x3D; pp.sudogcache[n-1]</span><br><span class="line">pp.sudogcache[n-1] &#x3D; nil</span><br><span class="line">pp.sudogcache &#x3D; pp.sudogcache[:n-1]</span><br><span class="line">if s.elem !&#x3D; nil &#123;</span><br><span class="line">throw(&quot;acquireSudog: found s.elem !&#x3D; nil in cache&quot;)</span><br><span class="line">&#125;</span><br><span class="line">releasem(mp)</span><br><span class="line">return s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-2-销毁sudog——releaseSudog"><a href="#2-3-2-销毁sudog——releaseSudog" class="headerlink" title="2.3.2 销毁sudog——releaseSudog"></a>2.3.2 销毁sudog——releaseSudog</h3><p>大概逻辑就是如果当前goroutine所在调度器(P)的缓存满了，就将调度器(P)的缓存一半放入全局缓存，然后在把sudog放入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">func releaseSudog(s *sudog) &#123;</span><br><span class="line">&#x2F;&#x2F; 这部分都是check sudog 是否合法</span><br><span class="line">if s.elem !&#x3D; nil &#123;</span><br><span class="line">throw(&quot;runtime: sudog with non-nil elem&quot;)</span><br><span class="line">&#125;</span><br><span class="line">if s.isSelect &#123;</span><br><span class="line">throw(&quot;runtime: sudog with non-false isSelect&quot;)</span><br><span class="line">&#125;</span><br><span class="line">if s.next !&#x3D; nil &#123;</span><br><span class="line">throw(&quot;runtime: sudog with non-nil next&quot;)</span><br><span class="line">&#125;</span><br><span class="line">if s.prev !&#x3D; nil &#123;</span><br><span class="line">throw(&quot;runtime: sudog with non-nil prev&quot;)</span><br><span class="line">&#125;</span><br><span class="line">if s.waitlink !&#x3D; nil &#123;</span><br><span class="line">throw(&quot;runtime: sudog with non-nil waitlink&quot;)</span><br><span class="line">&#125;</span><br><span class="line">if s.c !&#x3D; nil &#123;</span><br><span class="line">throw(&quot;runtime: sudog with non-nil c&quot;)</span><br><span class="line">&#125;</span><br><span class="line">gp :&#x3D; getg()</span><br><span class="line">if gp.param !&#x3D; nil &#123;</span><br><span class="line">throw(&quot;runtime: releaseSudog with non-nil gp.param&quot;)</span><br><span class="line">&#125;</span><br><span class="line">mp :&#x3D; acquirem() &#x2F;&#x2F; avoid rescheduling to another P</span><br><span class="line">pp :&#x3D; mp.p.ptr()</span><br><span class="line">&#x2F;&#x2F; 如果当前调度器的缓存满了，就将一半放入中央缓存</span><br><span class="line">if len(pp.sudogcache) &#x3D;&#x3D; cap(pp.sudogcache) &#123;</span><br><span class="line">&#x2F;&#x2F; Transfer half of local cache to the central cache.</span><br><span class="line">var first, last *sudog</span><br><span class="line">for len(pp.sudogcache) &gt; cap(pp.sudogcache)&#x2F;2 &#123;</span><br><span class="line">n :&#x3D; len(pp.sudogcache)</span><br><span class="line">p :&#x3D; pp.sudogcache[n-1]</span><br><span class="line">pp.sudogcache[n-1] &#x3D; nil</span><br><span class="line">pp.sudogcache &#x3D; pp.sudogcache[:n-1]</span><br><span class="line">if first &#x3D;&#x3D; nil &#123;</span><br><span class="line">first &#x3D; p</span><br><span class="line">&#125; else &#123;</span><br><span class="line">last.next &#x3D; p</span><br><span class="line">&#125;</span><br><span class="line">last &#x3D; p</span><br><span class="line">&#125;</span><br><span class="line">lock(&amp;sched.sudoglock)</span><br><span class="line">last.next &#x3D; sched.sudogcache</span><br><span class="line">sched.sudogcache &#x3D; first</span><br><span class="line">unlock(&amp;sched.sudoglock)</span><br><span class="line">&#125;</span><br><span class="line">pp.sudogcache &#x3D; append(pp.sudogcache, s)</span><br><span class="line">releasem(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-实现细节"><a href="#3-实现细节" class="headerlink" title="3. 实现细节"></a>3. 实现细节</h1><h2 id="3-1-创建channel"><a href="#3-1-创建channel" class="headerlink" title="3.1 创建channel"></a>3.1 创建channel</h2><p><em>go中所有的channel的创建都会使用make关键字，make(arg1, arg2)函数最终会调用到runtime.makechan和runtime.makechan64，下面讲解go在编译时期是如何做这些事情的</em></p><p><a href="https://github.com/golang/go/blob/go1.13.8/src/cmd/compile/internal/gc/typecheck.go">typecheck.go</a><br>编译器会将make(arg1, arg2)转化成OMAKE类型的节点，并在类型检查阶段将OMAKE类型的节点按照arg1的类型转化为OMAKECHAN，OMAKEMAP，OMAKESLICE等类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func typecheck1(n *Node, top int) (res *Node) &#123;</span><br><span class="line">    ...</span><br><span class="line">    switch n.Op &#123;</span><br><span class="line">    ...</span><br><span class="line">    case OMAKE:</span><br><span class="line">        ... </span><br><span class="line">        switch t.Etype &#123;</span><br><span class="line">        ...</span><br><span class="line">        case TCHAN:</span><br><span class="line">            l &#x3D; nil</span><br><span class="line">            if i &lt; len(args) &#123;</span><br><span class="line">                ....</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                n.Left &#x3D; nodintconst(0)</span><br><span class="line">            &#125;</span><br><span class="line">            n.Op &#x3D; OMAKECHAN &#x2F;&#x2F; 节点类型转化为OMAKECHAN</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/golang/go/blob/go1.13.8/src/cmd/compile/internal/gc/walk.go">walk.go</a><br>OMAKECHAN类型的节点最终会在SSA中间代码生成之前被转化成runtime.makechan或者runtime.makechan64</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func walkexpr(n *Node, init *Nodes) *Node &#123;</span><br><span class="line">    ...</span><br><span class="line">    switch n.Op &#123;</span><br><span class="line">    ...</span><br><span class="line">    case OMAKECHAN:</span><br><span class="line">        &#x2F;&#x2F; When size fits into int, use makechan instead of</span><br><span class="line">        &#x2F;&#x2F; makechan64, which is faster and shorter on 32 bit platforms.</span><br><span class="line">        size :&#x3D; n.Left</span><br><span class="line">        fnname :&#x3D; &quot;makechan64&quot;</span><br><span class="line">        argtype :&#x3D; types.Types[TINT64]</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Type checking guarantees that TIDEAL size is positive and fits in an int.</span><br><span class="line">        &#x2F;&#x2F; The case of size overflow when converting TUINT or TUINTPTR to TINT</span><br><span class="line">        &#x2F;&#x2F; will be handled by the negative range checks in makechan during runtime.</span><br><span class="line">        if size.Type.IsKind(TIDEAL) || maxintval[size.Type.Etype].Cmp(maxintval[TUINT]) &lt;&#x3D; 0 &#123;</span><br><span class="line">            fnname &#x3D; &quot;makechan&quot;</span><br><span class="line">            argtype &#x3D; types.Types[TINT]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        n &#x3D; mkcall1(chanfn(fnname, 1, n.Type), n.Type, init, typename(n.Type), conv(size, argtype))</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-1-makechan64"><a href="#3-1-1-makechan64" class="headerlink" title="3.1.1 makechan64"></a>3.1.1 makechan64</h3><p>check一下size是否是int，然后就执行makechan了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func makechan64(t *chantype, size int64) *hchan &#123;</span><br><span class="line">if int64(int(size)) !&#x3D; size &#123;</span><br><span class="line">panic(plainError(&quot;makechan: size out of range&quot;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return makechan(t, int(size))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-2-makechan"><a href="#3-1-2-makechan" class="headerlink" title="3.1.2 makechan"></a>3.1.2 makechan</h3><ol><li>安全检查: channel能存的元素类型大小是否超过2^16</li><li>判断<a href="https://www.cnblogs.com/wuwangchuxin0924/p/12735129.html">hchanSize</a>是否关于maxAlign对齐，判断元素对齐是否maxAlign小，如果大maxAlign就没用了，这里hchanSize设计十分巧妙，位运算神操作优化，可以看另一篇文章<a href="https://www.cnblogs.com/wuwangchuxin0924/p/12735129.html">关于2的n次幂对齐</a></li><li>判断申请的空间大小是否uint64大，判断所需空间是否超过最大可申请空间，判断size是否小于0(非法)</li><li>然后就是给hchan申请内存空间了<ol><li>无缓冲的size=0的，只需要给hchan申请hchansize大小的内存空间即可</li><li>有缓冲，但是元素是非指针类型的，就申请hchanSize+mem大小的连续内存空间, 并将hchanSize之后的首地址赋值给buf</li><li>有缓冲，并且元素类型是指针的，hchan和底层buf内存就可以分开申请不用连续</li></ol></li><li>给其他变量赋值</li><li>返回hchan指针，<strong>注意这里返回的是指针，所以channel在各函数之间传递时，就不是值传递了</strong></li></ol><p><strong>为什么元素类型是非指针hchan和buf要在一段地址连续的内存中，而指针类型的则可以分开</strong><br>这是源码注释的原话:<br>Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.<br>buf points into the same allocation, elemtype is persistent.<br>SudoG’s are referenced from their owning thread so they can’t be collected.<br>TODO(dvyukov,rlh): Rethink when collector can move allocated objects.<br><strong>猜想:</strong><br>大概意思是，当channel中元素类型不包含指针时，gc时需要回收这段空间的，当channel中元素类型包含指针时，这些指针被自己所在线程引用gc是不能回收，所以当元素不包含指针时申请一段连续的空间可以减小gc的压力</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">func makechan(t *chantype, size int) *hchan &#123;</span><br><span class="line">elem :&#x3D; t.elem</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; compiler checks this but be safe.</span><br><span class="line">if elem.size &gt;&#x3D; 1&lt;&lt;16 &#123;</span><br><span class="line">throw(&quot;makechan: invalid channel element type&quot;)</span><br><span class="line">&#125;</span><br><span class="line">if hchanSize%maxAlign !&#x3D; 0 || elem.align &gt; maxAlign &#123;</span><br><span class="line">throw(&quot;makechan: bad alignment&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 计算大小需要多少空间，check是否</span><br><span class="line">&#x2F;&#x2F; math.MulUintptr(a, b)函数返回a * b，以及结果是否超过uintptr的最大值</span><br><span class="line">&#x2F;&#x2F; 判断所需空间是否比uint64大，判断所需空间是否超过最大可申请空间，判断size是否小于0(非法)</span><br><span class="line">mem, overflow :&#x3D; math.MulUintptr(elem.size, uintptr(size))</span><br><span class="line">if overflow || mem &gt; maxAlloc-hchanSize || size &lt; 0 &#123;</span><br><span class="line">panic(plainError(&quot;makechan: size out of range&quot;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var c *hchan</span><br><span class="line">switch &#123;</span><br><span class="line">case mem &#x3D;&#x3D; 0:</span><br><span class="line">&#x2F;&#x2F; 就是无缓冲channel，只需要申请hchan需要的大小就行</span><br><span class="line">c &#x3D; (*hchan)(mallocgc(hchanSize, nil, true))</span><br><span class="line">c.buf &#x3D; c.raceaddr()</span><br><span class="line">case elem.ptrdata &#x3D;&#x3D; 0:</span><br><span class="line">&#x2F;&#x2F; 有缓冲队列channel，但是存放元素不是指针类型的，就要申请hchanSize+这些元素大小的内存空间，然后把申请下来空间首地址赋给buf</span><br><span class="line">c &#x3D; (*hchan)(mallocgc(hchanSize+mem, nil, true))</span><br><span class="line">c.buf &#x3D; add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">default:</span><br><span class="line">&#x2F;&#x2F; 默认除了给hchan申请内存空间之外还需要申请size个元素大小的内存空间，并且把首地址赋给c.buf</span><br><span class="line">c &#x3D; new(hchan)</span><br><span class="line">c.buf &#x3D; mallocgc(mem, elem, true)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.elemsize &#x3D; uint16(elem.size)</span><br><span class="line">c.elemtype &#x3D; elem</span><br><span class="line">c.dataqsiz &#x3D; uint(size)</span><br><span class="line"></span><br><span class="line">if debugChan &#123;</span><br><span class="line">print(&quot;makechan: chan&#x3D;&quot;, c, &quot;; elemsize&#x3D;&quot;, elem.size, &quot;; elemalg&#x3D;&quot;, elem.alg, &quot;; dataqsiz&#x3D;&quot;, size, &quot;\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line">return c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-发送"><a href="#3-2-发送" class="headerlink" title="3.2 发送"></a>3.2 发送</h2><p><strong>具体编译时做的转换可参考makechan，代码都在类似的地方</strong></p><h3 id="3-2-1-chansend"><a href="#3-2-1-chansend" class="headerlink" title="3.2.1 chansend"></a>3.2.1 chansend</h3><ol><li>首先检测channel是否为空, 如果为空直接报错</li><li>check是否开启了竞争检测，golang的竞争检测通过ThreadSanitizer库(C++)做的</li><li>然后kill掉一些不用加锁就可以判断的情况，如果是非阻塞并且channel未关闭，size = 0或者channel满了, 直接返回false(发送失败)</li><li>如果已经有goroutine在等待了，就直接调send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int)发给那个goroutine</li><li>如果没有goroutine在等待.</li><li>如果channel是非阻塞并且还地方，就放入buffer中，如果没地方了就直接返回false</li><li>如果channel是阻塞并且不在select中或者在select中且没有其他出口的，就将创建一个sudog，将sudog初始化并且放入待发送队列(sendq), 并且调用goparkunlock(&amp;c.lock, waitReasonChanSend, traceEvGoBlockSend, 3)使当前goroutine陷入沉睡直到被唤醒(已经发出去了)</li><li>清理这个过程的垃圾数据</li></ol><p><strong>第四步中如果有goroutine在等待就直接发送，会影响非阻塞channel数据的顺序吗？</strong><br>不会，channel的数据由唯一全局锁保护，读写互斥，假设一个goroutine来读channel，只有两种情况:</p><ol><li>channel buffer中有数据，这时goroutine会直接读取数据，不会被阻塞。</li><li>channel buffer中没有数据，这时goroutine会被阻塞。</li></ol><p>只有当buffer中有数据且有goroutine被阻塞时，顺序才会被打乱，但这两个条件是互斥的，有数据就不可能阻塞，阻塞就不可能有数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; entry point for c &lt;- x from compiled code</span><br><span class="line">&#x2F;&#x2F;go:nosplit</span><br><span class="line">func chansend1(c *hchan, elem unsafe.Pointer) &#123;</span><br><span class="line">chansend(c, elem, true, getcallerpc())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool &#123;</span><br><span class="line">&#x2F;&#x2F; 如果c为空</span><br><span class="line">if c &#x3D;&#x3D; nil &#123;</span><br><span class="line">&#x2F;&#x2F; 如果是非阻塞的，就是那种有容量的，就返回false写channel失败</span><br><span class="line">if !block &#123;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 如果是非阻塞的就让当前goroutine停止(这里写个小程序就能看效果，这个goroutine的defer不会执行)</span><br><span class="line">gopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2)</span><br><span class="line">throw(&quot;unreachable&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if debugChan &#123;</span><br><span class="line">print(&quot;chansend: chan&#x3D;&quot;, c, &quot;\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if raceenabled &#123; &#x2F;&#x2F; 开启竞争检测</span><br><span class="line">racereadpc(c.raceaddr(), callerpc, funcPC(chansend))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 先不加锁判断非阻塞channel且没关闭</span><br><span class="line">&#x2F;&#x2F; 如果size &#x3D; 0或者channel满了, 直接返回false(发送失败)</span><br><span class="line">if !block &amp;&amp; c.closed &#x3D;&#x3D; 0 &amp;&amp; ((c.dataqsiz &#x3D;&#x3D; 0 &amp;&amp; c.recvq.first &#x3D;&#x3D; nil) ||</span><br><span class="line">(c.dataqsiz &gt; 0 &amp;&amp; c.qcount &#x3D;&#x3D; c.dataqsiz)) &#123;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var t0 int64</span><br><span class="line">if blockprofilerate &gt; 0 &#123;</span><br><span class="line">t0 &#x3D; cputicks()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; channel加锁</span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果channel关闭了，就返回panic</span><br><span class="line">if c.closed !&#x3D; 0 &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line">panic(plainError(&quot;send on closed channel&quot;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等receive队列的队首中取出一个接收者，如果这个接收者不是nil就绕过buffer直接把ep发给他，并且释放锁</span><br><span class="line">if sg :&#x3D; c.recvq.dequeue(); sg !&#x3D; nil &#123;</span><br><span class="line">&#x2F;&#x2F; Found a waiting receiver. We pass the value we want to send</span><br><span class="line">&#x2F;&#x2F; directly to the receiver, bypassing the channel buffer (if any).</span><br><span class="line">send(c, sg, ep, func() &#123; unlock(&amp;c.lock) &#125;, 3)</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; channel还没满就将元素放入buffer</span><br><span class="line">if c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">&#x2F;&#x2F; Space is available in the channel buffer. Enqueue the element to send.</span><br><span class="line">&#x2F;&#x2F; 获取一下发送数据的位置</span><br><span class="line">qp :&#x3D; chanbuf(c, c.sendx)</span><br><span class="line">if raceenabled &#123;</span><br><span class="line">raceacquire(qp)</span><br><span class="line">racerelease(qp)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 将元素拷贝进buffer</span><br><span class="line">typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">c.sendx++</span><br><span class="line">if c.sendx &#x3D;&#x3D; c.dataqsiz &#123; &#x2F;&#x2F; 循环一下</span><br><span class="line">c.sendx &#x3D; 0</span><br><span class="line">&#125;</span><br><span class="line">c.qcount++</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果是非阻塞channel满了就返回false</span><br><span class="line">if !block &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Block on the channel. Some receiver will complete our operation for us.</span><br><span class="line">&#x2F;&#x2F; 获取当前goroutine</span><br><span class="line">gp :&#x3D; getg()</span><br><span class="line">&#x2F;&#x2F; 创建sudog</span><br><span class="line">mysg :&#x3D; acquireSudog()</span><br><span class="line">mysg.releasetime &#x3D; 0</span><br><span class="line">if t0 !&#x3D; 0 &#123;</span><br><span class="line">mysg.releasetime &#x3D; -1</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; No stack splits between assigning elem and enqueuing mysg</span><br><span class="line">&#x2F;&#x2F; on gp.waiting where copystack can find it.</span><br><span class="line">&#x2F;&#x2F; 完善sudog的信息</span><br><span class="line">mysg.elem &#x3D; ep</span><br><span class="line">mysg.waitlink &#x3D; nil</span><br><span class="line">mysg.g &#x3D; gp</span><br><span class="line">mysg.isSelect &#x3D; false</span><br><span class="line">mysg.c &#x3D; c</span><br><span class="line">gp.waiting &#x3D; mysg</span><br><span class="line">gp.param &#x3D; nil</span><br><span class="line">&#x2F;&#x2F; 放入发送列表中</span><br><span class="line">c.sendq.enqueue(mysg)</span><br><span class="line">&#x2F;&#x2F; 将当前goroutine陷入沉睡</span><br><span class="line">goparkunlock(&amp;c.lock, waitReasonChanSend, traceEvGoBlockSend, 3)</span><br><span class="line">KeepAlive(ep)</span><br><span class="line">&#x2F;&#x2F; 再次唤醒的时候说明元素已经发送完毕了</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; someone woke us up.</span><br><span class="line">if mysg !&#x3D; gp.waiting &#123;</span><br><span class="line">throw(&quot;G waiting list is corrupted&quot;)</span><br><span class="line">&#125;</span><br><span class="line">gp.waiting &#x3D; nil</span><br><span class="line">if gp.param &#x3D;&#x3D; nil &#123;</span><br><span class="line">if c.closed &#x3D;&#x3D; 0 &#123;</span><br><span class="line">throw(&quot;chansend: spurious wakeup&quot;)</span><br><span class="line">&#125;</span><br><span class="line">panic(plainError(&quot;send on closed channel&quot;))</span><br><span class="line">&#125;</span><br><span class="line">gp.param &#x3D; nil</span><br><span class="line">if mysg.releasetime &gt; 0 &#123;</span><br><span class="line">blockevent(mysg.releasetime-t0, 2)</span><br><span class="line">&#125;</span><br><span class="line">mysg.c &#x3D; nil</span><br><span class="line">releaseSudog(mysg)</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-1-1-racereadpc"><a href="#3-2-1-1-racereadpc" class="headerlink" title="3.2.1.1 racereadpc"></a>3.2.1.1 racereadpc</h4><p>go/src/runtime/race_amd64.s</p><p>PC: 指令计数器寄存器<br>FP: 函数的帧指针，引用函数的参数。使用形如 symbol+offset(FP) 的方式，引用函数的输入参数。例如 arg0+0(FP)，arg1+8(FP)，使用 FP 不加 symbol 时，无法通过编译，在汇编层面来讲，symbol 并没有什么用，加 symbol 主要是为了提升代码可读性。<br>SP: 当前函数栈帧的底部<br>SB: 全局静态基指针，一般用来声明函数或全局变量<br>参数0放在DI通用寄存器<br>参数1放在SI通用寄存器<br>参数2放在DX通用寄存器<br>参数3放在CX通用寄存器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#define RARG0 DI</span><br><span class="line">#define RARG1 SI</span><br><span class="line">#define RARG2 DX</span><br><span class="line">#define RARG3 CX</span><br><span class="line">&#x2F;&#x2F; void runtime·racereadpc(void *addr, void *callpc, void *pc)</span><br><span class="line">TEXT    runtime·racereadpc(SB), NOSPLIT, $0-24</span><br><span class="line">        MOVQ    addr+0(FP), RARG1</span><br><span class="line">        MOVQ    callpc+8(FP), RARG2</span><br><span class="line">        MOVQ    pc+16(FP), RARG3</span><br><span class="line">        ADDQ    $1, RARG3 &#x2F;&#x2F; pc is function start, tsan wants return address</span><br><span class="line">        &#x2F;&#x2F; void __tsan_read_pc(ThreadState *thr, void *addr, void *callpc, void *pc);</span><br><span class="line"></span><br><span class="line">        MOVQ    $__tsan_read_pc(SB), AX</span><br><span class="line">        JMP     racecalladdr&lt;&gt;(SB)</span><br></pre></td></tr></table></figure><h4 id="3-2-1-2-send"><a href="#3-2-1-2-send" class="headerlink" title="3.2.1.2 send"></a>3.2.1.2 send</h4><p>用于给goroutine直接发送数据</p><ol><li>如果数据没问题就直接将数据拷贝到x := &lt;- c表达式x的内存地址上</li><li>然后将该goroutine放到处理器(P)的runnext上面等待执行，这里不是直接让goroutine执行，而是等下一次调度的时候直接调这个goroutine</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">func send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) &#123;</span><br><span class="line">if raceenabled &#123;</span><br><span class="line">if c.dataqsiz &#x3D;&#x3D; 0 &#123;</span><br><span class="line">racesync(c, sg)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">qp :&#x3D; chanbuf(c, c.recvx)</span><br><span class="line">raceacquire(qp)</span><br><span class="line">racerelease(qp)</span><br><span class="line">raceacquireg(sg.g, qp)</span><br><span class="line">racereleaseg(sg.g, qp)</span><br><span class="line">c.recvx++</span><br><span class="line">if c.recvx &#x3D;&#x3D; c.dataqsiz &#123;</span><br><span class="line">c.recvx &#x3D; 0</span><br><span class="line">&#125;</span><br><span class="line">c.sendx &#x3D; c.recvx &#x2F;&#x2F; c.sendx &#x3D; (c.sendx+1) % c.dataqsiz</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if sg.elem !&#x3D; nil &#123; &#x2F;&#x2F; 如果元素没问题就将发送的数据拷贝到x :&#x3D; &lt;- c表达式x所在内存地址上</span><br><span class="line">sendDirect(c.elemtype, sg, ep)</span><br><span class="line">sg.elem &#x3D; nil</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 然后将将该goroutine放到处理器(P)的runnext上面等待执行，这里不是直接让goroutine执行，而是等下一次调度的时候直接调这个goroutine</span><br><span class="line">gp :&#x3D; sg.g</span><br><span class="line">unlockf()</span><br><span class="line">gp.param &#x3D; unsafe.Pointer(sg)</span><br><span class="line">if sg.releasetime !&#x3D; 0 &#123;</span><br><span class="line">sg.releasetime &#x3D; cputicks()</span><br><span class="line">&#125;</span><br><span class="line">goready(gp, skip+1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-接收"><a href="#3-3-接收" class="headerlink" title="3.3 接收"></a>3.3 接收</h2><p><strong>具体编译时做的转换可参考makechan，代码都在类似的地方</strong></p><h3 id="3-3-1-chanrecv"><a href="#3-3-1-chanrecv" class="headerlink" title="3.3.1 chanrecv"></a>3.3.1 chanrecv</h3><p>两种接收方式：<br>chanrecv1是丢弃channel出来的元素，类似 &lt;- c这中表达式<br>chanrecv2是使用channel出来的元素，类似 elem := &lt;- c<br>最终都会调用到chanrecv</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; entry points for &lt;- c from compiled code</span><br><span class="line">&#x2F;&#x2F;go:nosplit</span><br><span class="line">func chanrecv1(c *hchan, elem unsafe.Pointer) &#123;</span><br><span class="line">chanrecv(c, elem, true)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;go:nosplit</span><br><span class="line">func chanrecv2(c *hchan, elem unsafe.Pointer) (received bool) &#123;</span><br><span class="line">_, received &#x3D; chanrecv(c, elem, true)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>判断chan是否为nil，如果是直接报错</li><li>kill掉一些不用枷锁就可以判断的情况，如果是非阻塞并且队列为空并且channel未关闭就返回false</li><li>如果channel已经关闭了，就清空ep中的数据，立即返回</li><li>如果已经有sendq在等待了(发送端提到过，如果没有goroutine等待接受，就加入sendq), 就直接接收这个元素</li><li>如果此时没有goroutine等待发送</li><li>如果是非阻塞且buffer中有数据直接从buffer中取出，如果没有数据直接返回false</li><li>如果是阻塞的且当前goroutine没在select中或者在select中但没有其他出口，就把自己加入recvq，然后调用goparkunlock(&amp;c.lock, waitReasonChanReceive, traceEvGoBlockRecv, 3)，等待被唤醒（如果被唤醒说明有有数据来了)</li><li>清理这个过程中的垃圾数据</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) &#123;</span><br><span class="line">if debugChan &#123;</span><br><span class="line">print(&quot;chanrecv: chan&#x3D;&quot;, c, &quot;\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; channel为空就使goroutine 停止并报错</span><br><span class="line">if c &#x3D;&#x3D; nil &#123;</span><br><span class="line">if !block &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">gopark(nil, nil, waitReasonChanReceiveNilChan, traceEvGoStop, 2)</span><br><span class="line">throw(&quot;unreachable&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果是非阻塞并且队列为空并且channel未关闭就返回false</span><br><span class="line">if !block &amp;&amp; (c.dataqsiz &#x3D;&#x3D; 0 &amp;&amp; c.sendq.first &#x3D;&#x3D; nil ||</span><br><span class="line">c.dataqsiz &gt; 0 &amp;&amp; atomic.Loaduint(&amp;c.qcount) &#x3D;&#x3D; 0) &amp;&amp;</span><br><span class="line">atomic.Load(&amp;c.closed) &#x3D;&#x3D; 0 &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var t0 int64</span><br><span class="line">if blockprofilerate &gt; 0 &#123;</span><br><span class="line">t0 &#x3D; cputicks()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果channel已关闭, 并且没有数据了就清除ep中的数据立刻返回</span><br><span class="line">if c.closed !&#x3D; 0 &amp;&amp; c.qcount &#x3D;&#x3D; 0 &#123;</span><br><span class="line">if raceenabled &#123;</span><br><span class="line">raceacquire(c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line">if ep !&#x3D; nil &#123;</span><br><span class="line">typedmemclr(c.elemtype, ep)</span><br><span class="line">&#125;</span><br><span class="line">return true, false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果已经有goroutine等着了，就直接让这个goroutine recive</span><br><span class="line">if sg :&#x3D; c.sendq.dequeue(); sg !&#x3D; nil &#123;</span><br><span class="line">recv(c, sg, ep, func() &#123; unlock(&amp;c.lock) &#125;, 3)</span><br><span class="line">return true, true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; channel不为空将元素复制到ep中(ep :&#x3D; &lt;- c)</span><br><span class="line">if c.qcount &gt; 0 &#123;</span><br><span class="line">&#x2F;&#x2F; Receive directly from queue</span><br><span class="line">qp :&#x3D; chanbuf(c, c.recvx)</span><br><span class="line">if raceenabled &#123;</span><br><span class="line">raceacquire(qp)</span><br><span class="line">racerelease(qp)</span><br><span class="line">&#125;</span><br><span class="line">if ep !&#x3D; nil &#123;</span><br><span class="line">typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">&#125;</span><br><span class="line">typedmemclr(c.elemtype, qp)</span><br><span class="line">c.recvx++</span><br><span class="line">if c.recvx &#x3D;&#x3D; c.dataqsiz &#123;</span><br><span class="line">c.recvx &#x3D; 0</span><br><span class="line">&#125;</span><br><span class="line">c.qcount--</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line">return true, true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果是非阻塞直接返回false</span><br><span class="line">if !block &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line">return false, false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取当前goroutine</span><br><span class="line">gp :&#x3D; getg()</span><br><span class="line">&#x2F;&#x2F; 创建sudog</span><br><span class="line">mysg :&#x3D; acquireSudog()</span><br><span class="line">mysg.releasetime &#x3D; 0</span><br><span class="line">if t0 !&#x3D; 0 &#123;</span><br><span class="line">mysg.releasetime &#x3D; -1</span><br><span class="line">&#125;</span><br><span class="line">mysg.elem &#x3D; ep</span><br><span class="line">mysg.waitlink &#x3D; nil</span><br><span class="line">gp.waiting &#x3D; mysg</span><br><span class="line">mysg.g &#x3D; gp</span><br><span class="line">mysg.isSelect &#x3D; false</span><br><span class="line">mysg.c &#x3D; c</span><br><span class="line">gp.param &#x3D; nil</span><br><span class="line">c.recvq.enqueue(mysg)</span><br><span class="line">goparkunlock(&amp;c.lock, waitReasonChanReceive, traceEvGoBlockRecv, 3)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; someone woke us up</span><br><span class="line">if mysg !&#x3D; gp.waiting &#123;</span><br><span class="line">throw(&quot;G waiting list is corrupted&quot;)</span><br><span class="line">&#125;</span><br><span class="line">gp.waiting &#x3D; nil</span><br><span class="line">if mysg.releasetime &gt; 0 &#123;</span><br><span class="line">blockevent(mysg.releasetime-t0, 2)</span><br><span class="line">&#125;</span><br><span class="line">closed :&#x3D; gp.param &#x3D;&#x3D; nil</span><br><span class="line">gp.param &#x3D; nil</span><br><span class="line">mysg.c &#x3D; nil</span><br><span class="line">releaseSudog(mysg)</span><br><span class="line">return true, !closed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-关闭channel"><a href="#3-3-关闭channel" class="headerlink" title="3.3 关闭channel"></a>3.3 关闭channel</h2><p>关闭channel大概逻辑就是，将buffer中的数据都释放掉，然后close设置为0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">func closechan(c *hchan) &#123;</span><br><span class="line">&#x2F;&#x2F; 如果为空抛出异常</span><br><span class="line">if c &#x3D;&#x3D; nil &#123;</span><br><span class="line">panic(plainError(&quot;close of nil channel&quot;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line">&#x2F;&#x2F; 如果channel已经关闭就抛出异常</span><br><span class="line">if c.closed !&#x3D; 0 &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line">panic(plainError(&quot;close of closed channel&quot;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if raceenabled &#123;</span><br><span class="line">callerpc :&#x3D; getcallerpc()</span><br><span class="line">racewritepc(c.raceaddr(), callerpc, funcPC(closechan))</span><br><span class="line">racerelease(c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.closed &#x3D; 1</span><br><span class="line"></span><br><span class="line">var glist gList</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 清理所有的数据</span><br><span class="line">&#x2F;&#x2F; release all readers</span><br><span class="line">for &#123;</span><br><span class="line">sg :&#x3D; c.recvq.dequeue()</span><br><span class="line">if sg &#x3D;&#x3D; nil &#123;</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">if sg.elem !&#x3D; nil &#123;</span><br><span class="line">typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">sg.elem &#x3D; nil</span><br><span class="line">&#125;</span><br><span class="line">if sg.releasetime !&#x3D; 0 &#123;</span><br><span class="line">sg.releasetime &#x3D; cputicks()</span><br><span class="line">&#125;</span><br><span class="line">gp :&#x3D; sg.g</span><br><span class="line">gp.param &#x3D; nil</span><br><span class="line">if raceenabled &#123;</span><br><span class="line">raceacquireg(gp, c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line">glist.push(gp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; release all writers (they will panic)</span><br><span class="line">for &#123;</span><br><span class="line">sg :&#x3D; c.sendq.dequeue()</span><br><span class="line">if sg &#x3D;&#x3D; nil &#123;</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">sg.elem &#x3D; nil</span><br><span class="line">if sg.releasetime !&#x3D; 0 &#123;</span><br><span class="line">sg.releasetime &#x3D; cputicks()</span><br><span class="line">&#125;</span><br><span class="line">gp :&#x3D; sg.g</span><br><span class="line">gp.param &#x3D; nil</span><br><span class="line">if raceenabled &#123;</span><br><span class="line">raceacquireg(gp, c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line">glist.push(gp)</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Ready all Gs now that we&#39;ve dropped the channel lock.</span><br><span class="line">for !glist.empty() &#123;</span><br><span class="line">gp :&#x3D; glist.pop()</span><br><span class="line">gp.schedlink &#x3D; 0</span><br><span class="line">goready(gp, 3)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="chan-dot"><a href="#chan-dot" class="headerlink" title="chan.dot"></a>chan.dot</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">digraph &#123;</span><br><span class="line">    bgcolor&#x3D;&quot;#C6CFD532&quot;; </span><br><span class="line"></span><br><span class="line">    node [shape&#x3D;record, fontsize&#x3D;&quot;8&quot;, margin&#x3D;&quot;0.04&quot;, height&#x3D;0.2, color&#x3D;gray] </span><br><span class="line">edge [fontname&#x3D;&quot;Inconsolata, Consolas&quot;, fontsize&#x3D;10, arrowhead&#x3D;normal]</span><br><span class="line"></span><br><span class="line">    hchan [shape&#x3D;record,label&#x3D;&quot;&#123;qcount|dataqsiz|buf|elemsize|closed|elemtype|&lt;sendx&gt;sendx|&lt;recvx&gt;recvx|recvq|sendq|lock&#125;&quot;,xlabel&#x3D;&quot;hchan&quot;]</span><br><span class="line">    waitq[shape&#x3D;record,label&#x3D;&quot;&#123;&lt;first&gt;first|&lt;last&gt;last&#125;&quot;,xlabel&#x3D;&quot;waitq&quot;]</span><br><span class="line">    sudog[shape&#x3D;record,label&#x3D;&quot;&#123;g|isSelect|next|prev|elem|acquiretime|releasetime|ticket|parent|waitlink|waittail|c&#125;&quot;,xlabel&#x3D;&quot;sudog&quot;]</span><br><span class="line"></span><br><span class="line">    hchan:sendx -&gt; waitq [label&#x3D;&quot;发送队列&quot;]</span><br><span class="line">    hchan:recvx -&gt; waitq [label&#x3D;&quot;接收队列&quot;]</span><br><span class="line">    waitq:first -&gt; sudog</span><br><span class="line">    waitq:last -&gt; sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;(年初的时候go语言的学习提上了日程，前一篇sync.pool阅读之后，阅读代码进度本该更快些，奈何身体被掏空，所以这篇文章断断续续一个月终于攒起来了。)&lt;/p&gt;</summary>
    
    
    
    
    <category term="Golang" scheme="https://journey-c.github.io/tags/Golang/"/>
    
    <category term="源码" scheme="https://journey-c.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="https://journey-c.github.io/2020/10/22/red-black-tree/"/>
    <id>https://journey-c.github.io/2020/10/22/red-black-tree/</id>
    <published>2020-10-22T15:17:39.683Z</published>
    <updated>2020-12-12T19:06:30.196Z</updated>
    
    <content type="html"><![CDATA[<p>红黑树是一种自平衡二叉搜索树。二叉搜索树就是插入的时候，比当前节点小的放到左子树，大的放到右子树。这样查找的时候可以沿着树的一条路径找到想要的值，所以时间复杂度是树的深度，最坏$O(N)$，平均$O(lg^N)$。</p><p>正因为二叉搜索树由于数据的不确定性可能造成树建的不平衡，导致树过深，时间复杂度过高。所以出现了自平衡二叉搜索树像红黑树。</p><p>红黑树所有的性质和特点都是想让树尽可能的平衡。</p><p><img src="/images/rbtree.jpg" alt="rbtree"></p><div>    <center>图片引自《算法导论》第三版</center></div><h1 id="1-性质"><a href="#1-性质" class="headerlink" title="1. 性质"></a>1. 性质</h1><ol><li>每个节点或是红色，或是黑色</li><li>根结点是黑色</li><li>每个叶节点(NIL)是黑色</li><li>如果一个节点是红色，则它两个子节点必须是黑色</li><li>对每个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点</li></ol><p>另外其他二叉树叶子结点一般为nil，红黑树为了节省内存空间，将所有叶子节点指向一个哨兵节点，哨兵节点color为BLACK，其他属性p、left、right、key为任意值，根结点的父节点也指向哨兵节点。</p><h1 id="2-为什么红黑树可以平衡"><a href="#2-为什么红黑树可以平衡" class="headerlink" title="2. 为什么红黑树可以平衡"></a>2. 为什么红黑树可以平衡</h1><h2 id="2-1-引理"><a href="#2-1-引理" class="headerlink" title="2.1 引理"></a>2.1 引理</h2><blockquote><p>一棵有n个内部节点的红黑树的高度至多为$2lg^{(n+1)}$</p></blockquote><p>如果可以证明上述引理，那么红黑树的查找最坏的时间复杂度也是$O(2lg^{(n+1)})$，因为在一棵高度为h的树上操作时间复杂度是$O(h)$，就是咱们要的平衡。</p><h2 id="2-2-证明"><a href="#2-2-证明" class="headerlink" title="2.2 证明"></a>2.2 证明</h2><p>首先证明<font color=red>红黑树以任意一个节点x为根的子树中至少包含$2^{bh(x)}-1$个内部节点</font>(从节点x出发，不包含x到达一个叶子节点的任意一条简单路径上黑节点的个数成为x节点的黑高，记为$bh(x)$)。</p><p>下面用数学归纳法证明</p><ul><li><p>当高度为0时<br>即子树为空，满足内部节点不超过$2^{0}-1=0$的要求。</p></li><li><p>当高度为k时<br>假设以x为根的子树内部节点不超过$2^{bh(x)}-1$。</p></li><li><p>当高度为k-1时<br>即当前节点是x(这个x节点是高度为k时假设的那个)的儿子，黑高为$bh(x)$或$bh(x)-1$，取决于儿子是黑还是红。所以以儿子节点为根的子树至少有$2^{bh(x)-1}-1$内部节点。于是，<font color=red>由儿子节点推父节点x内部节点的个数不超过$(2^{bh(x)-1}-1)+(2^{bh(x)-1}-1)=(2^{bh(x)}-1)$</font>，由此假设成立。</p></li></ul><p>现在来证明引理。设h为树的高度，根据性质4得出从根节点到叶节点的任何一条简单路径上都至少有一半节点是黑色，所以根的黑高至少时h/2。于是有</p><center>$n \geq 2^{h/2}-1$</center><p>n为树的节点个数，这个公式上边证明过了。将1放到左边，然后取对数得到</p><center>$lg^{(n+1)} \geq h/2 $</center><p>由此得到结论，高度小于等于$2lg^{(n+1)}$，所以只要满足红黑树性质的n节点二叉树高度最大为$2lg^{(n+1)}$。</p><center>$h \leq 2lg^{(n+1)}$</center><h1 id="3-红黑树如何实现自平衡"><a href="#3-红黑树如何实现自平衡" class="headerlink" title="3. 红黑树如何实现自平衡"></a>3. 红黑树如何实现自平衡</h1><h2 id="3-1-旋转"><a href="#3-1-旋转" class="headerlink" title="3.1 旋转"></a>3.1 旋转</h2><p>由于插入和删除操作会对红黑树修改，有可能会不符合红黑树的性质，所以必须通过调整节点的颜色和指针结构来重新满足性质，而调整指针结构的操作是旋转，有左旋、右旋。<br><strong>下图α,β,γ代表一棵子树(可能为空)</strong></p><p><img src="/images/rotate.png" alt="rotate"></p><h3 id="3-1-1-左旋"><a href="#3-1-1-左旋" class="headerlink" title="3.1.1 左旋"></a>3.1.1 左旋</h3><p>上图为例，左旋就是从右边树结构变成左边树结构的操作。<br>当在某点例如x点做左旋时: </p><ol><li>以x-y这条路径当轴，逆时针旋转(左旋)，x变成y的左儿子，y到原来x的位置。</li><li>因为x变成了y的左儿子，所以要考虑y之前是否有左儿子，如果有的话就要将左儿子β在左子树中重新找位置了，之前β是在x的右边所以比x大，刚好x的右儿子旋转后是空的，所以β就放到x的右儿子的位置。就得到了左边树的结构。</li></ol><h3 id="3-1-2-右旋"><a href="#3-1-2-右旋" class="headerlink" title="3.1.2 右旋"></a>3.1.2 右旋</h3><p>和左旋步骤是一样的，方向相反。</p><h2 id="3-2-插入"><a href="#3-2-插入" class="headerlink" title="3.2 插入"></a>3.2 插入</h2><ol><li>插入节点颜色设置为红色。</li><li>首先从根结点开始遍历，插入节点比当前节点小就去左子树，否则就去右子树，直到遍历到叶子结点，然后比较插入节点和父节点大小选择作为父节点的左儿子还是右儿子。</li><li>现在已经将节点插入了，由于插入节点颜色是红色，所以可能破坏红节点儿子只能是黑节点的性质。所以从插入节点向上遍历修复破坏性质的地方，直到完全符合性质。</li></ol><h3 id="3-2-1-修复"><a href="#3-2-1-修复" class="headerlink" title="3.2.1 修复"></a>3.2.1 修复</h3><p>回想一下插入新节点的过程，然后对比一下可能违反什么性质。</p><table><thead><tr><th>性质编号</th><th>描述</th><th>是否可能违反</th></tr></thead><tbody><tr><td>1</td><td>每个节点或是红色，或是黑色</td><td>不会违反，除非插入第三种颜色</td></tr><tr><td>2</td><td>根结点是黑色</td><td>可能违反，只有树为空的时候，插入节点(红色)作为根结点</td></tr><tr><td>3</td><td>每个叶节点(NIL)是黑色</td><td>不会违反，插入节点不会改变叶节点的颜色，叶节点永远都是T.nil</td></tr><tr><td>4</td><td>如果一个节点是红色，则它两个子节点必须是黑色</td><td>可能违反，只有插入节点的父节点是红色时，会违反这条性质</td></tr><tr><td>5</td><td>对每个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点</td><td>不会违反，插入节点为红色，不会改变每条路径上黑色的数量</td></tr></tbody></table><p>对比过后发现，可能违反的性质有2、4。并且同一时间只可能违反其一，如果违反性质2，说明树为空插入节点为根结点，根结点的父节点是T.nil(黑色)不违反性质4。如果违反性质4，那么插入节点的父节点一定是红色，说明树一定不是空的(为空的话，插入节点的父节点应该是T.nil黑色)，并且只有树为空的情况插入才会影响根结点颜色，所以也不可能违反性质2。</p><p>现在可能破坏的地方分析清楚了，就可以开始梳理如何修复了，并且修复操作不能造成二次破坏导致不符合其他性质。 </p><ul><li><p>违反性质1<br>只需要把根结点直接设置为黑色即可。因为违反性质1的时候，树中只有插入节点一个节点，所以修复结束。</p></li><li><p>违反性质4<br>违反性质4是因为插入节点和父节点都是红色，情况比较复杂，具体分6类。从插入节点往上遍历，针对不同的case采取不同的fix方式，直到父节点是黑色或者到根结点即停止遍历。</p></li></ul><p><strong>指针指向的位置初始时在插入位置</strong></p><h4 id="3-2-1-1-case-1"><a href="#3-2-1-1-case-1" class="headerlink" title="3.2.1.1 case 1"></a>3.2.1.1 case 1</h4><blockquote><p>1.入节点是父节点是祖父节点的左儿子<br>2.入节点叔节点是红色<br>**(z是插入节点，p是父节点，u是叔节点，g是祖父节点)**</p></blockquote><p><img src="/images/insert_case1.png" alt="insert_case1"></p><blockquote><p>这种情况将父节点和叔节点变为黑色，祖父节点变为红色，指针指向祖父节点(上移两层)然后继续判断。</p></blockquote><p><img src="/images/insert_case1_fix.png" alt="insert_case1_fix"></p><p><em>这一步祖父节点可能是根结点，所以在修复完违反性质4的情况之后，再把根结点设置为黑色，避免再违反性质1</em></p><h4 id="3-2-1-2-case-2"><a href="#3-2-1-2-case-2" class="headerlink" title="3.2.1.2 case 2"></a>3.2.1.2 case 2</h4><blockquote><p>1.插入节点是父节点是祖父节点的左儿子<br>2.插入节点叔节点是黑色<br>3.插入节点是父节点右儿子<br>**(z是插入节点，b是兄弟节点，p是父节点，u是叔节点，g是祖父节点)**</p></blockquote><p><img src="/images/insert_case2.png" alt="insert_case2"></p><blockquote><p>关于父节点做左旋，就可以变为case 3。</p></blockquote><h4 id="3-2-1-3-case-3"><a href="#3-2-1-3-case-3" class="headerlink" title="3.2.1.3 case 3"></a>3.2.1.3 case 3</h4><blockquote><p>1.插入节点是父节点是祖父节点的左儿子<br>2.插入节点叔节点是黑色<br>3.插入节点是父节点左儿子<br>**(z是插入节点，b是兄弟节点，p是父节点，u是叔节点，g是祖父节点)**</p></blockquote><p><img src="/images/insert_case3.png" alt="insert_case3"></p><blockquote><p>将父节点变为黑色，祖父节点变为红色，然后关于祖父节点做右旋得到下图(关系还是按照旋转前定的)</p></blockquote><p><img src="/images/insert_case3_fix.png" alt="insert_case3_fix"></p><blockquote><p>case3修复之后，看上图，就没有可能违反性质的地方了，修复结束。</p></blockquote><p><strong><em>case 4,5,6是插入节点的父节点是父节点右儿子的情况，和前三种对称，这里就略过了。</em></strong></p><h3 id="3-2-2-插入节点为什么设置为红色"><a href="#3-2-2-插入节点为什么设置为红色" class="headerlink" title="3.2.2 插入节点为什么设置为红色?"></a>3.2.2 插入节点为什么设置为红色?</h3><p>如果设置为黑色的话，会破坏每点到叶节点简单路径上黑色节点数量相同的性质了，修复起来情况就复杂了，相比之下就比如直接设置为红色。</p><h3 id="3-2-3-小结"><a href="#3-2-3-小结" class="headerlink" title="3.2.3 小结"></a>3.2.3 小结</h3><p>到现在插入步骤已经清晰了:</p><ul><li>按照普通二叉树插入方式插入节点</li><li>从插入节点开始往上看看有没有违反性质的地方，只有父节点是红色的情况会违反性质4(违反性质2的情况不要考虑，只需要在修复结束时，强制把根节点设为黑色即可)</li><li>遇到父节点是红色的情况就需要修复了(以下情况都假设插入节点的父节点是祖父节点的左儿子，右儿子的情况修复方式相反)<blockquote><ol><li>叔节点是红色的(case 1), 就把父节点和叔节点都变为黑色，祖父节点变为红色，然后指针指向祖父节点继续向上遍历，直到根节点或者指针的父节点是黑色就结束。</li><li>叔节点是黑色，插入节点是父节点右儿子(case 2)，关于父节点做个左旋变成case 3</li><li>叔节点是黑色，插入节点是父节点左儿子(case 3)，父节点变为黑色，祖父变红色，然后关于祖父节点做右旋，修复结束。</li></ol></blockquote></li></ul><p>大概就是，遇到case 1把错误交给上层，然后一层层遍历上去。遇到case 2变为case 3，case 3可以直接修复。</p><blockquote><p>所以插入及修复只是在二叉树的一条路径上操作，时间复杂度是$O(lg^N)$。</p></blockquote><h2 id="3-3-删除"><a href="#3-3-删除" class="headerlink" title="3.3 删除"></a>3.3 删除</h2><p>删除和普通的搜索二叉树的删除差不多，唯一的不同就是要记录减少的颜色，因为可能破坏红黑树的性质。 </p><p>初始情况下y指向z<br><em>z为要删除节点，p为父节点，l为z左儿子，r为z右儿子</em></p><ol><li>z没有子节点</li></ol><p><img src="/images/delete_case1.png" alt="delete_case1"></p><blockquote><p>直接删除z，z的父节点的儿子指向T.nil。</p></blockquote><p><img src="/images/delete_case1_op.png" alt="delete_case1_op"></p><ol start="2"><li>z只有右儿子</li></ol><p><img src="/images/delete_case2.png" alt="delete_case2"></p><blockquote><p>将z的右子树提到z的位置。</p></blockquote><p><img src="/images/delete_case2_op.png" alt="delete_case2_op"></p><ol start="3"><li>z只有左儿子</li></ol><p><img src="/images/delete_case3.png" alt="delete_case3"></p><blockquote><p>将z的左子树提到z的位置。</p></blockquote><p><img src="/images/delete_case3_op.png" alt="delete_case3_op"></p><ol start="4"><li>z有两个儿子</li></ol><p><img src="/images/delete_case4.png" alt="delete_case4"></p><blockquote><p>找到后继节点y(比z大的最小的那个)，用y替换z的位置，颜色设置为z的颜色，这样y原来的位置就空了，将y的右子树x(如果有)提到y原来的位置。</p></blockquote><p><img src="/images/delete_case4_op.png" alt="delete_case4_op"></p><h3 id="3-3-1-修复解析"><a href="#3-3-1-修复解析" class="headerlink" title="3.3.1 修复解析"></a>3.3.1 修复解析</h3><blockquote><p>y: 代表要z或者z的后继节点(case 4)<br>x: 代表不违反性质的最低节点(x往下就没操作过，要修复的话，从x向上遍历修复)<br>    case 1: x为nil<br>    case 2,3: x为z的唯一的那个儿子(因为儿子子树内部没变过，只需要修复往上)<br>    case 4: x为z后继的右儿子</p></blockquote><p>删除操作完成之后，相当于少了y指向节点的颜色，所以只要y是黑色节点，就会产生违反性质的情况。</p><blockquote><ol><li>如果y是根结点，删除y后，如果提到y位置节点颜色是红色就违反了性质2。(性质2最好修复，所有修复操作完成后直接把根变为黑色就行)</li><li>如果x是红色，并且x的父节点也是红色，就违反性质4。</li><li>因为y是黑色节点，所以删掉后经过y的路径上黑色节点都少1就违反性质5了，解决这个问题的办法是假设x除了自身颜色外还有一层黑色，就是双重颜色，所以现在x违反性质1。</li></ol></blockquote><table><thead><tr><th>性质编号</th><th>描述</th><th>是否可能违反</th></tr></thead><tbody><tr><td>1</td><td>每个节点或是红色，或是黑色</td><td>可能违反，x有双重颜色时违反</td></tr><tr><td>2</td><td>根结点是黑色</td><td>可能违反，y是根结点，并且后续一个红色节点代替了上来，那么根节点就是红色</td></tr><tr><td>3</td><td>每个叶节点(NIL)是黑色</td><td>不会违反</td></tr><tr><td>4</td><td>如果一个节点是红色，则它两个子节点必须是黑色</td><td>可能违反，情况4(两个儿子)，后继节点的父亲是红色，右儿子是红色，那么右儿子提上来之后就父子都是红色</td></tr><tr><td>5</td><td>对每个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点</td><td>不会违反</td></tr></tbody></table><p><strong>现在可能违反的性质有1，2，4</strong></p><h3 id="3-3-2-修复策略"><a href="#3-3-2-修复策略" class="headerlink" title="3.3.2 修复策略"></a>3.3.2 修复策略</h3><p>因为删除操作后，红黑树少了一个黑色，所以把这个黑色放在x，x变为双重颜色(下图用紫色表示)。</p><ul><li>如果x原来是红色，刚好将x变为黑色，修复完成。</li><li>如果x原来是黑色，那么x为双重黑色，下面就是剖析如果修复x的双重黑色。</li></ul><p>修复是从x向上遍历，因为x为根的子树没有做过操作(删除操作的时候记录下来)，所以不会违反性质。修复策略分为四种情况:(以下情况都是x为父节点左儿子的情况，右儿子的情况相反而已)</p><h4 id="3-3-2-1-case-1"><a href="#3-3-2-1-case-1" class="headerlink" title="3.3.2.1 case 1"></a>3.3.2.1 case 1</h4><blockquote><p>x的兄弟节点w是红色 </p></blockquote><p><img src="/images/delete_fix_case1.png" alt="delete_fix_case1"></p><blockquote><p>此时: 1) 因为w是红色，所以p是黑色。 2) 因为x是双重黑色，所以w一定有儿子且w的子节点是黑色。如果没有，那么从p到叶子各路径上的黑节点数量就不一样了。<br>措施:</p><ul><li>将w变为黑色，p变为红色，且对p做左旋，就变成case 2</li><li>操作前l，r，x到p的父节点之前的路径有1个黑色节点(p)，操作后还是1个(w)，所以没改变黑色个数的性质。且x有黑色性质，所以p为红色也没违反性质。</li></ul></blockquote><p><img src="/images/delete_fix_case1_fix.png" alt="delete_fix_case1_fix"></p><h4 id="3-3-2-2-case-2"><a href="#3-3-2-2-case-2" class="headerlink" title="3.3.2.2 case 2"></a>3.3.2.2 case 2</h4><blockquote><p>x的兄弟节点w是黑色，且w的两个子节点是黑色</p></blockquote><p><img src="/images/delete_fix_case2.png" alt="delete_fix_case2"></p><div><center>因为w是黑色，所以p不确定是什么颜色，用白色表示<center></div><blockquote><p>w是黑色且x本来就一层黑色，所以从x，w上去掉一层黑色。将这层黑色加到x的父节点身上，指针指向x的父节点。<br>黑色加到x的父节点之后，有两种情况:</p><ul><li>x的父节点原来是红色，这种情况就不是双重黑色了，直接将x的父节点变为黑色，修复结束。</li><li>x的父节点原来是黑色，那么继续遍历，一直将双重黑色传递至根，这样去掉一重黑色，相当于所有路径都去了一个黑节点，依然满足性质。</li></ul></blockquote><p><img src="/images/delete_fix_case2_fix.png" alt="delete_fix_case2_fix"></p><h4 id="3-3-2-3-case-3"><a href="#3-3-2-3-case-3" class="headerlink" title="3.3.2.3 case 3"></a>3.3.2.3 case 3</h4><blockquote><p>x的兄弟节点w是黑色，且w的左儿子是红色，右儿子是黑色</p></blockquote><p><img src="/images/delete_fix_case3.png" alt="delete_fix_case3"></p><div><center>因为w是黑色，所以p不确定是什么颜色，用白色表示<center></div><blockquote><p>交换w和左儿子的颜色，然后关于w做一次右旋，变成case 4。黑色节点的个数都没有变，所以没改变性质。</p></blockquote><p><img src="/images/delete_fix_case3_fix.png" alt="delete_fix_case3_fix"></p><div><center>因为w是黑色，所以p不确定是什么颜色，用白色表示<center></div><h4 id="3-3-2-4-case-4"><a href="#3-3-2-4-case-4" class="headerlink" title="3.3.2.4 case 4"></a>3.3.2.4 case 4</h4><blockquote><p>x的兄弟节点w是黑色，且w的右儿子是红色</p></blockquote><p><img src="/images/delete_fix_case4.png" alt="delete_fix_case4"></p><div><center>p的颜色未知，l的颜色随便，用白色表示<center></div><blockquote><p>交换w和p的颜色，w的右儿子变成黑色，关于p做一次左旋，循环结束。看下图:</p><ol><li>x的黑色节点相当于转移到p身上了，而w为p之前的颜色，所以是黑是红都不违反性质</li><li>l到原p的父亲中间有1个黑(原w)+1个可能黑(原p)，操作后1个黑(p)+1个可能黑(w)所以刚好也不违反性质，操作后x的双重颜色成功被去掉，结束修复。</li></ol></blockquote><p><img src="/images/delete_fix_case4_fix.png" alt="delete_fix_case4"></p><div><center>w为p之前的颜色(未知)，l颜色随便，用白色表示<center></div><h3 id="3-3-4-小结"><a href="#3-3-4-小结" class="headerlink" title="3.3.4 小结"></a>3.3.4 小结</h3><p>按照正常二叉树删除<br>修复:</p><ul><li>遇到case 1转case 2，然后一层层向上转移双色节点。</li><li>遇到case 3转case 4，能将多余一层黑色去掉，修复结束。</li></ul><h1 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4. 代码实现"></a>4. 代码实现</h1><p><a href="https://github.com/journey-c/rbtree">代码地址</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;红黑树是一种自平衡二叉搜索树。二叉搜索树就是插入的时候，比当前节点小的放到左子树，大的放到右子树。这样查找的时候可以沿着树的一条路径找到想要的值，所以时间复杂度是树的深度，最坏$O(N)$，平均$O(lg^N)$。&lt;/p&gt;
&lt;p&gt;正因为二叉搜索树由于数据的不确定性可能造成树建的不平衡，导致树过深，时间复杂度过高。所以出现了自平衡二叉搜索树像红黑树。&lt;/p&gt;
&lt;p&gt;红黑树所有的性质和特点都是想让树尽可能的平衡。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/rbtree.jpg&quot; alt=&quot;rbtree&quot;&gt;&lt;/p&gt;
&lt;div&gt;
    &lt;center&gt;图片引自《算法导论》第三版&lt;/center&gt;
&lt;/div&gt;

&lt;h1 id=&quot;1-性质&quot;&gt;&lt;a href=&quot;#1-性质&quot; class=&quot;headerlink&quot; title=&quot;1. 性质&quot;&gt;&lt;/a&gt;1. 性质&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;每个节点或是红色，或是黑色&lt;/li&gt;
&lt;li&gt;根结点是黑色&lt;/li&gt;
&lt;li&gt;每个叶节点(NIL)是黑色&lt;/li&gt;
&lt;li&gt;如果一个节点是红色，则它两个子节点必须是黑色&lt;/li&gt;
&lt;li&gt;对每个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外其他二叉树叶子结点一般为nil，红黑树为了节省内存空间，将所有叶子节点指向一个哨兵节点，哨兵节点color为BLACK，其他属性p、left、right、key为任意值，根结点的父节点也指向哨兵节点。&lt;/p&gt;
&lt;h1 id=&quot;2-为什么红黑树可以平衡&quot;&gt;&lt;a href=&quot;#2-为什么红黑树可以平衡&quot; class=&quot;headerlink&quot; title=&quot;2. 为什么红黑树可以平衡&quot;&gt;&lt;/a&gt;2. 为什么红黑树可以平衡&lt;/h1&gt;&lt;h2 id=&quot;2-1-引理&quot;&gt;&lt;a href=&quot;#2-1-引理&quot; class=&quot;headerlink&quot; title=&quot;2.1 引理&quot;&gt;&lt;/a&gt;2.1 引理&lt;/h2&gt;</summary>
    
    
    
    
    <category term="算法" scheme="https://journey-c.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="https://journey-c.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>goroutine 源码阅读</title>
    <link href="https://journey-c.github.io/2020/10/21/goroutine-read/"/>
    <id>https://journey-c.github.io/2020/10/21/goroutine-read/</id>
    <published>2020-10-21T14:48:39.387Z</published>
    <updated>2020-11-19T03:24:52.172Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1.数据结构"></a>1.数据结构</h1><p>调度相关的数据结构有三个，M(线程)，P(调度器)，G(goroutine)<br>M表示线程，P作为调度器用来帮助每个线程管理自己的goroutine，G就是golang的协程。我们可以通过runtime.GOMAXPROCS(n int)函数设置P的个数，<strong>注意</strong>P的个数并不代表M的个数，例如程序启动时runtime代码会出实话procs个P，但开始的时候只会启动一个M，就是M0和一个栈为64K(其他goroutine默认初始栈大小2K)来执行runtime代码。</p><a id="more"></a><p><strong>那其他线程是什么时候创建的呐?</strong><br>当goroutine被唤醒时，要在M上运行(恢复goroutine的上下文)，P是帮助M管理goroutine的，恢复上下文的操作也由P来完成。如果被唤醒时发现还有空闲的P，并且没有其他M在窃取goroutine(M发现本地goroutine队列和全局goroutine队列都没有goroutine的时候，会去其他线程窃取goroutine)，说明其他M都在忙，就会创建一个M让这个空闲的P帮他来管理goroutine。<br>总之一句话，开始的时候创建一个M，当发现调度不过来且还有空闲P没有工作就在创建新的，直到创建procs个M(procs通过runtime.GOMAXPROCS设置)</p><p><img src="/images/model.png" alt="model"></p><h2 id="1-1-G"><a href="#1-1-G" class="headerlink" title="1.1 G"></a>1.1 G</h2><p>golang 用结构体g表示goroutine</p><ul><li>g</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">stack       stack   <span class="comment">// 当前栈的范围[stack.lo, stack.hi)</span></span><br><span class="line">stackguard0 <span class="keyword">uintptr</span> <span class="comment">// 用于抢占的，一般情况值为stack.lo + StackGuard</span></span><br><span class="line">stackguard1 <span class="keyword">uintptr</span> <span class="comment">// 用于C语言的抢占</span></span><br><span class="line">_panic         *_panic <span class="comment">// 最内侧的panic函数</span></span><br><span class="line">_defer         *_defer <span class="comment">// 最外侧的defer函数</span></span><br><span class="line">m              *m      <span class="comment">// 当前goroutine属于哪个m</span></span><br><span class="line">sched          gobuf <span class="comment">// 调度相关信息</span></span><br><span class="line">...</span><br><span class="line">schedlink      guintptr <span class="comment">// sched是全局的goroutine链表，schedlink表示这个goroutine在链表中的下一个goroutine的指针</span></span><br><span class="line">...</span><br><span class="line">preempt        <span class="keyword">bool</span>       <span class="comment">// 抢占标志，如果需要抢占就将preempt设置为true</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>gobuf<br>gobuf保存goroutine的调度信息，当一个goroutine被调度的时，本质上就是把这个goroutine放到cpu，恢复各个寄存器的值，然后运行</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> gobuf <span class="keyword">struct</span> &#123;</span><br><span class="line">sp   <span class="keyword">uintptr</span> <span class="comment">// 栈指针</span></span><br><span class="line">pc   <span class="keyword">uintptr</span> <span class="comment">// 程序计数器</span></span><br><span class="line">g    guintptr <span class="comment">// 当前被哪个goroutine持有</span></span><br><span class="line">ctxt unsafe.Pointer</span><br><span class="line">ret  sys.Uintreg <span class="comment">// 系统调用返回值，防止系统调用后被其他goroutine抢占，所以有个地方保存返回值</span></span><br><span class="line">lr   <span class="keyword">uintptr</span></span><br><span class="line">bp   <span class="keyword">uintptr</span> <span class="comment">// 保存CPU的rip寄存器的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-M"><a href="#1-2-M" class="headerlink" title="1.2 M"></a>1.2 M</h2><p>golang中M表示实际操作系统的线程</p><ul><li>m</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;</span><br><span class="line">g0      *g     <span class="comment">// g0帮M处理大小事务的goroutine，他是m中的第一个goroutine</span></span><br><span class="line">...</span><br><span class="line">gsignal       *g           <span class="comment">// 用于信号处理的goroutine</span></span><br><span class="line">tls           [<span class="number">6</span>]<span class="keyword">uintptr</span>   <span class="comment">// 线程私有空间</span></span><br><span class="line">mstartfn      <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">curg          *g       <span class="comment">// current running goroutine</span></span><br><span class="line">...</span><br><span class="line">p             puintptr <span class="comment">// 当前正在运行的p(处理器)</span></span><br><span class="line">nextp         puintptr <span class="comment">// 暂存的p</span></span><br><span class="line">oldp          puintptr <span class="comment">// 执行系统调用之前的p</span></span><br><span class="line">...</span><br><span class="line">spinning      <span class="keyword">bool</span> <span class="comment">// 表示当前m没有goroutine了，正在从其他m偷取goroutine</span></span><br><span class="line">blocked       <span class="keyword">bool</span> <span class="comment">// m is blocked on a note</span></span><br><span class="line">...</span><br><span class="line">park          note <span class="comment">// m没有goroutine的时候会在park上sleep，需要其他m在park中wake up这个m</span></span><br><span class="line">alllink       *m <span class="comment">// on allm // 所有m的链表</span></span><br><span class="line">...</span><br><span class="line">thread        <span class="keyword">uintptr</span> <span class="comment">// thread handle</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-P"><a href="#1-3-P" class="headerlink" title="1.3 P"></a>1.3 P</h2><p>golang中P表示一个调度器，为M提供上下文环境，使得M可以执行多个goroutine</p><ul><li>p</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">m           muintptr   <span class="comment">// 与哪个M关联(可能为空的)</span></span><br><span class="line">...</span><br><span class="line">runqhead <span class="keyword">uint32</span> <span class="comment">// p本地goroutine队列的头</span></span><br><span class="line">runqtail <span class="keyword">uint32</span> <span class="comment">// p本地goroutine队列的尾</span></span><br><span class="line">runq     [<span class="number">256</span>]guintptr <span class="comment">// 队列指针，和sync.pool中数据结构一样也是循环队列</span></span><br><span class="line">...</span><br><span class="line">sudogcache []*sudog <span class="comment">// sudog缓存，channel用的</span></span><br><span class="line">sudogbuf   [<span class="number">128</span>]*sudog <span class="comment">// 也是防止false sharing</span></span><br><span class="line">...</span><br><span class="line">pad cpu.CacheLinePad <span class="comment">// 防止false sharing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-schedt"><a href="#1-4-schedt" class="headerlink" title="1.4 schedt"></a>1.4 schedt</h2><p>schedt结构体用来保存P的状态信息和goroutine的全局运行队列</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> schedt <span class="keyword">struct</span> &#123;</span><br><span class="line">...</span><br><span class="line">lock mutex <span class="comment">// 全局锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 维护空闲的M</span></span><br><span class="line">midle        muintptr <span class="comment">// 等待中的M链表</span></span><br><span class="line">nmidle       <span class="keyword">int32</span>    <span class="comment">// 等待中的M的数量</span></span><br><span class="line">nmidlelocked <span class="keyword">int32</span>    <span class="comment">// number of locked m&#x27;s waiting for work</span></span><br><span class="line">mnext        <span class="keyword">int64</span>    <span class="comment">// number of m&#x27;s that have been created and next M ID</span></span><br><span class="line">maxmcount    <span class="keyword">int32</span>    <span class="comment">// 最多创建多少个M(10000)</span></span><br><span class="line">nmsys        <span class="keyword">int32</span>    <span class="comment">// number of system m&#x27;s not counted for deadlock</span></span><br><span class="line">nmfreed      <span class="keyword">int64</span>    <span class="comment">// cumulative number of freed m&#x27;s</span></span><br><span class="line"></span><br><span class="line">ngsys <span class="keyword">uint32</span> <span class="comment">// number of system goroutines; updated atomically</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 维护空闲的P</span></span><br><span class="line">pidle      puintptr <span class="comment">// idle p&#x27;s</span></span><br><span class="line">npidle     <span class="keyword">uint32</span></span><br><span class="line">nmspinning <span class="keyword">uint32</span> <span class="comment">// See &quot;Worker thread parking/unparking&quot; comment in proc.go.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// goroutine的全局队列</span></span><br><span class="line">runq     gQueue</span><br><span class="line">runqsize <span class="keyword">int32</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 全局缓存已经退出的goroutine链表，下次再创建的时候直接用</span></span><br><span class="line"><span class="comment">// Global cache of dead G&#x27;s.</span></span><br><span class="line">gFree <span class="keyword">struct</span> &#123;</span><br><span class="line">lock    mutex</span><br><span class="line">stack   gList <span class="comment">// Gs with stacks</span></span><br><span class="line">noStack gList <span class="comment">// Gs without stacks</span></span><br><span class="line">n       <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-重要的全局变量"><a href="#1-5-重要的全局变量" class="headerlink" title="1.5 重要的全局变量"></a>1.5 重要的全局变量</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">allgs    []*g   <span class="comment">// 保存所有的g</span></span><br><span class="line">allm     *m     <span class="comment">// 所有的m构成的一个链表，包括下面的m0</span></span><br><span class="line">allp     []*p  <span class="comment">// 保存所有的p，len(allp) == gomaxprocs</span></span><br><span class="line"></span><br><span class="line">ncpu         <span class="keyword">int32</span>  <span class="comment">// 系统中cpu核的数量，程序启动时由runtime代码初始化</span></span><br><span class="line">gomaxprocs   <span class="keyword">int32</span>  <span class="comment">// p的最大值，默认等于ncpu，但可以通过GOMAXPROCS修改</span></span><br><span class="line"></span><br><span class="line">sched     schedt    <span class="comment">// 调度器结构体对象，记录了调度器的工作状态</span></span><br><span class="line"></span><br><span class="line">m0 m        <span class="comment">// 代表进程的主线程</span></span><br><span class="line">g0  g       <span class="comment">// m0的g0，也就是m0.g0 = &amp;g0</span></span><br></pre></td></tr></table></figure><h1 id="2-分步骤剖析调度的初始化"><a href="#2-分步骤剖析调度的初始化" class="headerlink" title="2.分步骤剖析调度的初始化"></a>2.分步骤剖析调度的初始化</h1><p>下面是用go实现的hello world，代码里并没有关于调度的初始化，所以程序的入口并非是main.main，下面通过gdb一步步找到go是如何初始化调度的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;hello, world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-1-编译"><a href="#2-1-编译" class="headerlink" title="2.1 编译"></a>2.1 编译</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -gcflags &quot;-N -l&quot; test.go</span><br></pre></td></tr></table></figure><p><strong>使用OS X的同学注意，go1.11之后压缩的debug信息，OS X的同学需要同时做以下设置参考<a href="https://stackoverflow.com/questions/52534287/debug-go-program-with-gdb-on-macos">Debug Go Program With Gdb On Macos</a></strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export GOFLAGS=&quot;-ldflags=-compressdwarf=false&quot;</span><br></pre></td></tr></table></figure><h2 id="2-2-调试"><a href="#2-2-调试" class="headerlink" title="2.2 调试"></a>2.2 调试</h2><ul><li>利用断点可以找出目标文件的信息，在入口处打一个断点，找到程序入口在rt0_darwin_amd64.s的第8行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜  sudo gdb test </span><br><span class="line">(gdb) info files</span><br><span class="line">Symbols from &quot;/Users/journey/workspace/src/tool/gdb/test&quot;.</span><br><span class="line">Local exec file:</span><br><span class="line">`/Users/journey/workspace/src/tool/gdb/test&#x27;, file type mach-o-x86-64.</span><br><span class="line">Entry point: 0x104cd00</span><br><span class="line">0x0000000001001000 - 0x00000000010515b1 is .text</span><br><span class="line">0x00000000010515c0 - 0x000000000108162a is __TEXT.__rodata</span><br><span class="line">0x0000000001081640 - 0x0000000001081706 is __TEXT.__symbol_stub1</span><br><span class="line">0x0000000001081720 - 0x0000000001081e80 is __TEXT.__typelink</span><br><span class="line">0x0000000001081e80 - 0x0000000001081e88 is __TEXT.__itablink</span><br><span class="line">0x0000000001081e88 - 0x0000000001081e88 is __TEXT.__gosymtab</span><br><span class="line">0x0000000001081ea0 - 0x00000000010bfacd is __TEXT.__gopclntab</span><br><span class="line">0x00000000010c0000 - 0x00000000010c0020 is __DATA.__go_buildinfo</span><br><span class="line">0x00000000010c0020 - 0x00000000010c0128 is __DATA.__nl_symbol_ptr</span><br><span class="line">0x00000000010c0140 - 0x00000000010c0d08 is __DATA.__noptrdata</span><br><span class="line">0x00000000010c0d20 - 0x00000000010c27f0 is .data</span><br><span class="line">0x00000000010c2800 - 0x00000000010ddc90 is .bss</span><br><span class="line">0x00000000010ddca0 - 0x00000000010e01e8 is __DATA.__noptrbss</span><br><span class="line">(gdb) b *0x104cd00</span><br><span class="line">Breakpoint 1 at 0x104cd00: file /usr/local/go/src/runtime/rt0_darwin_amd64.s, line 8.</span><br></pre></td></tr></table></figure><ul><li>进入上面找到的文件rt0_darwin_amd64.s(不同的架构文件是不同的)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  runtime ls rt0_*</span><br><span class="line">rt0_aix_ppc64.s       rt0_darwin_amd64.s    rt0_freebsd_arm.s     rt0_linux_arm64.s     rt0_nacl_386.s        rt0_netbsd_arm64.s    rt0_plan9_amd64.s</span><br><span class="line">rt0_android_386.s     rt0_darwin_arm.s      rt0_illumos_amd64.s   rt0_linux_mips64x.s   rt0_nacl_amd64p32.s   rt0_openbsd_386.s     rt0_plan9_arm.s</span><br><span class="line">rt0_android_amd64.s   rt0_darwin_arm64.s    rt0_js_wasm.s         rt0_linux_mipsx.s     rt0_nacl_arm.s        rt0_openbsd_amd64.s   rt0_solaris_amd64.s</span><br><span class="line">rt0_android_arm.s     rt0_dragonfly_amd64.s rt0_linux_386.s       rt0_linux_ppc64.s     rt0_netbsd_386.s      rt0_openbsd_arm.s     rt0_windows_386.s</span><br><span class="line">rt0_android_arm64.s   rt0_freebsd_386.s     rt0_linux_amd64.s     rt0_linux_ppc64le.s   rt0_netbsd_amd64.s    rt0_openbsd_arm64.s   rt0_windows_amd64.s</span><br><span class="line">rt0_darwin_386.s      rt0_freebsd_amd64.s   rt0_linux_arm.s       rt0_linux_s390x.s     rt0_netbsd_arm.s      rt0_plan9_386.s       rt0_windows_arm.s</span><br></pre></td></tr></table></figure><ul><li>打开文件go/src/runtime/rt0_darwin_amd64.s:8<br>这里没有做什么就调了函数_rt0_amd64</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TEXT _rt0_amd64_darwin(SB),NOSPLIT,$<span class="number">-8</span> <span class="comment">// 参数+返回值共8字节</span></span><br><span class="line">JMP_rt0_amd64(SB)</span><br></pre></td></tr></table></figure><ul><li>然后在打断点看看_rt0_amd64在哪<br>在ams_amd64.s第15行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b _rt0_amd64</span><br><span class="line">Breakpoint 2 at 0x1049350: file /usr/local/go/src/runtime/asm_amd64.s, line 15.</span><br></pre></td></tr></table></figure><p>这里首先把参数放到DI，SI寄存器中，然后调用runtime.rt0_go，这就是进程初始化主要函数了<br>参数0放在DI通用寄存器<br>参数1放在SI通用寄存器<br>参数2放在DX通用寄存器<br>参数3放在CX通用寄存器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TEXT _rt0_amd64(SB),NOSPLIT,$<span class="number">-8</span> <span class="comment">// 参数+返回值共8字节</span></span><br><span class="line">MOVQ<span class="number">0</span>(SP), DI<span class="comment">// argc</span></span><br><span class="line">LEAQ<span class="number">8</span>(SP), SI<span class="comment">// argv</span></span><br><span class="line">JMPruntime·rt0_go(SB)</span><br></pre></td></tr></table></figure><ul><li>然后跳转到runtime.rt0_go</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b runtime.rt0_go</span><br><span class="line">Breakpoint 3 at 0x1049360: file /usr/local/go/src/runtime/asm_amd64.s, line 89.</span><br></pre></td></tr></table></figure><h2 id="2-3-初始化"><a href="#2-3-初始化" class="headerlink" title="2.3 初始化"></a>2.3 初始化</h2><p>这个函数有点长，下面我们分段来看rt0_go这个函数</p><ul><li>初始化参数以及创建g0</li></ul><ol><li>首先将之前放入通用寄存器的参数放入AX，BX寄存器，然后调整栈顶指针(真SP寄存器)的位置，SP指针先减39，关于16字节向下对齐(因为CPU有一组 SSE 指令，这些指令中出现的内存地址必须是16的倍数)，然后把参数放到SP+16字节和SP+24字节处</li></ol><p><strong>golang的汇编有抽象出来的寄存器，通过是否有前缀变量区分真假寄存器，例如a+8(SP)就是golang的寄存器，8(SP)就是真的寄存器</strong></p><ol start="2"><li>创建g0，并初始化g.stackgruard0，g.stackguard1以及g.stack.lo，g.stack.hi的值(实际上是分配一段内存，然后分割成小段，约定哪小段表示哪个变量)</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·rt0_go(SB),NOSPLIT,$<span class="number">0</span></span><br><span class="line">MOVQDI, AX<span class="comment">// argc</span></span><br><span class="line">MOVQSI, BX<span class="comment">// argv</span></span><br><span class="line">SUBQ$(<span class="number">4</span>*<span class="number">8</span>+<span class="number">7</span>), SP<span class="comment">// 2args 2auto</span></span><br><span class="line">ANDQ$~<span class="number">15</span>, SP</span><br><span class="line">MOVQAX, <span class="number">16</span>(SP)</span><br><span class="line">MOVQBX, <span class="number">24</span>(SP)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化g0，g0就是go的第一个协程</span></span><br><span class="line"><span class="comment">// 给g0分配栈空间大概64K</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">MOVQ$runtime·g0(SB), DI</span><br><span class="line">LEAQ(<span class="number">-64</span>*<span class="number">1024</span>+<span class="number">104</span>)(SP), BX <span class="comment">// BX = SP - 64 * 1024 + 104</span></span><br><span class="line">MOVQBX, g_stackguard0(DI) <span class="comment">// g0.g_stackguard0 = SP - 64 * 1024 + 104</span></span><br><span class="line">MOVQBX, g_stackguard1(DI) <span class="comment">// g0.g_stackguard1 = SP - 64 * 1024 + 104</span></span><br><span class="line">MOVQBX, (g_stack+stack_lo)(DI) <span class="comment">// g0.stack.lo = SP - 64 * 1024 + 104</span></span><br><span class="line">MOVQSP, (g_stack+stack_hi)(DI) <span class="comment">// g0.stack.hi = SP</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建完g0的内存分布</p><p><img src="/images/stack_0.png" alt="stack_0"></p><p>然后略过一段CPU型号检测和CGO初始化的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>创建m0</li></ul><ol><li>创建将m0.tls放入DI寄存器，然后调用runtime.settls将m0设置为线程私有变量(mac下什么也没干)，将m0与主线程绑定，然后对m0.tls进行存取操作验证是否能用，不能用就直接退出</li><li>绑定m0和g0的关系，m0.g0 = g0，g0.m = m0</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将m0与主线程绑定</span></span><br><span class="line">LEAQruntime·m0+m_tls(SB), DI <span class="comment">// 将m0的thread local store成员的地址到DI</span></span><br><span class="line">CALLruntime·settls(SB) <span class="comment">// 调用settls设置线程本地存储(mac 下settls什么都没做，线程已经设置好本地存储了)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过往TLS存0x123在判断tls[0]是不是0x123验证TLS是否可用，如果不可用就abort</span></span><br><span class="line">get_tls(BX)</span><br><span class="line">MOVQ$<span class="number">0x123</span>, g(BX)</span><br><span class="line">MOVQruntime·m0+m_tls(SB), AX</span><br><span class="line">CMPQAX, $<span class="number">0x123</span></span><br><span class="line">JEQ <span class="number">2</span>(PC)</span><br><span class="line">CALLruntime·abort(SB)</span><br><span class="line">ok:</span><br><span class="line"><span class="comment">// 把g0存入m0的本地存储tls[0]</span></span><br><span class="line">get_tls(BX) <span class="comment">// 将m0.tls[0]地址放入BX</span></span><br><span class="line">LEAQruntime·g0(SB), CX <span class="comment">// 将g0地址放入CX</span></span><br><span class="line">MOVQCX, g(BX) <span class="comment">// m0.tls[0] = &amp;g0</span></span><br><span class="line">LEAQruntime·m0(SB), AX <span class="comment">// 将m0地址放入AX</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将m0和g0建立映射关系</span></span><br><span class="line"><span class="comment">// save m-&gt;g0 = g0</span></span><br><span class="line">MOVQCX, m_g0(AX) <span class="comment">// m0.g0 = g0</span></span><br><span class="line"><span class="comment">// save m0 to g0-&gt;m</span></span><br><span class="line">MOVQAX, g_m(CX) <span class="comment">// g0.m = m0</span></span><br><span class="line"></span><br><span class="line">CLD<span class="comment">// convention is D is always left cleared</span></span><br><span class="line">CALLruntime·check(SB)</span><br></pre></td></tr></table></figure><p>创建完m0之后的内存分布</p><p><img src="/images/stack_1.png" alt="stack_1"></p><ul><li>m0和g0的关系</li></ul><ol><li>m0表示主线程，g0表示主线程的第一个goroutine</li><li>g0主要是记录主线程的栈信息，执行调度函数(schedule后边会讲)时会用，而用户goroutine有自己的栈，执行的时候会从g0栈切换到用户goroutine栈</li></ol><ul><li>初始化调度</li></ul><p>g0和m0都创建并初始化好了，下面就该进行调度初始化了</p><ol><li>将参数放入AX(初始化g0时将参数放入SP+16和SP+24的位置</li><li>runtime.args初始化参数的</li><li>runtime.osinit是初始化CPU核数的</li><li>重点看runtime.schedinit<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化m0</span></span><br><span class="line"><span class="comment">// 将argc和argv入栈</span></span><br><span class="line">MOVL<span class="number">16</span>(SP), AX<span class="comment">// copy argc</span></span><br><span class="line">MOVLAX, <span class="number">0</span>(SP)</span><br><span class="line">MOVQ<span class="number">24</span>(SP), AX<span class="comment">// copy argv</span></span><br><span class="line">MOVQAX, <span class="number">8</span>(SP)</span><br><span class="line"><span class="comment">// 处理参数</span></span><br><span class="line">CALLruntime·args(SB)</span><br><span class="line"><span class="comment">// 获取cpu的核数</span></span><br><span class="line">CALLruntime·osinit(SB)</span><br><span class="line"><span class="comment">// 调度系统初始化</span></span><br><span class="line">CALLruntime·schedinit(SB)</span><br></pre></td></tr></table></figure></li></ol><ul><li>runtime.schedinit<br>下面函数省略了调度无关的代码，大概流程:</li></ul><ol><li>设置最大线程数</li><li>根据GOMAXPROCS设置procs(P的数量)</li><li>调用procresizeprocs调整P的数量</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedinit</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 取出g0</span></span><br><span class="line">_g_ := getg()</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">_g_.racectx, raceprocctx0 = raceinit()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置最大线程数</span></span><br><span class="line">sched.maxmcount = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化m0, 前边已经将m0和g0的关系绑定好了</span></span><br><span class="line"><span class="comment">// 只是检查一下各种变量，然后将m0挂到allm链表中</span></span><br><span class="line">mcommoninit(_g_.m)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">sched.lastpoll = <span class="keyword">uint64</span>(nanotime())</span><br><span class="line"><span class="comment">// ncpu在osinit时已经获取</span></span><br><span class="line">procs := ncpu</span><br><span class="line"><span class="comment">// 如果GOMAXPROCS设置并且合法就将procs的设置为GOMAXPROCS</span></span><br><span class="line"><span class="keyword">if</span> n, ok := atoi32(gogetenv(<span class="string">&quot;GOMAXPROCS&quot;</span>)); ok &amp;&amp; n &gt; <span class="number">0</span> &#123;</span><br><span class="line">procs = n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> procresize(procs) != <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;unknown runnable goroutine during bootstrap&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>runtime.procresize</p></li><li><p>调度初始化最后一步</p></li></ul><ol><li>更新最后一次修改P数量动作的时间戳并累加花费时间</li><li>根据nprocs调整P的数量(加锁)<ol><li>nprocs &gt; 现有P数量，就扩展allp(p的全局数组)的长度为nprocs</li><li>nprocs &lt; 现有P数量，就缩容allp的长度为nprocs</li></ol></li><li>如果上一步是扩容了，就从堆中创建新P，并把P放入扩容出来的位置</li><li>通过g0找到m0，然后将allp[0]和m0绑定</li><li>如果allp缩容了，就将多余的p销毁</li><li>将空闲的p加入空闲链表<br>到目前为止，创建了m0，g0，和nprocs个P，但是还是没有让调度真正的跑起来</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">func procresize(nprocs int32) *p &#123;</span><br><span class="line">old :&#x3D; gomaxprocs</span><br><span class="line">if old &lt; 0 || nprocs &lt;&#x3D; 0 &#123;</span><br><span class="line">throw(&quot;procresize: invalid arg&quot;)</span><br><span class="line">&#125;</span><br><span class="line">if trace.enabled &#123;</span><br><span class="line">traceGomaxprocs(nprocs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; update statistics</span><br><span class="line">now :&#x3D; nanotime()</span><br><span class="line">if sched.procresizetime !&#x3D; 0 &#123;</span><br><span class="line">sched.totaltime +&#x3D; int64(old) * (now - sched.procresizetime)</span><br><span class="line">&#125;</span><br><span class="line">sched.procresizetime &#x3D; now</span><br><span class="line"></span><br><span class="line">if nprocs &gt; int32(len(allp)) &#123; &#x2F;&#x2F; 初始化的len(allp) &#x3D;&#x3D; 0</span><br><span class="line">lock(&amp;allpLock)</span><br><span class="line">if nprocs &lt;&#x3D; int32(cap(allp)) &#123; &#x2F;&#x2F; 需要缩容</span><br><span class="line">allp &#x3D; allp[:nprocs]</span><br><span class="line">&#125; else &#123; &#x2F;&#x2F; 扩容</span><br><span class="line">nallp :&#x3D; make([]*p, nprocs)</span><br><span class="line">&#x2F;&#x2F; Copy everything up to allp&#39;s cap so we</span><br><span class="line">&#x2F;&#x2F; never lose old allocated Ps.</span><br><span class="line">copy(nallp, allp[:cap(allp)])</span><br><span class="line">allp &#x3D; nallp</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;allpLock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for i :&#x3D; old; i &lt; nprocs; i++ &#123;</span><br><span class="line">pp :&#x3D; allp[i]</span><br><span class="line">if pp &#x3D;&#x3D; nil &#123;</span><br><span class="line">pp &#x3D; new(p)</span><br><span class="line">&#125;</span><br><span class="line">pp.init(i)</span><br><span class="line">atomicstorep(unsafe.Pointer(&amp;allp[i]), unsafe.Pointer(pp))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_g_ :&#x3D; getg() &#x2F;&#x2F; 获取g0</span><br><span class="line">if _g_.m.p !&#x3D; 0 &amp;&amp; _g_.m.p.ptr().id &lt; nprocs &#123; &#x2F;&#x2F; 进程初始化时g0.m与p没有绑定，所以g0.m.p &#x3D;&#x3D; 0</span><br><span class="line">_g_.m.p.ptr().status &#x3D; _Prunning</span><br><span class="line">_g_.m.p.ptr().mcache.prepareForSweep()</span><br><span class="line">&#125; else &#123;</span><br><span class="line">if _g_.m.p !&#x3D; 0 &#123;</span><br><span class="line">if trace.enabled &#123;</span><br><span class="line">traceGoSched()</span><br><span class="line">traceProcStop(_g_.m.p.ptr())</span><br><span class="line">&#125;</span><br><span class="line">_g_.m.p.ptr().m &#x3D; 0</span><br><span class="line">&#125;</span><br><span class="line">_g_.m.p &#x3D; 0</span><br><span class="line">_g_.m.mcache &#x3D; nil</span><br><span class="line">p :&#x3D; allp[0]</span><br><span class="line">p.m &#x3D; 0</span><br><span class="line">p.status &#x3D; _Pidle</span><br><span class="line">acquirep(p) &#x2F;&#x2F; 把allp[0]和m0关联起来</span><br><span class="line">if trace.enabled &#123;</span><br><span class="line">traceGoStart()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果有需要销毁的p，就是销毁</span><br><span class="line">for i :&#x3D; nprocs; i &lt; old; i++ &#123;</span><br><span class="line">p :&#x3D; allp[i]</span><br><span class="line">p.destroy()</span><br><span class="line">&#x2F;&#x2F; can&#39;t free P itself because it can be referenced by an M in syscall</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if int32(len(allp)) !&#x3D; nprocs &#123;</span><br><span class="line">lock(&amp;allpLock)</span><br><span class="line">allp &#x3D; allp[:nprocs]</span><br><span class="line">unlock(&amp;allpLock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将空闲p放入空闲链表</span><br><span class="line">var runnablePs *p</span><br><span class="line">for i :&#x3D; nprocs - 1; i &gt;&#x3D; 0; i-- &#123;</span><br><span class="line">p :&#x3D; allp[i]</span><br><span class="line">if _g_.m.p.ptr() &#x3D;&#x3D; p &#123; &#x2F;&#x2F; allp[0]已经和m0关联了，所以不用放入空闲链表</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line">p.status &#x3D; _Pidle</span><br><span class="line">if runqempty(p) &#123;</span><br><span class="line">pidleput(p)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">p.m.set(mget())</span><br><span class="line">p.link.set(runnablePs)</span><br><span class="line">runnablePs &#x3D; p</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">stealOrder.reset(uint32(nprocs))</span><br><span class="line">var int32p *int32 &#x3D; &amp;gomaxprocs &#x2F;&#x2F; make compiler check that gomaxprocs is an int32</span><br><span class="line">atomic.Store((*uint32)(unsafe.Pointer(int32p)), uint32(nprocs))</span><br><span class="line">return runnablePs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.4 创建”第一个”goroutine</p><p>我们返回runtime·rt0_go接着看</p><ol><li>将runtime.main地址放入AX</li><li>参数AX, 0入栈(函数参数入栈由右向左)</li><li>然后调用runtime.newproc创建goroutine</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a new goroutine to start program</span></span><br><span class="line"><span class="comment">// 创建第一个goroutine执行runtime.main，源码里没搜到runtime.mainPC，在schedinit函数前注释里找到的runtime.mainPC就是runtime.main</span></span><br><span class="line">MOVQ$runtime·mainPC(SB), AX<span class="comment">// entry AX = func(runtime.main)</span></span><br><span class="line">PUSHQAX</span><br><span class="line">PUSHQ$<span class="number">0</span><span class="comment">// arg size runtime.main没有参数所以入栈0</span></span><br><span class="line">CALLruntime·newproc(SB)     <span class="comment">// 创建goroutine执行runtime.main(还没执行，只是将goroutine加入待运行队列)</span></span><br><span class="line">POPQAX                      <span class="comment">// 出栈</span></span><br><span class="line">POPQAX                      <span class="comment">// 出栈</span></span><br></pre></td></tr></table></figure><ul><li>newproc</li></ul><ol><li>首先获取参数地址</li><li>获取当前所在goroutine(初始化时runtime代码都在g0执行)</li><li>获取要执行指令地址</li><li>在gp的栈上执行runtime.newproc1(在g0栈上执行)</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc</span><span class="params">(siz <span class="keyword">int32</span>, fn *funcval)</span></span> &#123;</span><br><span class="line"><span class="comment">// 获取函数fn的第一个参数的位置</span></span><br><span class="line">argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)</span><br><span class="line"><span class="comment">// 获取当前所有goroutine ---- g0</span></span><br><span class="line">gp := getg()</span><br><span class="line"><span class="comment">// 获取要执行指令的位置</span></span><br><span class="line">pc := getcallerpc()</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">systemstack是将函数切换到g0的栈上运行，初始化时本来就在g0的栈上，所以直接调用函数返回</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">newproc1(fn, (*<span class="keyword">uint8</span>)(argp), siz, gp, pc)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>newproc1函数主要的工作<br>这个函数有点长分段来看</li></ul><ol><li>首先获得当前所在goroutine(g0)</li><li>禁止抢占</li><li>计算参数位置</li><li>计算下参数是否过大</li><li>获取当前goroutine所在m的p，前边讲过g0对应的m是m0，m0对应的p是allp[0]</li><li>创建一个goroutine(先从p的缓存里找，找不到就new一个)，并且确认goroutine栈边界是初始化好的(方式p缓存里的goroutine参数没初始化)</li><li>计算栈顶的地址，如果有参数就将参数放到新创建的这个goroutine上</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc1</span><span class="params">(fn *funcval, argp *<span class="keyword">uint8</span>, narg <span class="keyword">int32</span>, callergp *g, callerpc <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 获取当前所在goroutine，初始化的是g0</span></span><br><span class="line">_g_ := getg()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> fn == <span class="literal">nil</span> &#123;</span><br><span class="line">_g_.m.throwing = <span class="number">-1</span> <span class="comment">// do not dump full stacks</span></span><br><span class="line">throw(<span class="string">&quot;go of nil func value&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 禁止抢占，把p固定在本地变量</span></span><br><span class="line">acquirem() <span class="comment">// disable preemption because it can be holding p in a local var</span></span><br><span class="line">siz := narg</span><br><span class="line">siz = (siz + <span class="number">7</span>) &amp;^ <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查一下参数是否需要空间是否过大，参数大小 和 栈大小 - (额外栈底空间(猜的)) - 返回需要的栈大小</span></span><br><span class="line"><span class="keyword">if</span> siz &gt;= _StackMin<span class="number">-4</span>*sys.RegSize-sys.RegSize &#123;</span><br><span class="line">throw(<span class="string">&quot;newproc: function arguments too large for new goroutine&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// _p_ = allp[0]</span></span><br><span class="line">_p_ := _g_.m.p.ptr()</span><br><span class="line"><span class="comment">// 从_p_的缓存中取一个g，初始化的时候没有可用的g所以newg==nil</span></span><br><span class="line">newg := gfget(_p_)</span><br><span class="line"><span class="keyword">if</span> newg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 创建一个新g，栈空间2k, 并且给stack,stackguard0,stackguard1初始化</span></span><br><span class="line">newg = malg(_StackMin)</span><br><span class="line"><span class="comment">// 将g的状态设置为_Gdead</span></span><br><span class="line">casgstatus(newg, _Gidle, _Gdead)</span><br><span class="line"><span class="comment">// 将g加入allg链表</span></span><br><span class="line">allgadd(newg) <span class="comment">// publishes with a g-&gt;status of Gdead so GC scanner doesn&#x27;t look at uninitialized stack.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 确认刚才的初始化是否有效</span></span><br><span class="line"><span class="keyword">if</span> newg.stack.hi == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;newproc1: newg missing stack&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> readgstatus(newg) != _Gdead &#123;</span><br><span class="line">throw(<span class="string">&quot;newproc1: new g is not Gdead&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略一段调整sp指针的函数，并且如果有参数就将参数放入new goroutine的栈中</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>设置各个寄存器的值(在cpu上恢复上下文时使用)<br>    1) 清理sched<br>    2) 设置栈顶置针位置<br>    3) 设置pc寄存器值(goexit函数第二条指令，常理应该是goroutine本身函数的第一条指令，这个妙用后边说)<br>    4) 设置goroutine地址<br>    5) 调用gostartcallfn，参数是sched和goroutine的参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清理sched(各参数清零)</span></span><br><span class="line">memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))</span><br><span class="line"><span class="comment">// 设置sched, 在CPU上运行的相关参数</span></span><br><span class="line">newg.sched.sp = sp</span><br><span class="line">newg.stktopsp = sp</span><br><span class="line"><span class="comment">// 设置pc，被调度时第一条指令的位置，将pc设置为goexit函数一个偏移量的位置(goexit函数第二条指令)</span></span><br><span class="line"><span class="comment">// 这里把pc设置为goexit函数的第二条指令的作用就是，伪装成goexit函数调用的fn函数，当fn执行完跳回goexit函数继续做退出需要的操作</span></span><br><span class="line">newg.sched.pc = funcPC(goexit) + sys.PCQuantum <span class="comment">// +PCQuantum so that previous instruction is in same function</span></span><br><span class="line">newg.sched.g = guintptr(unsafe.Pointer(newg))</span><br><span class="line">gostartcallfn(&amp;newg.sched, fn)</span><br></pre></td></tr></table></figure><p>判断一下goroutine的函数是否为空，然后调用gostartcall</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gostartcallfn</span><span class="params">(gobuf *gobuf, fv *funcval)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> fn unsafe.Pointer</span><br><span class="line"><span class="keyword">if</span> fv != <span class="literal">nil</span> &#123;</span><br><span class="line">fn = unsafe.Pointer(fv.fn)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fn = unsafe.Pointer(funcPC(nilfunc))</span><br><span class="line">&#125;</span><br><span class="line">gostartcall(gobuf, fn, unsafe.Pointer(fv))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>获取sp，现在新goroutine的栈上之后本身的函数，sp指向函数的第一个参数</li><li>将sp指向pc里面的指令地址，也就是goexit的第二条指令，然后重新设置新goroutinesp地址</li><li>这时候pc才指向goroutine自己的函数</li></ol><p>gostartcall的主要作用就是将goexit入栈，然后设置goroutine的pc指向自身函数，伪装成是goexit调用的自身函数，当自身函数执行完时返回goexit清理线程，大概就是下面这样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexit</span><span class="params">()</span></span> &#123;</span><br><span class="line">goroutine自身函数()</span><br><span class="line">清理现场()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gostartcall</span><span class="params">(buf *gobuf, fn, ctxt unsafe.Pointer)</span></span> &#123;</span><br><span class="line">sp := buf.sp</span><br><span class="line"><span class="keyword">if</span> sys.RegSize &gt; sys.PtrSize &#123;</span><br><span class="line">sp -= sys.PtrSize</span><br><span class="line">*(*<span class="keyword">uintptr</span>)(unsafe.Pointer(sp)) = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 预留返回值空间</span></span><br><span class="line">sp -= sys.PtrSize</span><br><span class="line"><span class="comment">// sp指向pc指令的位置，前边已经将goexit第二条指令的地址放入pc</span></span><br><span class="line">*(*<span class="keyword">uintptr</span>)(unsafe.Pointer(sp)) = buf.pc </span><br><span class="line"><span class="comment">// 然后设置sp</span></span><br><span class="line">buf.sp = sp</span><br><span class="line"><span class="comment">// 这时候的pc才是goroutine的函数</span></span><br><span class="line">buf.pc = <span class="keyword">uintptr</span>(fn)</span><br><span class="line">buf.ctxt = ctxt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再回到newproc函数，剩下的就是设置goroutine的状态，然后把goroutine放入p的待执行队列中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">newg.gopc = callerpc <span class="comment">// 用于traceback</span></span><br><span class="line">newg.ancestors = saveAncestors(callergp)</span><br><span class="line"><span class="comment">// newg的函数从哪里开始执行依赖于sched.pc 不依赖于startpc</span></span><br><span class="line">newg.startpc = fn.fn</span><br><span class="line"><span class="keyword">if</span> _g_.m.curg != <span class="literal">nil</span> &#123;</span><br><span class="line">newg.labels = _g_.m.curg.labels</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> isSystemGoroutine(newg, <span class="literal">false</span>) &#123;</span><br><span class="line">atomic.Xadd(&amp;sched.ngsys, +<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">newg.gcscanvalid = <span class="literal">false</span></span><br><span class="line"><span class="comment">// 设置newg状态为_Grunnable, 到这里newg就可以运行了</span></span><br><span class="line">casgstatus(newg, _Gdead, _Grunnable)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _p_.goidcache == _p_.goidcacheend &#123;</span><br><span class="line">_p_.goidcache = atomic.Xadd64(&amp;sched.goidgen, _GoidCacheBatch)</span><br><span class="line">_p_.goidcache -= _GoidCacheBatch - <span class="number">1</span></span><br><span class="line">_p_.goidcacheend = _p_.goidcache + _GoidCacheBatch</span><br><span class="line">&#125;</span><br><span class="line">newg.goid = <span class="keyword">int64</span>(_p_.goidcache)</span><br><span class="line">_p_.goidcache++</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">newg.racectx = racegostart(callerpc)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">traceGoCreate(newg, newg.startpc)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将newg加入p的待运行队列</span></span><br><span class="line">runqput(_p_, newg, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> atomic.Load(&amp;sched.npidle) != <span class="number">0</span> &amp;&amp; atomic.Load(&amp;sched.nmspinning) == <span class="number">0</span> &amp;&amp; mainStarted &#123;</span><br><span class="line">wakep()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取消m的固定</span></span><br><span class="line">releasem(_g_.m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下创建第一个goroutine执行runtime.main的过程(只是创建啊，整个调度这时候还是没有跑起来)<br><img src="/images/creat_goroutine_main.png" alt="create_goroutine_main"></p><h2 id="2-4-调度循环"><a href="#2-4-调度循环" class="headerlink" title="2.4 调度循环"></a>2.4 调度循环</h2><p>我们再返回runtime·rt0_go继续看，总结一下到目前为止已经准备好的事情</p><ol><li>将m0与主线程绑定了(将m0结构体设为主线程的私有变量)</li><li>创建了g0，并且与m0绑定</li><li>创建了procs个p并且初始化，将allp[0]与m0绑定，形成初步的GMP模型(g0,m0,p0)</li><li>创建了一个执行runtime.main(不是代码里的main.main，runtime.main会做加载init函数等操作然后调用main.main)的goroutine并且放入了p0的待运行队列</li></ol><p>接下来就是调度循环了，调用runtime.mstart，这个函数就是调度循环，除非程序退出否则永远阻塞住</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start this M</span></span><br><span class="line"><span class="comment">// 运行runtime.mstart这个函数会阻塞住，运行结束的时候就是程序退出的时候</span></span><br><span class="line">CALLruntime·mstart(SB)</span><br><span class="line"></span><br><span class="line">CALLruntime·abort(SB)<span class="comment">// mstart should never return</span></span><br><span class="line">RET</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prevent dead-code elimination of debugCallV1, which is</span></span><br><span class="line"><span class="comment">// intended to be called by debuggers.</span></span><br><span class="line">MOVQ$runtime·debugCallV1(SB), AX</span><br><span class="line">RET</span><br></pre></td></tr></table></figure><ul><li>runtime.mstart</li></ul><ol><li>获取了当前所在goroutine(初始化时代码都是在g0上执行的)</li><li>初始化栈保护</li><li>调用mstart1<br>go/src/runtime/proc.go, line 1146<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func mstart() &#123;</span><br><span class="line">_g_ :&#x3D; getg() &#x2F;&#x2F; 获取g0</span><br><span class="line"></span><br><span class="line">osStack :&#x3D; _g_.stack.lo &#x3D;&#x3D; 0 &#x2F;&#x2F; g0.stack.lo在前边已经初始化过了，所以osStack &#x3D; false</span><br><span class="line">if osStack &#123;</span><br><span class="line">size :&#x3D; _g_.stack.hi</span><br><span class="line">if size &#x3D;&#x3D; 0 &#123;</span><br><span class="line">size &#x3D; 8192 * sys.StackGuardMultiplier</span><br><span class="line">&#125;</span><br><span class="line">_g_.stack.hi &#x3D; uintptr(noescape(unsafe.Pointer(&amp;size)))</span><br><span class="line">_g_.stack.lo &#x3D; _g_.stack.hi - size + 1024</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 初始化栈保护</span><br><span class="line">_g_.stackguard0 &#x3D; _g_.stack.lo + _StackGuard</span><br><span class="line">_g_.stackguard1 &#x3D; _g_.stackguard0</span><br><span class="line">&#x2F;&#x2F; 开始m0开始运行</span><br><span class="line">mstart1()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Exit this thread.</span><br><span class="line">if GOOS &#x3D;&#x3D; &quot;windows&quot; || GOOS &#x3D;&#x3D; &quot;solaris&quot; || GOOS &#x3D;&#x3D; &quot;illumos&quot; || GOOS &#x3D;&#x3D; &quot;plan9&quot; || GOOS &#x3D;&#x3D; &quot;darwin&quot; || GOOS &#x3D;&#x3D; &quot;aix&quot; &#123;</span><br><span class="line">osStack &#x3D; true</span><br><span class="line">&#125;</span><br><span class="line">mexit(osStack)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>runtime.mstart1</li></ul><ol><li>保存g0的指令指针和栈指针，保存这两个值是理解调度循环的关键，mstart1执行完之后，g0继续执行指令，不会再返回来了，保存了指令和栈指针之后，g0要继续执行指令的时候，就会又从上面开始执行</li><li>做一些初始化工作</li><li>调用schedule开始调度<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">func mstart1() &#123;</span><br><span class="line">&#x2F;&#x2F; 获取当前goroutine g0</span><br><span class="line">_g_ :&#x3D; getg()</span><br><span class="line"></span><br><span class="line">if _g_ !&#x3D; _g_.m.g0 &#123;</span><br><span class="line">throw(&quot;bad runtime·mstart&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; save函数保存了g0再次运行时(循环调度下一次回头)调度相关信息</span><br><span class="line">save(getcallerpc(), getcallersp())</span><br><span class="line">&#x2F;&#x2F; asminit</span><br><span class="line">asminit()</span><br><span class="line">&#x2F;&#x2F; 信号相关初始化</span><br><span class="line">minit()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 初始化时m &#x3D;&#x3D; m0，mstartm0也是信号相关的初始化</span><br><span class="line">if _g_.m &#x3D;&#x3D; &amp;m0 &#123;</span><br><span class="line">mstartm0()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 初始化时fn &#x3D;&#x3D; ni</span><br><span class="line">if fn :&#x3D; _g_.m.mstartfn; fn !&#x3D; nil &#123;</span><br><span class="line">fn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if _g_.m !&#x3D; &amp;m0 &#123;</span><br><span class="line">acquirep(_g_.m.nextp.ptr())</span><br><span class="line">_g_.m.nextp &#x3D; 0</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 开始调度</span><br><span class="line">schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>runtime.schedule</li></ul><p>调度开始了，m要找gorutine放到cpu上执行了</p><ol><li>每调度61次(具体为啥是61有待思考)，就从全局的goroutine列表中选goroutine</li><li>如果上一步没找到，就从m对应的p的缓存里找</li><li>如果上一步还没有找到，就调findrunnable从其他线程窃取goroutine，如果发现有就窃取一半放到自己的p缓存中，如果都没有就说明真的没有待运行的goroutine了，就陷入睡眠一直阻塞在findrunnable函数，等待被唤醒</li><li>直到有goroutine需要执行了，就调用execute执行goroutine</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 获得g0</span></span><br><span class="line">_g_ := getg()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _g_.m.locks != <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;schedule: holding locks&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _g_.m.lockedg != <span class="number">0</span> &#123;</span><br><span class="line">stoplockedm()</span><br><span class="line">execute(_g_.m.lockedg.ptr(), <span class="literal">false</span>) <span class="comment">// Never returns.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _g_.m.incgo &#123;</span><br><span class="line">throw(<span class="string">&quot;schedule: in cgo&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line"><span class="comment">// 等待gc</span></span><br><span class="line"><span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">gcstopm()</span><br><span class="line"><span class="keyword">goto</span> top</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _g_.m.p.ptr().runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">runSafePointFn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gp *g</span><br><span class="line"><span class="keyword">var</span> inheritTime <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">tryWakeP := <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> trace.enabled || trace.shutdown &#123;</span><br><span class="line">gp = traceReader()</span><br><span class="line"><span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">tryWakeP = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> gp == <span class="literal">nil</span> &amp;&amp; gcBlackenEnabled != <span class="number">0</span> &#123;</span><br><span class="line">gp = gcController.findRunnableGCWorker(_g_.m.p.ptr())</span><br><span class="line">tryWakeP = tryWakeP || gp != <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 先从全局队列中获取，每61次调度都会从全局队列中获取goroutine</span></span><br><span class="line"><span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> _g_.m.p.ptr().schedtick%<span class="number">61</span> == <span class="number">0</span> &amp;&amp; sched.runqsize &gt; <span class="number">0</span> &#123;</span><br><span class="line">lock(&amp;sched.lock)</span><br><span class="line">gp = globrunqget(_g_.m.p.ptr(), <span class="number">1</span>)</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果还空就从本地队列中获取</span></span><br><span class="line"><span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">gp, inheritTime = runqget(_g_.m.p.ptr())</span><br><span class="line"><span class="keyword">if</span> gp != <span class="literal">nil</span> &amp;&amp; _g_.m.spinning &#123;</span><br><span class="line">throw(<span class="string">&quot;schedule: spinning with local work&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果本地也没有就调用findrunnable从其他线程偷一个过来，直到偷过来在运行</span></span><br><span class="line"><span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">gp, inheritTime = findrunnable() <span class="comment">// blocks until work is available</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">resetspinning()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sched.disable.user &amp;&amp; !schedEnabled(gp) &#123;</span><br><span class="line">lock(&amp;sched.lock)</span><br><span class="line"><span class="keyword">if</span> schedEnabled(gp) &#123;</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sched.disable.runnable.pushBack(gp)</span><br><span class="line">sched.disable.n++</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line"><span class="keyword">goto</span> top</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> tryWakeP &#123;</span><br><span class="line"><span class="keyword">if</span> atomic.Load(&amp;sched.npidle) != <span class="number">0</span> &amp;&amp; atomic.Load(&amp;sched.nmspinning) == <span class="number">0</span> &#123;</span><br><span class="line">wakep()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> gp.lockedm != <span class="number">0</span> &#123;</span><br><span class="line">startlockedm(gp)</span><br><span class="line"><span class="keyword">goto</span> top</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行这个goroutine</span></span><br><span class="line">execute(gp, inheritTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-触发调度"><a href="#2-5-触发调度" class="headerlink" title="2.5 触发调度"></a>2.5 触发调度</h2><p>触发调度地方大致有:</p><ol><li>主动挂起</li><li>系统调用</li><li>协作式调度</li><li>正常退出</li></ol><ul><li><p>proc.go:1208 runtime.mstart1(调度开始)</p></li><li><p>主动挂起</p></li><li><p>proc.go:2610 runtime.park_m<br>在上一章内容里讲过<a href="https://www.cnblogs.com/wuwangchuxin0924/p/13022386.html">golang channel源码阅读</a>，当goroutine接收一个channel为空且为阻塞的时候，goroutine会调用goparkunlock使goroutine陷入睡眠，等待send端调用goready函数唤醒函数，主动挂起就是这种情况，当goroutine由于某些条件在等待时，就会主动挂起，不放回待运行队列，等待被唤醒</p></li></ul><p>各种阻塞条件 -&gt; runtime.gopark() -&gt; runtime.park_m() -&gt; runtime.schedule</p><ol><li>获取当前所在m，并且固定m</li><li>获取当前程序所在goroutine</li><li>设置锁状态以及阻塞原因</li><li>调用runtime.park_m挂起goroutine</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gopark</span><span class="params">(unlockf <span class="keyword">func</span>(*g, unsafe.Pointer)</span> <span class="title">bool</span>, <span class="title">lock</span> <span class="title">unsafe</span>.<span class="title">Pointer</span>, <span class="title">reason</span> <span class="title">waitReason</span>, <span class="title">traceEv</span> <span class="title">byte</span>, <span class="title">traceskip</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> reason != waitReasonSleep &#123;</span><br><span class="line">checkTimeouts() <span class="comment">// timeouts may expire while two goroutines keep the scheduler busy</span></span><br><span class="line">&#125;</span><br><span class="line">mp := acquirem()</span><br><span class="line">gp := mp.curg</span><br><span class="line">status := readgstatus(gp)</span><br><span class="line"><span class="keyword">if</span> status != _Grunning &amp;&amp; status != _Gscanrunning &#123;</span><br><span class="line">throw(<span class="string">&quot;gopark: bad g status&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">mp.waitlock = lock</span><br><span class="line">mp.waitunlockf = unlockf</span><br><span class="line">gp.waitreason = reason</span><br><span class="line">mp.waittraceev = traceEv</span><br><span class="line">mp.waittraceskip = traceskip</span><br><span class="line">releasem(mp)</span><br><span class="line"><span class="comment">// can&#x27;t do anything that might move the G between Ms here.</span></span><br><span class="line">mcall(park_m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>获取当前goroutine</li><li>将goroutine状态设置为Gwaiting</li><li>重新调度</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">park_m</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">_g_ := getg()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">traceGoPark(_g_.m.waittraceev, _g_.m.waittraceskip)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">casgstatus(gp, _Grunning, _Gwaiting)</span><br><span class="line">dropg()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> fn := _g_.m.waitunlockf; fn != <span class="literal">nil</span> &#123;</span><br><span class="line">ok := fn(gp, _g_.m.waitlock)</span><br><span class="line">_g_.m.waitunlockf = <span class="literal">nil</span></span><br><span class="line">_g_.m.waitlock = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">traceGoUnpark(gp, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">execute(gp, <span class="literal">true</span>) <span class="comment">// Schedule it back, never returns.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>协作式调度</p></li><li><p>proc.go:2625 runtime.goschedImpl(协作式调度)</p></li></ul><ol><li>主动让出cpu，这个情况不会挂起goroutine，而是放回队列，等待下次调度，这个函数(GoSched)被暴露出去，可以调用，例如，线上有这种情况，写log是异步的，但由于机器磁盘老旧性能不佳，所以当log goroutine运行时还是会过多的占用cpu，这时候可以调用GoSched适当降低当前goroutine优先级</li></ol><p>runtime.Gosched -&gt; runtime.gosched_m -&gt; runtime.goschedImpl runtime.schedule</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Gosched continuation on g0.</span><br><span class="line">func gosched_m(gp *g) &#123;</span><br><span class="line">if trace.enabled &#123;</span><br><span class="line">traceGoSched()</span><br><span class="line">&#125;</span><br><span class="line">goschedImpl(gp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>调度保护，当调度器发现goroutine处于禁止的状态时就会主动调度让出cpu</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// goschedguarded is a forbidden-states-avoided version of gosched_m</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goschedguarded_m</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> gp.m.locks != <span class="number">0</span> || gp.m.mallocing != <span class="number">0</span> || gp.m.preemptoff != <span class="string">&quot;&quot;</span> || gp.m.p.ptr().status != _Prunning &#123;</span><br><span class="line">gogo(&amp;gp.sched) <span class="comment">// never return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">traceGoSched()</span><br><span class="line">&#125;</span><br><span class="line">goschedImpl(gp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>发生抢占，例如当一个goroutine运行时间过长但不像等待channel那样阻塞，一直有事情做时，其他goroutine可能会抢占cpu</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gopreempt_m</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">traceGoPreempt()</span><br><span class="line">&#125;</span><br><span class="line">goschedImpl(gp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goschedImpl</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">status := readgstatus(gp)</span><br><span class="line"><span class="keyword">if</span> status&amp;^_Gscan != _Grunning &#123;</span><br><span class="line">dumpgstatus(gp)</span><br><span class="line">throw(<span class="string">&quot;bad g status&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">casgstatus(gp, _Grunning, _Grunnable)</span><br><span class="line">dropg()</span><br><span class="line">lock(&amp;sched.lock)</span><br><span class="line">globrunqput(gp)</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>非main goroutine结束</p></li><li><p>proc.go:2704,2727 runtime.goexit0(goroutine正常执行完)<br>非main goroutine结束后会继续调度，这个是正常继续下一次调度不做过多介绍</p></li><li><p>系统调用</p></li><li><p>proc.go:3141 runtime.exitsyscall0(系统调用)</p></li></ul><p>runtime·exitsyscall -&gt; runtime·exitsyscall0 -&gt; runtime.schedule</p><p>我们来看下系统调用的过程</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">syscall_syscall</span><span class="params">(fn, a1, a2, a3 <span class="keyword">uintptr</span>)</span> <span class="params">(r1, r2, err <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">entersyscall()</span><br><span class="line">libcCall(unsafe.Pointer(funcPC(syscall)), unsafe.Pointer(&amp;fn))</span><br><span class="line">exitsyscall()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">syscall</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>首先会调用runtime.entersyscall获取当前的指令位置和栈指针，然后调用reentersyscall做goroutine进入系统调用之前的准备</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">entersyscall</span><span class="params">()</span></span> &#123;</span><br><span class="line">reentersyscall(getcallerpc(), getcallersp())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>禁止线程抢占防止出现栈不一致的情况</li><li>保证当前函数不会触发栈调整(golang进程的栈初始2k，然后动态调整)</li><li>设置goroutine状态为Gsyscall</li><li>将goroutine的P暂时和M分离，并且设置P状态为Psyscall</li><li>释放锁</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reentersyscall</span><span class="params">(pc, sp <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 获得当前goroutine</span></span><br><span class="line">_g_ := getg()</span><br><span class="line"></span><br><span class="line">_g_.m.locks++</span><br><span class="line"></span><br><span class="line">_g_.stackguard0 = stackPreempt</span><br><span class="line">_g_.throwsplit = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Leave SP around for GC and traceback.</span></span><br><span class="line">save(pc, sp)</span><br><span class="line">_g_.syscallsp = sp</span><br><span class="line">_g_.syscallpc = pc</span><br><span class="line">casgstatus(_g_, _Grunning, _Gsyscall)</span><br><span class="line"><span class="keyword">if</span> _g_.syscallsp &lt; _g_.stack.lo || _g_.stack.hi &lt; _g_.syscallsp &#123;</span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;entersyscall inconsistent &quot;</span>, hex(_g_.syscallsp), <span class="string">&quot; [&quot;</span>, hex(_g_.stack.lo), <span class="string">&quot;,&quot;</span>, hex(_g_.stack.hi), <span class="string">&quot;]\n&quot;</span>)</span><br><span class="line">throw(<span class="string">&quot;entersyscall&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">systemstack(traceGoSysCall)</span><br><span class="line">save(pc, sp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> atomic.Load(&amp;sched.sysmonwait) != <span class="number">0</span> &#123;</span><br><span class="line">systemstack(entersyscall_sysmon)</span><br><span class="line">save(pc, sp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _g_.m.p.ptr().runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">systemstack(runSafePointFn)</span><br><span class="line">save(pc, sp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_g_.m.syscalltick = _g_.m.p.ptr().syscalltick</span><br><span class="line">_g_.sysblocktraced = <span class="literal">true</span></span><br><span class="line">_g_.m.mcache = <span class="literal">nil</span></span><br><span class="line">pp := _g_.m.p.ptr()</span><br><span class="line">pp.m = <span class="number">0</span></span><br><span class="line">_g_.m.oldp.set(pp)</span><br><span class="line">_g_.m.p = <span class="number">0</span></span><br><span class="line">atomic.Store(&amp;pp.status, _Psyscall)</span><br><span class="line"><span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">systemstack(entersyscall_gcwait)</span><br><span class="line">save(pc, sp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_g_.m.locks--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就进入系统调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...</span><br></pre></td></tr></table></figure><ol><li>获得goroutine</li><li>线程加锁</li><li>调exitsyscallfast替当前goroutine找一个P<ol><li>如果原P处于Psyscall就让这个P接管，否则的话进行2)</li><li>否则的话就找空闲的P，有的话就调用exitsyscall0继续调度，否则的话进行3)</li><li>将goroutine设置为Grunning，加入全局队列，调用Gosched()继续调度<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exitsyscall</span><span class="params">()</span></span> &#123;</span><br><span class="line">_g_ := getg()</span><br><span class="line"></span><br><span class="line">_g_.m.locks++ <span class="comment">// see comment in entersyscall</span></span><br><span class="line"><span class="keyword">if</span> getcallersp() &gt; _g_.syscallsp &#123;</span><br><span class="line">throw(<span class="string">&quot;exitsyscall: syscall frame is no longer valid&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_g_.waitsince = <span class="number">0</span></span><br><span class="line">oldp := _g_.m.oldp.ptr()</span><br><span class="line">_g_.m.oldp = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> exitsyscallfast(oldp) &#123;</span><br><span class="line"><span class="keyword">if</span> _g_.m.mcache == <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;lost mcache&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line"><span class="keyword">if</span> oldp != _g_.m.p.ptr() || _g_.m.syscalltick != _g_.m.p.ptr().syscalltick &#123;</span><br><span class="line">systemstack(traceGoStart)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// There&#x27;s a cpu for us, so we can run.</span></span><br><span class="line">_g_.m.p.ptr().syscalltick++</span><br><span class="line"><span class="comment">// We need to cas the status and scan before resuming...</span></span><br><span class="line">casgstatus(_g_, _Gsyscall, _Grunning)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Garbage collector isn&#x27;t running (since we are),</span></span><br><span class="line"><span class="comment">// so okay to clear syscallsp.</span></span><br><span class="line">_g_.syscallsp = <span class="number">0</span></span><br><span class="line">_g_.m.locks--</span><br><span class="line"><span class="keyword">if</span> _g_.preempt &#123;</span><br><span class="line"><span class="comment">// restore the preemption request in case we&#x27;ve cleared it in newstack</span></span><br><span class="line">_g_.stackguard0 = stackPreempt</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// otherwise restore the real _StackGuard, we&#x27;ve spoiled it in entersyscall/entersyscallblock</span></span><br><span class="line">_g_.stackguard0 = _g_.stack.lo + _StackGuard</span><br><span class="line">&#125;</span><br><span class="line">_g_.throwsplit = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sched.disable.user &amp;&amp; !schedEnabled(_g_) &#123;</span><br><span class="line"><span class="comment">// Scheduling of this goroutine is disabled.</span></span><br><span class="line">Gosched()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_g_.sysexitticks = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line"><span class="comment">// Wait till traceGoSysBlock event is emitted.</span></span><br><span class="line"><span class="comment">// This ensures consistency of the trace (the goroutine is started after it is blocked).</span></span><br><span class="line"><span class="keyword">for</span> oldp != <span class="literal">nil</span> &amp;&amp; oldp.syscalltick == _g_.m.syscalltick &#123;</span><br><span class="line">osyield()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// We can&#x27;t trace syscall exit right now because we don&#x27;t have a P.</span></span><br><span class="line"><span class="comment">// Tracing code can invoke write barriers that cannot run without a P.</span></span><br><span class="line"><span class="comment">// So instead we remember the syscall exit time and emit the event</span></span><br><span class="line"><span class="comment">// in execute when we have a P.</span></span><br><span class="line">_g_.sysexitticks = cputicks()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_g_.m.locks--</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call the scheduler.</span></span><br><span class="line">mcall(exitsyscall0)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _g_.m.mcache == <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;lost mcache&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scheduler returned, so we&#x27;re allowed to run now.</span></span><br><span class="line"><span class="comment">// Delete the syscallsp information that we left for</span></span><br><span class="line"><span class="comment">// the garbage collector during the system call.</span></span><br><span class="line"><span class="comment">// Must wait until now because until gosched returns</span></span><br><span class="line"><span class="comment">// we don&#x27;t know for sure that the garbage collector</span></span><br><span class="line"><span class="comment">// is not running.</span></span><br><span class="line">_g_.syscallsp = <span class="number">0</span></span><br><span class="line">_g_.m.p.ptr().syscalltick++</span><br><span class="line">_g_.throwsplit = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><p><a href="https://www.cnblogs.com/abozhang/p/10766628.html">参考资料go语言调度器源代码情景分析</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-数据结构&quot;&gt;&lt;a href=&quot;#1-数据结构&quot; class=&quot;headerlink&quot; title=&quot;1.数据结构&quot;&gt;&lt;/a&gt;1.数据结构&lt;/h1&gt;&lt;p&gt;调度相关的数据结构有三个，M(线程)，P(调度器)，G(goroutine)&lt;br&gt;M表示线程，P作为调度器用来帮助每个线程管理自己的goroutine，G就是golang的协程。我们可以通过runtime.GOMAXPROCS(n int)函数设置P的个数，&lt;strong&gt;注意&lt;/strong&gt;P的个数并不代表M的个数，例如程序启动时runtime代码会出实话procs个P，但开始的时候只会启动一个M，就是M0和一个栈为64K(其他goroutine默认初始栈大小2K)来执行runtime代码。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Golang" scheme="https://journey-c.github.io/tags/Golang/"/>
    
    <category term="源码" scheme="https://journey-c.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>长连接平滑重启</title>
    <link href="https://journey-c.github.io/2020/10/21/long-connection-smooth-restart-realization/"/>
    <id>https://journey-c.github.io/2020/10/21/long-connection-smooth-restart-realization/</id>
    <published>2020-10-21T14:48:39.386Z</published>
    <updated>2020-11-19T03:25:33.443Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近小编一直在做长连接相关的事情，最大的感触就是发版太痛苦，一个个踢掉连接然后发版，导致发版时长过长，操作繁琐。所以在想能不能实现优雅重启, 发版时客户端无感知。</p></blockquote><h1 id="1-难点"><a href="#1-难点" class="headerlink" title="1.难点"></a>1.难点</h1><ul><li><p>如何做到不中断接收连接</p></li><li><p>如何做到已有连接不中断</p></li></ul><h1 id="2-解决"><a href="#2-解决" class="headerlink" title="2.解决"></a>2.解决</h1><h2 id="2-1-如何做到不中断接受连接"><a href="#2-1-如何做到不中断接受连接" class="headerlink" title="2.1 如何做到不中断接受连接"></a>2.1 如何做到不中断接受连接</h2><p>以下是linux源码中bind的实现(linux-1.0)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; linux-1.0&#x2F;net&#x2F;socket.c 536</span><br><span class="line">static int</span><br><span class="line">sock_bind(int fd, struct sockaddr *umyaddr, int addrlen)</span><br><span class="line">&#123;</span><br><span class="line">  struct socket *sock;</span><br><span class="line">  int i;</span><br><span class="line"></span><br><span class="line">  DPRINTF((net_debug, &quot;NET: sock_bind: fd &#x3D; %d\n&quot;, fd));</span><br><span class="line">  if (fd &lt; 0 || fd &gt;&#x3D; NR_OPEN || current-&gt;filp[fd] &#x3D;&#x3D; NULL)</span><br><span class="line">return(-EBADF);</span><br><span class="line">  &#x2F;&#x2F;获取fd对应的socket结构</span><br><span class="line">  if (!(sock &#x3D; sockfd_lookup(fd, NULL))) return(-ENOTSOCK);</span><br><span class="line">  &#x2F;&#x2F; 转调用bind指向的函数，下层函数(inet_bind)</span><br><span class="line">  if ((i &#x3D; sock-&gt;ops-&gt;bind(sock, umyaddr, addrlen)) &lt; 0) &#123;</span><br><span class="line">DPRINTF((net_debug, &quot;NET: sock_bind: bind failed\n&quot;));</span><br><span class="line">return(i);</span><br><span class="line">  &#125;</span><br><span class="line">  return(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; linux-1.0&#x2F;net&#x2F;inet&#x2F;sock.c 1012</span><br><span class="line">static int</span><br><span class="line">inet_bind(struct socket *sock, struct sockaddr *uaddr,</span><br><span class="line">       int addr_len)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">outside_loop:</span><br><span class="line">  for(sk2 &#x3D; sk-&gt;prot-&gt;sock_array[snum &amp; (SOCK_ARRAY_SIZE -1)];</span><br><span class="line">sk2 !&#x3D; NULL; sk2 &#x3D; sk2-&gt;next) &#123;</span><br><span class="line">#if 1&#x2F;* should be below! *&#x2F;</span><br><span class="line">if (sk2-&gt;num !&#x3D; snum) continue;</span><br><span class="line">&#x2F;*if (sk2-&gt;saddr !&#x3D; sk-&gt;saddr) continue; *&#x2F;</span><br><span class="line">#endif</span><br><span class="line">if (sk2-&gt;dead) &#123;</span><br><span class="line">destroy_sock(sk2);</span><br><span class="line">goto outside_loop;</span><br><span class="line">&#125;</span><br><span class="line">if (!sk-&gt;reuse) &#123;</span><br><span class="line">sti();</span><br><span class="line">return(-EADDRINUSE);</span><br><span class="line">&#125;</span><br><span class="line">if (sk2-&gt;num !&#x3D; snum) continue;&#x2F;* more than one *&#x2F;</span><br><span class="line">if (sk2-&gt;saddr !&#x3D; sk-&gt;saddr) continue;&#x2F;* socket per slot ! -FB *&#x2F;</span><br><span class="line">if (!sk2-&gt;reuse) &#123;</span><br><span class="line">sti();</span><br><span class="line">return(-EADDRINUSE);</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ... </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>sock_array是一个链式哈希表，保存着各端口号的sock结构  </li><li>通过源码可以看到，bind的时候会检测要绑定的地址和端口是否合法以及已被绑定, 如果发版时另一个进程和旧进程没有关系，则bind会返回错误Address already in use  </li><li>若旧进程fork出新进程，新进程和旧进程为父子关系，新进程继承旧进程的文件表，本身”本进程”就已经监听这个端口了，则不会出现上面的问题</li></ul><h2 id="2-2-如何做到已有连接不中断"><a href="#2-2-如何做到已有连接不中断" class="headerlink" title="2.2 如何做到已有连接不中断"></a>2.2 如何做到已有连接不中断</h2><ul><li><p>新进程继承旧进程的用于连接的fd，并且继续维持与客户端的心跳</p><p>linux提供了unix域套接字可用于socket的传输, 新进程起来后通过unix socket通信继承旧进程所维护的连接</p></li></ul><p>[^unix socket]: unix socket用于**<em>一台**</em>主机的进程间通信，不需要基于网络协议，主要是基于文件系统的。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;socket.h&gt;</span><br><span class="line"></span><br><span class="line">ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);</span><br><span class="line">ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);</span><br></pre></td></tr></table></figure><p>发送端调用sendmsg发送文件描述符，接收端调用revmsg接收文件描述符。  </p><p>两进程共享同一打开文件表，这与fork之后的父子进程共享打开文件表的情况完全相同。  </p><p><strong><em>由此解决了文章开头提出的两个问题</em></strong></p><h1 id="3-Demo实现"><a href="#3-Demo实现" class="headerlink" title="3. Demo实现"></a>3. Demo实现</h1><ul><li><p>进程每次启动时必须check有无继承socket(尝试连接本地的unix server，如果连接失败，说明是第一次启动，否则可能有继承的socket)，如果有，就将socket加入到自己的连接池中, 并初始化连接状态</p></li><li><p>旧进程监听USR2信号(通知进程需要重启，使用信号、http接口等都可)，监听后动作:</p><ol><li>监听Unix socket, 等待新进程初始化完成，发来开始继承连接的请求</li><li>使用旧进程启动的命令fork一个子进程(发布到线上的新二进制)。</li><li>accept到新进程的请求，关闭旧进程listener(保证旧进程不会再接收新请求，同时所有connector不在进行I/O操作。</li><li>旧进程将现有连接的socket，以及连接状态(读写buffer，connect session)通过 unix socket发送到新进程。</li><li>最后旧进程给新进程发送发送完毕信号，随后退出</li></ol></li><li><p>以下是简单实现的demo, demo中实现较为简单，只实现了文件描述符的传递，没有实现各连接状态的传递。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; server.go</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;flag&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;golang.org&#x2F;x&#x2F;sys&#x2F;unix&quot;</span><br><span class="line">&quot;log&quot;</span><br><span class="line">&quot;net&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">&quot;os&#x2F;signal&quot;</span><br><span class="line">&quot;path&#x2F;filepath&quot;</span><br><span class="line">&quot;sync&quot;</span><br><span class="line">&quot;syscall&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">workSpace string</span><br><span class="line"></span><br><span class="line">logger *log.Logger</span><br><span class="line"></span><br><span class="line">writeTimeout &#x3D; time.Second * 5</span><br><span class="line">readTimeout  &#x3D; time.Second * 5</span><br><span class="line"></span><br><span class="line">signalChan &#x3D; make(chan os.Signal)</span><br><span class="line"></span><br><span class="line">connFiles sync.Map</span><br><span class="line"></span><br><span class="line">serverListener net.Listener</span><br><span class="line"></span><br><span class="line">isUpdate &#x3D; false</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">flag.StringVar(&amp;workSpace, &quot;w&quot;, &quot;.&quot;, &quot;Usage:\n .&#x2F;server -w&#x3D;workspace&quot;)</span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line">file, err :&#x3D; os.OpenFile(filepath.Join(workSpace, &quot;server.log&quot;), os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0777)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">panic(err)</span><br><span class="line">&#125;</span><br><span class="line">logger &#x3D; log.New(file, &quot;&quot;, 11)</span><br><span class="line">go beforeStart()</span><br><span class="line">go signalHandler()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var err error</span><br><span class="line">serverListener, err &#x3D; net.Listen(&quot;tcp&quot;, &quot;:7000&quot;)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">panic(err)</span><br><span class="line">&#125;</span><br><span class="line">for &#123;</span><br><span class="line">if isUpdate &#x3D;&#x3D; true &#123;</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line">conn, err :&#x3D; serverListener.Accept()</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">logger.Println(&quot;conn error&quot;)</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line">c :&#x3D; conn.(*net.TCPConn)</span><br><span class="line">go connectionHandler(c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func connectionHandler(conn *net.TCPConn) &#123;</span><br><span class="line">file, _ :&#x3D; conn.File()</span><br><span class="line">connFiles.Store(file, true)</span><br><span class="line">logger.Printf(&quot;conn fd %d\n&quot;, file.Fd())</span><br><span class="line">defer func() &#123;</span><br><span class="line">connFiles.Delete(file)</span><br><span class="line">_ &#x3D; conn.Close()</span><br><span class="line">&#125;()</span><br><span class="line">for &#123;</span><br><span class="line">if isUpdate &#x3D;&#x3D; true &#123;</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line">err :&#x3D; conn.SetReadDeadline(time.Now().Add(readTimeout))</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">logger.Println(err.Error())</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">rBuf :&#x3D; make([]byte, 4)</span><br><span class="line">_, err &#x3D; conn.Read(rBuf)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">logger.Println(err.Error())</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">if string(rBuf) !&#x3D; &quot;ping&quot; &#123;</span><br><span class="line">logger.Println(&quot;failed to parse the message &quot; + string(rBuf))</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">err &#x3D; conn.SetWriteDeadline(time.Now().Add(writeTimeout))</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">logger.Println(err.Error())</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">_, err &#x3D; conn.Write([]byte(&#96;pong&#96;))</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">logger.Println(err.Error())</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func beforeStart() &#123;</span><br><span class="line">connInterface, err :&#x3D; net.Dial(&quot;unix&quot;, filepath.Join(workSpace, &quot;conn.sock&quot;))</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">logger.Println(err.Error())</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">defer func() &#123;</span><br><span class="line">_ &#x3D; connInterface.Close()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">unixConn :&#x3D; connInterface.(*net.UnixConn)</span><br><span class="line"></span><br><span class="line">b :&#x3D; make([]byte, 1)</span><br><span class="line">oob :&#x3D; make([]byte, 32)</span><br><span class="line">for &#123;</span><br><span class="line">err &#x3D; unixConn.SetWriteDeadline(time.Now().Add(time.Minute * 3))</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">n, oobn, _, _, err :&#x3D; unixConn.ReadMsgUnix(b, oob)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">logger.Println(err.Error())</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">if n !&#x3D; 1 || b[0] !&#x3D; 0 &#123;</span><br><span class="line">if n !&#x3D; 1 &#123;</span><br><span class="line">logger.Printf(&quot;recv fd type error: %d\n&quot;, n)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">logger.Println(&quot;init finish&quot;)</span><br><span class="line">&#125;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">scms, err :&#x3D; unix.ParseSocketControlMessage(oob[0:oobn])</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">logger.Println(err.Error())</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">if len(scms) !&#x3D; 1 &#123;</span><br><span class="line">logger.Printf(&quot;recv fd num !&#x3D; 1 : %d\n&quot;, len(scms))</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">fds, err :&#x3D; unix.ParseUnixRights(&amp;scms[0])</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">logger.Println(err.Error())</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">if len(fds) !&#x3D; 1 &#123;</span><br><span class="line">logger.Printf(&quot;recv fd num !&#x3D; 1 : %d\n&quot;, len(fds))</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">logger.Printf(&quot;recv fd %d\n&quot;, fds[0])</span><br><span class="line">file :&#x3D; os.NewFile(uintptr(fds[0]), &quot;fd-from-old&quot;)</span><br><span class="line">conn, err :&#x3D; net.FileConn(file)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">logger.Println(err.Error())</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">go connectionHandler(conn.(*net.TCPConn))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func signalHandler() &#123;</span><br><span class="line">signal.Notify(</span><br><span class="line">signalChan,</span><br><span class="line">syscall.SIGUSR2,</span><br><span class="line">)</span><br><span class="line">for &#123;</span><br><span class="line">sc :&#x3D; &lt;-signalChan</span><br><span class="line">switch sc &#123;</span><br><span class="line">case syscall.SIGUSR2:</span><br><span class="line">gracefulExit()</span><br><span class="line">default:</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func gracefulExit() &#123;</span><br><span class="line">var connWait sync.WaitGroup</span><br><span class="line">_ &#x3D; syscall.Unlink(filepath.Join(workSpace, &quot;conn.sock&quot;))</span><br><span class="line">listenerInterface, err :&#x3D; net.Listen(&quot;unix&quot;, filepath.Join(workSpace, &quot;conn.sock&quot;))</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">logger.Println(err.Error())</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">defer func() &#123;</span><br><span class="line">_ &#x3D; listenerInterface.Close()</span><br><span class="line">&#125;()</span><br><span class="line">unixListener :&#x3D; listenerInterface.(*net.UnixListener)</span><br><span class="line">connWait.Add(1)</span><br><span class="line">go func() &#123;</span><br><span class="line">defer connWait.Done()</span><br><span class="line">unixConn, err :&#x3D; unixListener.AcceptUnix()</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">logger.Println(err.Error())</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">defer func() &#123;</span><br><span class="line">_ &#x3D; unixConn.Close()</span><br><span class="line">&#125;()</span><br><span class="line">connFiles.Range(func(key, value interface&#123;&#125;) bool &#123;</span><br><span class="line">if key &#x3D;&#x3D; nil || value &#x3D;&#x3D; nil &#123;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line">file :&#x3D; key.(*os.File)</span><br><span class="line">defer func() &#123;</span><br><span class="line">_ &#x3D; file.Close()</span><br><span class="line">&#125;()</span><br><span class="line">buf :&#x3D; make([]byte, 1)</span><br><span class="line">buf[0] &#x3D; 0</span><br><span class="line">rights :&#x3D; syscall.UnixRights(int(file.Fd()))</span><br><span class="line">_, _, err :&#x3D; unixConn.WriteMsgUnix(buf, rights, nil)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">logger.Println(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">logger.Printf(&quot;send fd %d\n&quot;, file.Fd())</span><br><span class="line">return true</span><br><span class="line">&#125;)</span><br><span class="line">finish :&#x3D; make([]byte, 1)</span><br><span class="line">finish[0] &#x3D; 1</span><br><span class="line">_, _, err &#x3D; unixConn.WriteMsgUnix(finish, nil, nil)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">logger.Println(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">isUpdate &#x3D; true</span><br><span class="line">execSpec :&#x3D; &amp;syscall.ProcAttr&#123;</span><br><span class="line">Env:   os.Environ(),</span><br><span class="line">Files: append([]uintptr&#123;os.Stdin.Fd(), os.Stdout.Fd(), os.Stderr.Fd()&#125;),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pid, err :&#x3D; syscall.ForkExec(os.Args[0], os.Args, execSpec)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">logger.Println(err.Error())</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">logger.Printf(&quot;old process %d new process %d\n&quot;, os.Getpid(), pid)</span><br><span class="line">_ &#x3D; serverListener.Close()</span><br><span class="line"></span><br><span class="line">connWait.Wait()</span><br><span class="line">os.Exit(0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; client.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;net&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">writeTimeout &#x3D; time.Second * 5</span><br><span class="line">readTimeout  &#x3D; time.Second * 5</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">conn, err :&#x3D; net.Dial(&quot;tcp&quot;, &quot;127.0.0.1:7000&quot;)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">panic(err)</span><br><span class="line">&#125;</span><br><span class="line">defer func() &#123;</span><br><span class="line">conn.Close()</span><br><span class="line">&#125;()</span><br><span class="line">for &#123;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">err :&#x3D; conn.SetWriteDeadline(time.Now().Add(writeTimeout))</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;send ping&quot;)</span><br><span class="line">_, err &#x3D; conn.Write([]byte(&#96;ping&#96;))</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">err &#x3D; conn.SetReadDeadline(time.Now().Add(readTimeout))</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">rBuf :&#x3D; make([]byte, 4)</span><br><span class="line">_, err &#x3D; conn.Read(rBuf)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;recv &quot; + string(rBuf))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近小编一直在做长连接相关的事情，最大的感触就是发版太痛苦，一个个踢掉连接然后发版，导致发版时长过长，操作繁琐。所以在想能不能实现优雅重启, 发版时客户端无感知。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;1-难点&quot;&gt;&lt;a href=&quot;#1-难点&quot; class=&quot;headerlink&quot; title=&quot;1.难点&quot;&gt;&lt;/a&gt;1.难点&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如何做到不中断接收连接&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如何做到已有连接不中断&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-解决&quot;&gt;&lt;a href=&quot;#2-解决&quot; class=&quot;headerlink&quot; title=&quot;2.解决&quot;&gt;&lt;/a&gt;2.解决&lt;/h1&gt;&lt;h2 id=&quot;2-1-如何做到不中断接受连接&quot;&gt;&lt;a href=&quot;#2-1-如何做到不中断接受连接&quot; class=&quot;headerlink&quot; title=&quot;2.1 如何做到不中断接受连接&quot;&gt;&lt;/a&gt;2.1 如何做到不中断接受连接&lt;/h2&gt;&lt;p&gt;以下是linux源码中bind的实现(linux-1.0)&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F; linux-1.0&amp;#x2F;net&amp;#x2F;socket.c 536&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static int&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sock_bind(int fd, struct sockaddr *umyaddr, int addrlen)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  struct socket *sock;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  int i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  DPRINTF((net_debug, &amp;quot;NET: sock_bind: fd &amp;#x3D; %d\n&amp;quot;, fd));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  if (fd &amp;lt; 0 || fd &amp;gt;&amp;#x3D; NR_OPEN || current-&amp;gt;filp[fd] &amp;#x3D;&amp;#x3D; NULL)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;								return(-EBADF);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#x2F;&amp;#x2F;获取fd对应的socket结构&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  if (!(sock &amp;#x3D; sockfd_lookup(fd, NULL))) return(-ENOTSOCK);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#x2F;&amp;#x2F; 转调用bind指向的函数，下层函数(inet_bind)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  if ((i &amp;#x3D; sock-&amp;gt;ops-&amp;gt;bind(sock, umyaddr, addrlen)) &amp;lt; 0) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	DPRINTF((net_debug, &amp;quot;NET: sock_bind: bind failed\n&amp;quot;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return(0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F; linux-1.0&amp;#x2F;net&amp;#x2F;inet&amp;#x2F;sock.c 1012&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static int&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;inet_bind(struct socket *sock, struct sockaddr *uaddr,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	       int addr_len)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;outside_loop:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  for(sk2 &amp;#x3D; sk-&amp;gt;prot-&amp;gt;sock_array[snum &amp;amp; (SOCK_ARRAY_SIZE -1)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					sk2 !&amp;#x3D; NULL; sk2 &amp;#x3D; sk2-&amp;gt;next) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#if 	1	&amp;#x2F;* should be below! *&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if (sk2-&amp;gt;num !&amp;#x3D; snum) continue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;*	if (sk2-&amp;gt;saddr !&amp;#x3D; sk-&amp;gt;saddr) continue; *&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#endif&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if (sk2-&amp;gt;dead) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		destroy_sock(sk2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		goto outside_loop;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if (!sk-&amp;gt;reuse) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		sti();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		return(-EADDRINUSE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if (sk2-&amp;gt;num !&amp;#x3D; snum) continue;		&amp;#x2F;* more than one *&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if (sk2-&amp;gt;saddr !&amp;#x3D; sk-&amp;gt;saddr) continue;	&amp;#x2F;* socket per slot ! -FB *&amp;#x2F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if (!sk2-&amp;gt;reuse) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		sti();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		return(-EADDRINUSE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ... &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;sock_array是一个链式哈希表，保存着各端口号的sock结构  &lt;/li&gt;
&lt;li&gt;通过源码可以看到，bind的时候会检测要绑定的地址和端口是否合法以及已被绑定, 如果发版时另一个进程和旧进程没有关系，则bind会返回错误Address already in use  &lt;/li&gt;
&lt;li&gt;若旧进程fork出新进程，新进程和旧进程为父子关系，新进程继承旧进程的文件表，本身”本进程”就已经监听这个端口了，则不会出现上面的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-2-如何做到已有连接不中断&quot;&gt;&lt;a href=&quot;#2-2-如何做到已有连接不中断&quot; class=&quot;headerlink&quot; title=&quot;2.2 如何做到已有连接不中断&quot;&gt;&lt;/a&gt;2.2 如何做到已有连接不中断&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;新进程继承旧进程的用于连接的fd，并且继续维持与客户端的心跳&lt;/p&gt;
&lt;p&gt;linux提供了unix域套接字可用于socket的传输, 新进程起来后通过unix socket通信继承旧进程所维护的连接&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="网络" scheme="https://journey-c.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="Golang" scheme="https://journey-c.github.io/tags/Golang/"/>
    
  </entry>
  
</feed>
