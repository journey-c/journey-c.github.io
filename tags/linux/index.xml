<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
  <title>Linux on Journey-C</title>
  <link>https://journey-c.github.io/tags/linux/</link>
  <description>Recent content in Linux on Journey-C</description>
  <generator>Hugo -- gohugo.io</generator>
  
  <language>en-us</language>
  
  
  
  
  <lastBuildDate>Sun, 23 Jan 2022 19:07:41 +0800</lastBuildDate>
  
      <atom:link href="https://journey-c.github.io/tags/linux/index.xml" rel="self" type="application/rss+xml" />
  
  
  <item>
    <title>Linux进程管理和调度（一）</title>
    <link>https://journey-c.github.io/linux-process-management-and-scheduling-1/</link>
    <pubDate>Sun, 23 Jan 2022 19:07:41 +0800</pubDate>
    
    <guid>https://journey-c.github.io/linux-process-management-and-scheduling-1/</guid>
    <description>&lt;p&gt;几乎所有现代操作系统都支持同时运行若干程序（至少在用户错觉是这样的）。这种错觉是由内核和处理器建立的，在很短的时间间隔内多任务不停切换。由于用户无法注意到短时间内的停滞，所以就造成了感官上的多任务并行。本文就一起来探究一下Linux是如果管理多任务的。&lt;/p&gt;
&lt;h1 id=&#34;进程表示&#34;&gt;进程表示&lt;/h1&gt;
&lt;p&gt;既然要管理任务，就要有一个描述任务的数据结构，操作系统一般用&lt;a href=&#34;https://en.wikipedia.org/wiki/Process_(computing)&#34;&gt;进程&lt;/a&gt;来表示任务，Linux中将进程线程抽象为&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/sched.h#L640&#34;&gt;struct task_struct&lt;/a&gt;，&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/sched.h#L640&#34;&gt;struct task_struct&lt;/a&gt;中涉及了若干个子系统，十分的复杂，我们一点点来分析。

&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/linux-process-management-and-scheduling-process.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/linux-process-management-and-scheduling-process.png&#34; alt=&#34;linux-process-management-and-scheduling-process&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;h2 id=&#34;命名空间&#34;&gt;命名空间&lt;/h2&gt;
&lt;p&gt;在分析其他字段之前，先简单了解一下namespace的概念，因为后边讲的东西多多少少都会涉及这个特性。命名空间提供了虚拟化的一种轻量级形式，使得我们可以从不同的方面来查看运行系统的全局属性。该机制类似于Solaris中的zone或FreeBSD中的jail。&lt;/p&gt;
&lt;h3 id=&#34;概念&#34;&gt;概念&lt;/h3&gt;
&lt;p&gt;传统的类UNIX系统中许多资源都是全局管理的，内核统一维护所有进程的ID，以及用户ID等，调用者调用uname命令看到的内核信息都是相同的。&lt;/p&gt;
&lt;p&gt;全局管理可以有选择的允许或拒绝某些特权，0号进程几乎可以做任何事，但是其他用户的权限会被收敛，例如用户A不能杀死用户B的进程。虽然用户A不能杀死用户B的进程，但是能看到。Linux是多任务、多用户的的系统，没道理不让看其他用户的活动。&lt;/p&gt;
&lt;p&gt;但是在有些情况下，这种特性并不是十分友好，例如云厂商对外提供计算服务，当然要给予他机器所有的权利，最直白的方式是给用户提供物理机，但是用户需要的计算能力不一样，并且采购也需要时间的，运营成品极高。使用KVM或VMWare提供的虚拟化环境是另一种解决问题的方案。但是这种方案的弊端明显，需要先虚出来硬件，然后在此基础上运行操作系统，虽然随着虚拟化的发展，性能损耗可以讲到1%以下。但是创建计算节点的耗时高还是给使用上带来了不便。&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/linux-process-management-and-scheduling-namespace_1.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/linux-process-management-and-scheduling-namespace_1.png&#34; alt=&#34;linux-process-management-and-scheduling-namespace_1&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;


而命名空间则提供了一种新的解决方案，将所有全局资源通过命名空间抽象起来，将一组进程放入容器中，容器间隔离，但也允许一定程度上的共享，例如两个容器共享同一个文件系统。&lt;/p&gt;
&lt;h3 id=&#34;实现&#34;&gt;实现&lt;/h3&gt;
&lt;p&gt;资源隔离后所有资源不再是全局唯一，只有&lt;code&gt;资源+资源所在命名空间&lt;/code&gt;的二元组全局唯一。

&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/linux-process-management-and-scheduling-namespace_2.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/linux-process-management-and-scheduling-namespace_2.png&#34; alt=&#34;linux-process-management-and-scheduling-namespace_1&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/* Namespaces: */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; nsproxy          &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;nsproxy;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/sched.h#L640&#34;&gt;struct task_struct&lt;/a&gt;中使用&lt;a href=&#34;https://github.com/torvalds/linux/blob/60a9483534ed0d99090a2ee1d4bb0b8179195f51/include/linux/nsproxy.h#L31&#34;&gt;struct nsproxy&lt;/a&gt;来维护namespace的信息。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; nsproxy {
    atomic_t count;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; uts_namespace &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;uts_ns;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; ipc_namespace &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;ipc_ns;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; mnt_namespace &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;mnt_ns;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; pid_namespace &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;pid_ns_for_children;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; net       &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;net_ns;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; time_namespace &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;time_ns;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; time_namespace &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;time_ns_for_children;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; cgroup_namespace &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;cgroup_ns;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当前内核可以感知以下命名空间&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;uts_ns 记录了内核名称、版本、体系结构等信息，通过&lt;code&gt;uname&lt;/code&gt;系统调用可以获取&lt;/li&gt;
&lt;li&gt;ipc_us 记录了进程间通信的信息&lt;/li&gt;
&lt;li&gt;mnt_ns 已经装载的文件系统的视图&lt;/li&gt;
&lt;li&gt;pid_ns_for_children 进程ID相关的信息&lt;/li&gt;
&lt;li&gt;net_ns 包含所有网络相关的命名空间参数&lt;/li&gt;
&lt;li&gt;time_ns和time_ns_for_children 维护了时间相关信息&lt;/li&gt;
&lt;li&gt;cgroup_ns 包含了计算资源分配相关的信息，例如CPU、内存、磁盘I/O等&lt;/li&gt;
&lt;li&gt;count是引用计数，各task通过指针指向相同的nsproxy，所以这里有一个引用计数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相同namespace进程通过指针指向同一个nsproxy结构，反之的指向不同nsproxy，这样就做到改变只影响本namespace。&lt;/p&gt;
&lt;h3 id=&#34;相关操作&#34;&gt;相关操作&lt;/h3&gt;
&lt;p&gt;使用最频繁的操作就是获取当前进程所在的命名空间了。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果没有给定数字类型pid或者struct task_struct结构体，就使用get_current()获取当前进程。&lt;/li&gt;
&lt;li&gt;根据task_struct-&amp;gt;thread_pid-&amp;gt;level取出第几个struct upid&lt;/li&gt;
&lt;li&gt;struct upid中有对应的struct pid_namespace&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;进程id&#34;&gt;进程ID&lt;/h2&gt;
&lt;p&gt;进程作为操作系统的一个核心概念，每个进程都有自己的ID：进程ID，也有自己的生命周期。

&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/linux-process-management-and-scheduling-life-cycle.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/linux-process-management-and-scheduling-life-cycle.png&#34; alt=&#34;linux-process-management-and-scheduling-life-cycle&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;p&gt;子进程有父进程，父进程也有父进程，这样就形成了以init进程为根的家族树。除了纵向的关系，还有横向的关系：进程组、会话组。&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/linux-process-management-and-scheduling-process_groups_and_session_groups.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/linux-process-management-and-scheduling-process_groups_and_session_groups.png&#34; alt=&#34;linux-process-management-and-scheduling-process_groups_and_session_groups&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;p&gt;进程组和会话组的之间又形成了两级的关系：进程组是一组进程的集合，而会话组则是一组相关进程组的集合。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程组组长，linux中直接在task_struct中用变量&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/sched.h#L859&#34;&gt;task_struct-&amp;gt;group_leader&lt;/a&gt;指向进程组组长。&lt;/li&gt;
&lt;li&gt;会话组组长，进程组组成会话组，所以会话内某个进程组组长就是会话组组长，每个进程组组长都有一个变量&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/sched/signal.h#L162&#34;&gt;task_struct-&amp;gt;group_leader-&amp;gt;signal-&amp;gt;leader&lt;/a&gt;来表示自己是不是会话组组长。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由上边的描述，进程就需要三个ID来标识不同身份：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程ID（PID）进程的唯一标识。&lt;/li&gt;
&lt;li&gt;进程组ID（PGID）一般为进程组组长的PID，创建新进程是默认会继承父进程PGID。&lt;/li&gt;
&lt;li&gt;会话ID（SID）一般为会话组组长的PID，创建新进程是默认会继承父进程SID。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再细分的话，进程内部的工作单位还有线程，几个线程也可以合并为一个线程组。这样就又需要两个ID来标识身份：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程ID（TID）Linux中当task_struct作为线程时、其TID的值为PID。&lt;/li&gt;
&lt;li&gt;线程组ID（TGID）为线程组组长的TID，而线程组组长的TID就是整个进程的ID，所以Linux中又以TID是否为PID来判断线程是否为主线程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/linux-process-management-and-scheduling-process-id.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/linux-process-management-and-scheduling-process-id.png&#34; alt=&#34;linux-process-management-and-scheduling-process-id&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;p&gt;如果没有命名空间的特性的话，内核可以直接在struct task_struct使用五个数字类型的ID来表示上面定义的ID。但是命名空间的特性使得各种ID的维护变得更加的复杂。&lt;/p&gt;
&lt;p&gt;PID的命名空间类似树形的层次结构，创建一个新的命名空间时，该空间内所有的PID都是对父命名空间以及上层的命名空间可见的。往上多一层就要多一个ID表示。&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/linux-process-management-and-scheduling-process-id-namespace_1.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/linux-process-management-and-scheduling-process-id-namespace_1.png&#34; alt=&#34;linux-process-management-and-scheduling-process-id-namespace_1&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;p&gt;例如图中进程，对init命名空间、命名空间2、命名空间4可见，则PID就需要三个值来分别在三个命名空间表示唯一。&lt;/p&gt;
&lt;p&gt;根据命名空间的分层，可以将PID分成两类：全局ID、局部ID&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;全局ID，是内核本身和初始命名空间(init进程所在namespace)的ID号。&lt;/li&gt;
&lt;li&gt;局部ID，属于某个特定namespace，不同namespace间可以相同，但namespace内部不同。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;全局id&#34;&gt;全局ID&lt;/h3&gt;
&lt;p&gt;首先全局的pid和tgid直接保存在struct task_struct中。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; task_struct {
    ...
    pid_t pid;
    pid_t tgid;
    ...
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其余全局ID都可以用这两个ID来表示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全局SID，为会话组组长的全局pid。&lt;/li&gt;
&lt;li&gt;全局PGID，为进程组组长的全局pid。&lt;/li&gt;
&lt;li&gt;全局TID，当task_struct为线程时，pid就是tid，则全局pid也就是全局tid&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;局部id&#34;&gt;局部ID&lt;/h3&gt;
&lt;p&gt;除了全局ID这两个字段之外，内核还需要管理局部ID，因为增加了namespace的特性，所以这需要几个相互联系的数据结构，以及辅助函数。&lt;/p&gt;
&lt;h4 id=&#34;数据结构&#34;&gt;数据结构&lt;/h4&gt;
&lt;p&gt;先来看一下pid的&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/pid_namespace.h#L20&#34;&gt;namespace&lt;/a&gt;表示方式。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; pid_namespace {
    ...
	&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; task_struct &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;child_reaper;
    ...
	&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; level;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; pid_namespace &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;parent;
    ...
} __randomize_layout;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中主要的变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;child_reaper 每个命名空间必须绑定一个进程，这个进程就相当于init进程，该进程也必须完成init进程的工作，例如对孤儿进程调用&lt;code&gt;wait4&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;parent 指向父命名空间。level表示当前命名空间的深度，初始为0，依次递增。level较低命名空间对较高命名空间可见。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;局部pid的管理主要围绕两个数据结构：&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/pid.h#L59&#34;&gt;struct pid&lt;/a&gt;是内核对局部ID的表示，而&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/pid.h#L54&#34;&gt;struct upid&lt;/a&gt;则是PID在namespace内的可见信息。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; upid {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; nr;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; pid_namespace &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;ns;
};
&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; pid
{
    refcount_t count;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; level;
    spinlock_t lock;
    &lt;span style=&#34;color:#75715e&#34;&gt;/* 使用该pid的进程列表 */&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; hlist_head tasks[PIDTYPE_MAX];
    &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; hlist_head inodes;
    &lt;span style=&#34;color:#75715e&#34;&gt;/* wait queue for pidfd notifications */&lt;/span&gt;
    wait_queue_head_t wait_pidfd;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; rcu_head rcu;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; upid numbers[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;首先是&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/pid.h#L54&#34;&gt;struct upid&lt;/a&gt;，变量nr表示id的数值，比如执行shell命令&lt;code&gt;ps&lt;/code&gt;得到的PID就是取的这个值。ns指向对应的namespace。这样一个数据结构就能在增加namespace特性的情况下唯一的表示一个局部ID。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/pid.h#L59&#34;&gt;struct pid&lt;/a&gt;中count是一个引用计数，task是一个散列数组，包含了所有引用该struct pid的进程。因为同一个ID可能用于几个进程。比如进程组内进程组ID相同等。PIDTYPE_MAX表示ID的类型数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;enum&lt;/span&gt; pid_type
{
    PIDTYPE_PID,
    PIDTYPE_TGID,
    PIDTYPE_PGID,
    PIDTYPE_SID,
    PIDTYPE_MAX,
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一个进程可能对多个namespace都可见，所以level表示namespace的深度，如图左下角。而numbers对应一个&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/pid.h#L54&#34;&gt;struct upid&lt;/a&gt;的数组，长度为level，表示在每个namespace的ID。&lt;strong&gt;注意该数组形式上只有一个数组项，如果一个进程只包含在全局命名空间中，那么确实如此。由于该数组位于结构的末尾，因此 只要分配更多的内存空间，即可向数组添加附加的项。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/linux-process-management-and-scheduling-process-id-2.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/linux-process-management-and-scheduling-process-id-2.png&#34; alt=&#34;linux-process-management-and-scheduling-process-id-2&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;p&gt;这三个数据结构的关系如上图：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;struct task_struct内部会有指向struct pid的指针，方便查找ID时找到数据结构。指向struct pid的指针也做了分类，像PID、TID这种一般不会进行&lt;strong&gt;组操作的ID&lt;/strong&gt;就用struct pid *thread_pid指针缓存，查找PID时直接用这个指针。而PGID、TGID、SID这种需要&lt;strong&gt;组操作的ID&lt;/strong&gt;就放在task_struct-&amp;gt;signal-&amp;gt;pids[PID_TYPE]里面，查找这三类ID时就直接从task_struct-&amp;gt;signal-&amp;gt;pids[PID_TYPE]查。&lt;/li&gt;
&lt;li&gt;同时struct pid也会缓存引用他的struct task_struct，将引用他的struct task_struct都放在自身tasks变量中。&lt;/li&gt;
&lt;li&gt;struct pid中level变量会记录当前struct pid在第几层namespace，而pid-&amp;gt;numbers记录了ID在各层ID数值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;函数&#34;&gt;函数&lt;/h4&gt;
&lt;p&gt;内核提供了若干函数辅助操作上面的三个数据结构，但本质离不开两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;给定局部数字类型ID和namespace，如何找到对应的struct pid。&lt;/li&gt;
&lt;li&gt;给出task_struct、ID类型和namespace，如何找到数字类型的ID。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在这两个问题之前，有个问题：如何找到进程所在的namespace？&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/linux-process-management-and-scheduling-process-id-find-namespace.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/linux-process-management-and-scheduling-process-id-find-namespace.png&#34; alt=&#34;linux-process-management-and-scheduling-process-id-find-namespace&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;p&gt;首先如果没给定task_struct的话，可以调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/arch/x86/include/asm/current.h#L18&#34;&gt;current&lt;/a&gt;宏获取当前所在task_struct。&lt;/p&gt;
&lt;p&gt;然后调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/kernel/pid.c#L507&#34;&gt;task_active_pid_ns&lt;/a&gt;获取namespace，大概流程就是，通过task_struct-&amp;gt;thread_pid指针获的指向的struct pid，其变量记录了当前所在第几层namespace，然后从pid-&amp;gt;numbers[level]变量中取出对应的struct upid，其变量记录了对应的namespace。&lt;/p&gt;
&lt;p&gt;再回到前边两个问题:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;[1]给定局部数字类型ID和namespace，如何找到对应的struct pid?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;内核用&lt;a href=&#34;https://en.wikipedia.org/wiki/Radix_tree&#34;&gt;基数树&lt;/a&gt;存储局部ID到struct pid的映射，实际就是存储了局部ID（数字类型）对应的struct pid的内存地址（数字）。&lt;/p&gt;
&lt;p&gt;通过&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/kernel/pid.c#L309&#34;&gt;find_pid_ns&lt;/a&gt;找到局部ID对应的struct pid对象。&lt;/p&gt;
&lt;p&gt;然后根据需要的ID的类型取出pid-&amp;gt;tasks[ID_TYPE]散列表中第一个实例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;[2] 给出task_struct、ID类型和namespace，如何找到数字类型的ID?&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过task_struct和ID类型拿到struct pid:
&lt;ol&gt;
&lt;li&gt;PID/TID: 取task_struct-&amp;gt;thread_pid&lt;/li&gt;
&lt;li&gt;其他类型:
&lt;ol&gt;
&lt;li&gt;PGID: 通过task_struct-&amp;gt;group_leader找到进程组组长对应的task_struct&lt;/li&gt;
&lt;li&gt;TGID: 线程组ID就是PID，调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/arch/x86/include/asm/current.h#L18&#34;&gt;current&lt;/a&gt;获取task_struct&lt;/li&gt;
&lt;li&gt;SID: 调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/arch/x86/include/asm/current.h#L18&#34;&gt;current&lt;/a&gt;获取task_struct。&lt;/li&gt;
&lt;li&gt;分别调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/sched.h#L1368&#34;&gt;task_pid&lt;/a&gt;、&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/sched/signal.h#L637&#34;&gt;task_pgrp&lt;/a&gt;、&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/sched/signal.h#L627&#34;&gt;task_tgid&lt;/a&gt;、&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/sched/signal.h#L642&#34;&gt;task_session&lt;/a&gt;获取对应的struct pid&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;然后根据struct pid和namespace找到对应数字类型ID，这里实际就是用namespace里的level去struct pid里取第几个struct upid，然后struct upid的成员变量nr就是所需要的数字类型id。&lt;/li&gt;
&lt;/ol&gt;
</description>
  </item>
  
  <item>
    <title>网络性能优化：TFO</title>
    <link>https://journey-c.github.io/linux-tcp-fast-open/</link>
    <pubDate>Mon, 12 Jul 2021 22:38:33 +0800</pubDate>
    
    <guid>https://journey-c.github.io/linux-tcp-fast-open/</guid>
    <description>&lt;p&gt;今天大多数的web服务都是基于TCP协议对外提供交互，TCP协议是诞生在网络环境普遍很差的年代。传输时延由客户端和服务端之间往返时间(RTT)以及数据传输需要的往返次数决定。过去的几十年网络带宽有大幅增长，但传输时延还是受到光速的限制，所以谷歌公司在2011年的&lt;a href=&#34;https://conferences.sigcomm.org/co-next/2011/papers/1569470463.pdf&#34;&gt;TCP FAST OPEN&lt;/a&gt;论文中介绍TCP协议的扩展——TCP FAST OPEN。&lt;/p&gt;
&lt;h1 id=&#34;背景&#34;&gt;背景&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.rfc-editor.org/pdfrfc/rfc793.txt.pdf&#34;&gt;TCP标准&lt;/a&gt;中只允许握手建立连接后进行数据传输，这就意味着在应用层数据交互之前有一个额外的RTT。

&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/linux-tcp-fast-open-tcp-handshake.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/linux-tcp-fast-open-tcp-handshake.png&#34; alt=&#34;TCP Handshake&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;


而这个额外RTT是传播时延的一部分。下图是谷歌公司统计的google.com请求中TCP握手占总请求时延的百分比。可以看到cold request(新TCP连接)的握手时延占比明显高出很多。

&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/linux-tcp-fast-open-tcp-handshake-cast.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/linux-tcp-fast-open-tcp-handshake-cast.png&#34; alt=&#34;TCP Handshake Cast&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;


这个问题的解决方案一个是应用层协议复用TCP，请求结束后连接不关闭，缓存给下次使用。但实际效果不理想，谷歌公司对一些大型CDN的研究表明，实际生产中每个TCP连接平均只有2.4个HTTP请求。&lt;/p&gt;
&lt;p&gt;而另外一种解决方式就是在握手时期就进行数据传输，直接消除了额外的RTT。TCP标准中也是在握手第三阶段将数据包放入了SYN包中，所以应用层数据放入第一、二阶段SYN包中的设计理论上也是可行的。然而，这个想法的直接实现容易受到拒绝服务 (DoS) 攻击，并且可能面临重复或陈旧 SYN 的困难。谷歌的论文中提出了一种称为 TCP 快速打开 (TFO) 的新 TCP 机制，它可以在 TCP 的初始握手期间安全地交换数据。 TFO 的核心是一个安全 cookie，服务器使用它来验证启动 TFO 连接的客户端。

&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/linux-tcp-fast-open-tcp-fast-open.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/linux-tcp-fast-open-tcp-fast-open.png&#34; alt=&#34;TCP Fast Open&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;h1 id=&#34;实现&#34;&gt;实现&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;(被抓包程序代码在最后)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新TCP连接时，客户端发送带有 Fast Open Cookie Request TCP 选项的 SYN 数据包。

&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/linux-tcp-fast-open-tfo1.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/linux-tcp-fast-open-tfo1.png&#34; alt=&#34;1&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;p&gt;服务器通过在密钥下加密客户端的 IP 地址来生成 cookie。服务器使用 SYN-ACK 响应客户端，该 SYN-ACK 在 TCP 选项字段中包含生成的 Fast Open Cookie。

&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/linux-tcp-fast-open-tfo2.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/linux-tcp-fast-open-tfo2.png&#34; alt=&#34;2&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;p&gt;客户端缓存 cookie，以便将来 TFO 连接到同一服务器。&lt;/p&gt;
&lt;p&gt;要使用从服务器接收到的TFO cookie，客户端执行以下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端发送带有缓存的 Fast Open cookie（作为 TCP 选项）以及应用程序数据的 SYN。&lt;/li&gt;
&lt;li&gt;服务器通过解密并比较 IP 地址或通过重新加密 IP 地址并与接收到的 cookie 进行比较来验证 cookie。
&lt;ol&gt;
&lt;li&gt;如果 cookie 有效，服务器发送一个 SYN-ACK 确认 SYN 和数据。数据被传送到服务器应用程序。&lt;/li&gt;
&lt;li&gt;否则，服务器丢弃数据，并发送仅确认 SYN 序列号的 SYN-ACK。连接通过常规的 3WHS 进行。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;如果SYN包中的数据被接受，服务器可能会在收到客户端的第一个ACK之前向客户端发送额外的响应数据段。&lt;/li&gt;
&lt;li&gt;客户端发送确认服务器 SYN 的 ACK。如果客户端的数据未被确认，则使用 ACK 重新传输。&lt;/li&gt;
&lt;li&gt;然后连接像正常的 TCP 连接一样进行。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/linux-tcp-fast-open-tfo3.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/linux-tcp-fast-open-tfo3.png&#34; alt=&#34;3&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;


可以看到第二次TCP连接的握手第一步携带了上次服务端返回的cookie，并且携带了数据的。&lt;/p&gt;
&lt;p&gt;TFO是TCP协议的experimental update，所以协议要求TCP实现默认必须禁止TFO，Linux中打开方式如下：（确保内核版本在3.17及以上）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;在/etc/sysctl.conf文件中添加
net.ipv4.tcp_fastopen&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/net/tcp.h#L232&#34;&gt;Linux实现&lt;/a&gt;中，tcp_fastopen值如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define	TFO_CLIENT_ENABLE	1
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define	TFO_SERVER_ENABLE	2
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define	TFO_CLIENT_NO_COOKIE	4	&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/* Data in SYN w/o cookie option */&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;设置为3，则客户端服务端均开启TFO功能。&lt;/p&gt;
&lt;p&gt;最后是谷歌公司针对TFO做的对比数据，可以看到TFO机制明显缩短了传输时延，并且RTT越大的情况下越明显。

&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/linux-tcp-fast-open-result.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/linux-tcp-fast-open-result.png&#34; alt=&#34;result&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;h1 id=&#34;广域网tfo可用性&#34;&gt;广域网TFO可用性&lt;/h1&gt;
&lt;p&gt;由于中间路由器、交换机等设备可能不支持，导致TFO在互联网环境下可能失败，从而弱化到标准的TCP握手，甚至导致更恶劣的重传，不过从Anna Maria Mandalari博士的测试数据来看，只有2.18%的SYN数据包会被直接丢弃，引起重传。
下面是博士团队在2015年对18个国家、22个ISP环境下进行TFO的测试数据&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/linux-tcp-fast-open-result-data.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/linux-tcp-fast-open-result-data.png&#34; alt=&#34;result&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;h1 id=&#34;附录&#34;&gt;附录&lt;/h1&gt;
&lt;h2 id=&#34;serverc&#34;&gt;server.c&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;arpa/inet.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;errno.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;netdb.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Listen&lt;/span&gt;() {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; rc;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; addrinfo &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;listp, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;p, hints;
    memset(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;hints, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(hints));
    hints.ai_family &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; AF_INET;
    hints.ai_socktype &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; SOCK_STREAM;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ((rc &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; getaddrinfo(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0.0.0.0&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;8080&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;hints, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;listp)) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
        printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;getaddrinfo: %s&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, gai_strerror(rc));
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; ln;
    socklen_t ai_addrlen;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; sockaddr ai_addr;

    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; listp; p; p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; listp&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;ai_next) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ((ln &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; socket(p&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;ai_family, p&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;ai_socktype, p&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;ai_protocol)) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ((rc &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bind(ln, p&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;ai_addr, p&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;ai_addrlen)) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {
            printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;bind: %d %s&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, errno, strerror(errno));
            close(ln);
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; qlen &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;;
        setsockopt(ln, p&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;ai_protocol, &lt;span style=&#34;color:#ae81ff&#34;&gt;23&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;qlen, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(qlen));
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ((rc &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; listen(ln, &lt;span style=&#34;color:#ae81ff&#34;&gt;128&lt;/span&gt;)) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {
            printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;listen: %d %s&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, errno, strerror(errno));
            close(ln);
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
        }

        ai_addr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;p&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;ai_addr;
        ai_addrlen &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; p&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;ai_addrlen;
    }
    freeaddrinfo(listp);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; ln;
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;request&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; client) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; buf[&lt;span style=&#34;color:#ae81ff&#34;&gt;1024&lt;/span&gt;];
    recv(client, buf, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
    printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%s&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, buf);
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;response&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; client) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; buf[&lt;span style=&#34;color:#ae81ff&#34;&gt;1024&lt;/span&gt;];

    sprintf(buf, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;pong&amp;#34;&lt;/span&gt;);
    send(client, buf, strlen(buf), &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;argv) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; ln &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Listen();
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (ln &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (;;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; sockaddr ai_addr;
        socklen_t ai_addrlen;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; client &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; accept(ln, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;ai_addr, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;ai_addrlen);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (client &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {
            printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;accept: %d %s&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, errno, strerror(errno));
            &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; sockaddr_in addr;
        socklen_t addrlen &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(addr);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (getpeername(client, (&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; sockaddr &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;addr, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;addrlen) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {
            printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;get remote addr: %d %s&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, errno,
                   strerror(errno));
            &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; port &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ntohs(addr.sin_port);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;ip &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; inet_ntoa(addr.sin_addr);
        printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;client addr: %s:%d&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, ip, port);

        request(client);
        response(client);
        close(client);
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;clientc&#34;&gt;client.c&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;errno.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;netdb.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;netinet/in.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;request&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; client) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; buf[&lt;span style=&#34;color:#ae81ff&#34;&gt;1024&lt;/span&gt;];

    sprintf(buf, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ping&amp;#34;&lt;/span&gt;);
    send(client, buf, strlen(buf), &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;response&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; client) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; buf[&lt;span style=&#34;color:#ae81ff&#34;&gt;1024&lt;/span&gt;];
    recv(client, buf, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
    printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%s&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, buf);
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; sockaddr_in serv_addr;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; hostent &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;server;

    &lt;span style=&#34;color:#75715e&#34;&gt;// 第一次
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; client &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; socket(AF_INET, SOCK_STREAM, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
    server &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; gethostbyname(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;localhost&amp;#34;&lt;/span&gt;);

    bzero((&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;serv_addr, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(serv_addr));
    serv_addr.sin_family &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; AF_INET;
    bcopy((&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)server&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;h_addr, (&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;serv_addr.sin_addr.s_addr,
          server&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;h_length);
    serv_addr.sin_port &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; htons(&lt;span style=&#34;color:#ae81ff&#34;&gt;8080&lt;/span&gt;);

    sendto(client, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ping&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;, MSG_FASTOPEN &lt;span style=&#34;color:#75715e&#34;&gt;/*MSG_FASTOPEN*/&lt;/span&gt;,
           (&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; sockaddr &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;serv_addr, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(serv_addr));
    response(client);
    close(client);

    &lt;span style=&#34;color:#75715e&#34;&gt;// 第二次
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    client &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; socket(AF_INET, SOCK_STREAM, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
    server &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; gethostbyname(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;localhost&amp;#34;&lt;/span&gt;);

    bzero((&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;serv_addr, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(serv_addr));
    serv_addr.sin_family &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; AF_INET;
    bcopy((&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)server&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;h_addr, (&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;serv_addr.sin_addr.s_addr,
          server&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;h_length);
    serv_addr.sin_port &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; htons(&lt;span style=&#34;color:#ae81ff&#34;&gt;8080&lt;/span&gt;);

    sendto(client, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ping&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;, MSG_FASTOPEN &lt;span style=&#34;color:#75715e&#34;&gt;/*MSG_FASTOPEN*/&lt;/span&gt;,
           (&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; sockaddr &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;serv_addr, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(serv_addr));
    response(client);
    close(client);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
  </item>
  
  <item>
    <title>Linux内存管理</title>
    <link>https://journey-c.github.io/linux-memory-management-1/</link>
    <pubDate>Fri, 19 Feb 2021 23:25:19 +0800</pubDate>
    
    <guid>https://journey-c.github.io/linux-memory-management-1/</guid>
    <description>&lt;blockquote&gt;
&lt;p&gt;计算机的计算，一方面说的是进程、线程对于CPU的使用，另一方面是对于内存的管理。本文就是介绍Linux的内存管理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Linux中用户态是没有权限直接操作物理内存的，与硬件相关的交互都是通过系统调用由内核来完成操作的。Linux抽象出虚拟内存，用户态操作的只是虚拟内存，真正操作的物理内存由内核内存管理模块管理。本文通篇都在探索三个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;虚拟地址空间是如何管理的&lt;/li&gt;
&lt;li&gt;物理地址空间是如何管理的&lt;/li&gt;
&lt;li&gt;虚拟地址空间和物理地址空间是如何映射的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上述三个问题得到解决之后，我们就可通过一个虚拟地址空间找到对应的物理地址空间。我们首先来看一下Linux虚拟地址空间的管理。&lt;/p&gt;
&lt;h1 id=&#34;1-虚拟地址空间的管理&#34;&gt;1. 虚拟地址空间的管理&lt;/h1&gt;
&lt;p&gt;是不是用户态使用虚拟内存，内核态直接使用物理内存呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不是的，内核态和用户态使用的都是虚拟内存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用虚拟地址一个核心的问题，需要记录虚拟地址到物理地址的映射，最简单的方式是虚拟地址与物理地址一一对应，这样4G内存光是维护映射关系就需要4G（扯淡）。所以需要其他有效的内存管理方案。通常有两种：分段、分页。下面我们来一起分析一下这两种管理机制以及在Linux中是如何应用的。&lt;/p&gt;
&lt;h2 id=&#34;分段&#34;&gt;分段&lt;/h2&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/memory-management-x86-cpu.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/memory-management-x86-cpu.png&#34; alt=&#34;&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;


8086升级到80386之后，段寄存器CS、DS、SS、ES从直接存放地址变成高位存放段选择子，低位做段描述符缓存器。由原来的直接使用内存地址变为现在的通过分段机制来使用内存地址。&lt;/p&gt;
&lt;p&gt;那我们先来看一下内存管理中分段机制的原理。&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/memory-management-segmented.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/memory-management-segmented.png&#34; alt=&#34;&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;p&gt;分段机制下虚拟地址由两部分组成，&lt;strong&gt;段选择子&lt;/strong&gt;和&lt;strong&gt;段内偏移量&lt;/strong&gt;。段选择子中的段号作为段表的索引，通过段号可以在段表找到对应段表项，每一项记录了一段空间：段基址、段的界限、特权级等。用段基址+段内偏移量就可以计算出对应的物理地址。&lt;/p&gt;
&lt;p&gt;Linux中段表称为段描述符表，放在全局描述符表中，用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/arch/x86/include/asm/desc_defs.h#L23&#34;&gt;GDT_ENTRY_INIT&lt;/a&gt;函数来初始化表项&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/arch/x86/include/asm/desc_defs.h#L16&#34;&gt;desc_struct&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;下面是Linux中&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/arch/x86/include/asm/segment.h#L171&#34;&gt;段选择子&lt;/a&gt;和&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/arch/x86/kernel/cpu/common.c#L115&#34;&gt;段表&lt;/a&gt;的定义，看一下所有段表项初始化传入的参数中，段基址base都是0，这没有分段。事实上Linux中没有用到全部的分段功能，对于内存管理更倾向于分页机制。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define GDT_ENTRY_KERNEL32_CS		1
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define GDT_ENTRY_KERNEL_CS		2
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define GDT_ENTRY_KERNEL_DS		3
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#define GDT_ENTRY_DEFAULT_USER32_CS	4
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define GDT_ENTRY_DEFAULT_USER_DS	5
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define GDT_ENTRY_DEFAULT_USER_CS	6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;DEFINE_PER_CPU_PAGE_ALIGNED(&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; gdt_page, gdt_page) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; { .gdt &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
&lt;span style=&#34;color:#75715e&#34;&gt;#ifdef CONFIG_X86_64
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	[GDT_ENTRY_KERNEL32_CS]		&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; GDT_ENTRY_INIT(&lt;span style=&#34;color:#ae81ff&#34;&gt;0xc09b&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0xfffff&lt;/span&gt;),
	[GDT_ENTRY_KERNEL_CS]		&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; GDT_ENTRY_INIT(&lt;span style=&#34;color:#ae81ff&#34;&gt;0xa09b&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0xfffff&lt;/span&gt;),
	[GDT_ENTRY_KERNEL_DS]		&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; GDT_ENTRY_INIT(&lt;span style=&#34;color:#ae81ff&#34;&gt;0xc093&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0xfffff&lt;/span&gt;),
	[GDT_ENTRY_DEFAULT_USER32_CS]	&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; GDT_ENTRY_INIT(&lt;span style=&#34;color:#ae81ff&#34;&gt;0xc0fb&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0xfffff&lt;/span&gt;),
	[GDT_ENTRY_DEFAULT_USER_DS]	&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; GDT_ENTRY_INIT(&lt;span style=&#34;color:#ae81ff&#34;&gt;0xc0f3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0xfffff&lt;/span&gt;),
	[GDT_ENTRY_DEFAULT_USER_CS]	&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; GDT_ENTRY_INIT(&lt;span style=&#34;color:#ae81ff&#34;&gt;0xa0fb&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0xfffff&lt;/span&gt;),
&lt;span style=&#34;color:#75715e&#34;&gt;#else
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	[GDT_ENTRY_KERNEL_CS]		&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; GDT_ENTRY_INIT(&lt;span style=&#34;color:#ae81ff&#34;&gt;0xc09a&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0xfffff&lt;/span&gt;),
	[GDT_ENTRY_KERNEL_DS]		&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; GDT_ENTRY_INIT(&lt;span style=&#34;color:#ae81ff&#34;&gt;0xc092&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0xfffff&lt;/span&gt;),
	[GDT_ENTRY_DEFAULT_USER_CS]	&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; GDT_ENTRY_INIT(&lt;span style=&#34;color:#ae81ff&#34;&gt;0xc0fa&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0xfffff&lt;/span&gt;),
	[GDT_ENTRY_DEFAULT_USER_DS]	&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; GDT_ENTRY_INIT(&lt;span style=&#34;color:#ae81ff&#34;&gt;0xc0f2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0xfffff&lt;/span&gt;),
	......
&lt;span style=&#34;color:#75715e&#34;&gt;#endif
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;} };
EXPORT_PER_CPU_SYMBOL_GPL(gdt_page);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;分页&#34;&gt;分页&lt;/h2&gt;
&lt;p&gt;分页机制和分段机制差不多，都是将物理地址分块。不同的是分段一般将内存大段大段的分割且每段大小一般不相同。而分页将物理内存分成一块块大小相同的页，一般大小为4KB。

&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/memory-management-pagination_0.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/memory-management-pagination_0.png&#34; alt=&#34;&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;


在分页机制下，虚拟地址有两部分组成(两部分不是严格的两段，比如页号就可以有多级页号)，&lt;strong&gt;页号、页内偏移量&lt;/strong&gt;。通过页号找到对应页表项，页表项高位存了物理页号，低位存储了FLAGS。&lt;/p&gt;
&lt;p&gt;例如页大小为4KB，只分一级，32位环境中虚拟地址为32位，$2^{32}/2^{12}=2^{20}$可以分1M个页，用20位可以表示页号，12位表示页内偏移。页表项大小为4B(32位)，那么页表大小就是$1M*4B=4MB$，因为每个进程都有自己独立的虚拟地址空间，有100个进程的话光维护页表就需要100MB的空间，这个对于内核来说有点太大了。

&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/memory-management-pagination_1.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/memory-management-pagination_1.png&#34; alt=&#34;&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;p&gt;Linux是如何解决页表太大的问题呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;采用多级分页的策略才解决页表太大的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;32位环境中，一级分页和上边描述的一样，分成1M个4KB的页，由页表维护虚拟页号到物理页号的映射。内核在这次分页之后，又对页表进行分页。页表大小为4MB，我们在按照4KB一页进行分页，4KB包含页表项1K项。所以二级分页就是把页表1M的项按照1K项为一页分了1K页。

&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/memory-management-pagination_2.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/memory-management-pagination_2.png&#34; alt=&#34;&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;


二级分页后，虚拟地址就被分成三部分：页目录号、页表内偏移、页内偏移。通过虚拟地址查找物理地址时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过虚拟地址前10位的页目录号找到对应页目录项，这个页目录项管理了1K个页表项。&lt;/li&gt;
&lt;li&gt;通过虚拟地址中10位的页表内偏移，从1K个页表项中定位到一个页表项。这个页表项里有物理页号和各种标志位。&lt;/li&gt;
&lt;li&gt;物理页号+虚拟地址中后12位的页内偏移得到对应物理地址。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样用于维护分页机制的额外空间就是页表（4MB）+ 页表目录（4KB），这不是比一级分页更高了吗？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;实际不是的:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果使用一级页表，那么每个进程都需要一个页表来维护虚拟地址空间，就是说100个进程需要额外400 MB的空间。&lt;/li&gt;
&lt;li&gt;如果使用二级页表，每个进程必须的是一个4KB的页目录表。当然并不是每个进程都是用全部4GB内存的。所以4MB的二级页表不会全部使用，用到多少地址就建多少个页表项。所以实际需要额外空间为4KB+使用的页表项数量*4KB

&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/memory-management-pagination_3.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/memory-management-pagination_3.png&#34; alt=&#34;&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然64位的环境中，二级页表就不够了，使用的是四级页表，包括&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/arch/x86/include/asm/pgtable_types.h#L286&#34;&gt;全局页目录项 PGD（Page Global Directory）&lt;/a&gt;、&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/arch/x86/include/asm/pgtable_types.h#L359&#34;&gt;上层页目录项 PUD（Page Upper Directory）&lt;/a&gt;、&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/arch/x86/include/asm/pgtable_types.h#L385&#34;&gt;中间页目录项 PMD（Page Middle Directory）&lt;/a&gt;和&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/arch/x86/include/asm/pgtable_64_types.h#L21&#34;&gt;页表项 PTE（Page Table Entry）&lt;/a&gt;

&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/memory-management-pagination_4.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/memory-management-pagination_4.png&#34; alt=&#34;&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;p&gt;虽然多级分页解决了页表过大的问题，但是同时也增大了访问延时，由原来的一次访问内存，变为现在访问多次页表之后才能访问目的地址。&lt;/p&gt;
&lt;p&gt;到目前为止，我们已经知道如何通过一个虚拟地址得到对应的物理地址。&lt;/p&gt;
&lt;h1 id=&#34;2-进程的虚拟地址空间&#34;&gt;2. 进程的虚拟地址空间&lt;/h1&gt;
&lt;p&gt;接下来我们再一起看一下进程内的虚拟地址空间是什么样的，Linux中没有进程线程的区别，用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/sched.h#L640&#34;&gt;struct task_struct&lt;/a&gt;表示任务。那么我们可以分析&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/sched.h#L640&#34;&gt;struct task_struct&lt;/a&gt;中内存相关变量来分析进程的虚拟内存布局。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; task_struct {
	...
	&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; mm_struct		&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;mm;
	...	
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/sched.h#L640&#34;&gt;struct task_struct&lt;/a&gt;里面&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/mm_types.h#L388&#34;&gt;struct mm_struct&lt;/a&gt;来管理内存。&lt;/p&gt;
&lt;p&gt;首先，既然分析用户态的基本布局，当然要知道用户态和内核态的界限在哪，&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/mm_types.h#L388&#34;&gt;struct mm_struct&lt;/a&gt;里面的&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/mm_types.h#L405&#34;&gt;task_size&lt;/a&gt;变量表示用户态空间的大小。&lt;/p&gt;
&lt;p&gt;使用系统调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/fs/exec.c#L2054&#34;&gt;execve&lt;/a&gt;加载二进制文件的调用链是&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/fs/exec.c#L1977&#34;&gt;do_execve&lt;/a&gt; -&amp;gt; &lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/fs/exec.c#L1855&#34;&gt;do_execveat_common&lt;/a&gt; -&amp;gt; &lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/fs/exec.c#L1775&#34;&gt;bprm_execve&lt;/a&gt; -&amp;gt; &lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/fs/exec.c#L1727&#34;&gt;exec_binprm&lt;/a&gt; -&amp;gt; &lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/fs/exec.c#L1681&#34;&gt;search_binary_handler&lt;/a&gt; -&amp;gt; &lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/fs/binfmt_elf.c#L100&#34;&gt;linux_binfmt的load_binary接口&lt;/a&gt;。load_binary接口实际是&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/fs/binfmt_elf.c#L820&#34;&gt;load_elf_binary&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/fs/binfmt_elf.c#L820&#34;&gt;load_elf_binary&lt;/a&gt;调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/fs/exec.c#L1412&#34;&gt;setup_new_exec&lt;/a&gt;。这个函数中会将task的mm_struct成员变量task_size 设置为TASK_SIZE。&lt;/p&gt;
&lt;p&gt;32位环境中内核定义如下，TASK_SIZE为0xC0000000，用户空间默认3GB，内核空间1GB。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/*
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * User space process size: 3GB (default).
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#define IA32_PAGE_OFFSET	__PAGE_OFFSET
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define TASK_SIZE		__PAGE_OFFSET
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define TASK_SIZE_LOW		TASK_SIZE
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define TASK_SIZE_MAX		TASK_SIZE
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define DEFAULT_MAP_WINDOW	TASK_SIZE
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define STACK_TOP		TASK_SIZE
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define STACK_TOP_MAX		STACK_TOP
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;64位环境中虚拟地址只是用了48位，TASK_SIZE为 (1 &amp;laquo; 47) 减去一页的大小为0x00007FFFFFFFF000。用户空间大概位128TB，内核空间也是128TB，且用户空间和内核空间之间留有空隙用于隔离。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define TASK_SIZE_MAX	((_AC(1,UL) &amp;lt;&amp;lt; __VIRTUAL_MASK_SHIFT) - PAGE_SIZE)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#define DEFAULT_MAP_WINDOW	((1UL &amp;lt;&amp;lt; 47) - PAGE_SIZE)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* This decides where the kernel will search for a free chunk of vm
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * space during mmap&amp;#39;s.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#define IA32_PAGE_OFFSET	((current-&amp;gt;personality &amp;amp; ADDR_LIMIT_3GB) ? \
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;					0xc0000000 : 0xFFFFe000)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#define TASK_SIZE_LOW		(test_thread_flag(TIF_ADDR32) ? \
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;					IA32_PAGE_OFFSET : DEFAULT_MAP_WINDOW)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define TASK_SIZE		(test_thread_flag(TIF_ADDR32) ? \
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;					IA32_PAGE_OFFSET : TASK_SIZE_MAX)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define TASK_SIZE_OF(child)	((test_tsk_thread_flag(child, TIF_ADDR32)) ? \
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;					IA32_PAGE_OFFSET : TASK_SIZE_MAX)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/memory-management-task-size.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/memory-management-task-size.png&#34; alt=&#34;&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;h2 id=&#34;用户态&#34;&gt;用户态&lt;/h2&gt;
&lt;p&gt;了解了用户空间和内核空间分界之后，我们先来看下用户空间。用户态虚拟内存布局如下，32位和64位区域和布局差别不大。

&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/memory-management-user-mode-memory-layout.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/memory-management-user-mode-memory-layout.png&#34; alt=&#34;&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;


这些空间里的内容是从哪填充来的呢？没错，是不是感觉和可执行文件的格式有点像。一个进程创建之后所有的内存空间都是复制父进程的，当父进程调用exec加载新的二进制时就会将二进制文件内容加载到进程内存各个模块中，但是不一定是立即加载，有些非必需字段是用时加载。

&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/memory-management-executable-file-format.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/memory-management-executable-file-format.png&#34; alt=&#34;&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;


&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/mm_types.h#L388&#34;&gt;struct mm_struct&lt;/a&gt;结构体中如下参数定义了这些模块的属性和位置。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;字段名&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;struct vm_area_struct *&lt;/td&gt;
&lt;td&gt;mmap&lt;/td&gt;
&lt;td&gt;内存中每个区域对应一个mmap，这些区域用链表连接起来&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;struct rb_root&lt;/td&gt;
&lt;td&gt;mm_rb&lt;/td&gt;
&lt;td&gt;红黑树，用来辅助操作mmap&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;unsigned long&lt;/td&gt;
&lt;td&gt;mmap_base&lt;/td&gt;
&lt;td&gt;用于映射的内存起始位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;unsigned long&lt;/td&gt;
&lt;td&gt;task_size&lt;/td&gt;
&lt;td&gt;用户空间大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;unsigned long&lt;/td&gt;
&lt;td&gt;total_vm&lt;/td&gt;
&lt;td&gt;总共映射的页数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;unsigned long&lt;/td&gt;
&lt;td&gt;locked_vm&lt;/td&gt;
&lt;td&gt;当内存吃紧，将个别页换到磁盘上，locaked_vm表示被锁定不能换出的页数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;unsigned long&lt;/td&gt;
&lt;td&gt;pinned_vm&lt;/td&gt;
&lt;td&gt;不能换出也不能移动的页数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;unsigned long&lt;/td&gt;
&lt;td&gt;data_vm&lt;/td&gt;
&lt;td&gt;存放数据页数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;unsigned long&lt;/td&gt;
&lt;td&gt;exec_vm&lt;/td&gt;
&lt;td&gt;可执行文件占用的页数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;unsigned long&lt;/td&gt;
&lt;td&gt;stack_vm&lt;/td&gt;
&lt;td&gt;栈占用的页数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;unsigned long&lt;/td&gt;
&lt;td&gt;start_code, end_code, start_data, end_data&lt;/td&gt;
&lt;td&gt;代码段起始和结束位置，数据段起始和结束位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;unsigned long&lt;/td&gt;
&lt;td&gt;start_brk, brk, start_stack&lt;/td&gt;
&lt;td&gt;堆起始结束位置，栈起始位置(栈结束位置在SP寄存器中)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;unsigned long&lt;/td&gt;
&lt;td&gt;arg_start, arg_end, env_start, env_end&lt;/td&gt;
&lt;td&gt;参数列表起始和结束位置，环境变量起始和结束位置&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;函数&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/fs/binfmt_elf.c#L820&#34;&gt;load_elf_binary&lt;/a&gt;负责加载二进制，并且根据可执行文件内容初始化各个区域。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/fs/exec.c#L1412&#34;&gt;setup_new_exec&lt;/a&gt;设置&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/mm_types.h#L388&#34;&gt;struct mm_struct&lt;/a&gt;的mm_base参数（mmap内存映射区域）,并且设置task_size的值。&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/fs/exec.c#L741&#34;&gt;setup_arg_pages&lt;/a&gt;设置栈的&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/mm_types.h#L305&#34;&gt;struct vm_area_struct&lt;/a&gt;结构，并设置参数列表起始位置arg_start的值，arg_start指向栈低start_stack的位置。&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/fs/binfmt_elf.c#L360&#34;&gt;elf_map&lt;/a&gt;将可执行文件中的代码段映射到内存空间。&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/fs/binfmt_elf.c#L110&#34;&gt;set_brk&lt;/a&gt;设置堆空间的&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/mm_types.h#L305&#34;&gt;struct vm_area_struct&lt;/a&gt;，并且初始化start_brk=brk（堆为空）。&lt;/li&gt;
&lt;li&gt;如果有动态库，则调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/fs/binfmt_elf.c#L588&#34;&gt;load_elf_interp&lt;/a&gt;映射到内存映射区域。&lt;/li&gt;
&lt;li&gt;给start_code, end_code, start_data, end_data赋值。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;进程的用户态布局就变成下面这样。

&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/memory-management-user-mode-memory-layout_1.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/memory-management-user-mode-memory-layout_1.png&#34; alt=&#34;&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;p&gt;内存区域映射完之后，存在一下情况区域会发生变化：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户调用malloc/free申请堆空间，小内存操作调用brk移动堆结束指针，大内存操作调用mmap。&lt;/li&gt;
&lt;li&gt;创建临时变量或函数调用导致栈指针移动时对应栈区域也会移动。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里简单看下堆内存操作brk的过程，mmap后边会讲解。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;入口在&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/mmap.c#L190&#34;&gt;SYSCALL_DEFINE1(brk, unsigned long, brk)&lt;/a&gt;。参数brk就是新堆顶的位置。&lt;/li&gt;
&lt;li&gt;将参数堆顶位置brk和进程旧堆顶位置brk关于页对齐，如果对齐后两者相同说明变化量很小可以在同一页里解决。将mm_struct的brk指向新的brk即可。&lt;/li&gt;
&lt;li&gt;如果两者对齐后不相同，说明操作跨页了，如果新brk小于旧的brk说明是释放内存，就调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/mmap.c#L2806&#34;&gt;__do_munmap&lt;/a&gt;将多余的页去掉映射。&lt;/li&gt;
&lt;li&gt;如果新brk大于旧brk说明是申请内存，就调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/mmap.c#L2300&#34;&gt;find_vma&lt;/a&gt;在红黑树中找到下一个&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/mm_types.h#L305&#34;&gt;struct vm_area_struct&lt;/a&gt;的位置，看中间是否还能分配一个完整的页，分配不了就报错。如果能就更新各参数分配。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;内核态&#34;&gt;内核态&lt;/h2&gt;
&lt;p&gt;内核态的虚拟地址空间和某个进程没关系，所有进程共享同一个内核态虚拟地址空间。并且此时讨论的还是虚拟地址空间。前面分析用户态和内核态分界的时候讲了32位内核态是1GB，64位内核态是128TB。因为空间的数量级就差很大，可想而知布局也会有一定差别，毕竟32位太小了。我们先来分析一下32位内核态的布局。

&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/memory-management-kernel-mode-memory-layout.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/memory-management-kernel-mode-memory-layout.png&#34; alt=&#34;&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;前896M为直接映射区，这部分地址连续，虚拟地址与物理地址映射关系较为简单，内核用了两个宏定义来转换地址&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/arch/x86/include/asm/page.h#L59&#34;&gt;#define __va(x)&lt;/a&gt;，&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/arch/x86/include/asm/page.h#L42&#34;&gt;#define __pa(x)&lt;/a&gt;实际转换规则就是虚拟地址-PAGE_OFFSET(前面讲过用户空和内核空间分界)得到物理地址，物理地址+PAGE_OFFSET得到虚拟地址。直接映射区前1M空间开机处于实模式时会使用，内核代码从1M开始加载，然后就是全局变量、BSS等，另外内存管理的页表以及进程的内核栈都会放在这个区域。&lt;/li&gt;
&lt;li&gt;接下来就是8M的空洞，用于捕捉内存越界。其他空洞也是这个原因。&lt;/li&gt;
&lt;li&gt;VMALLOC_START到VMALLOC_END成为动态映射空间，类似进程的堆，内核使用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/vmalloc.c#L2632&#34;&gt;vmalloc&lt;/a&gt;进行动态申请内存的区域。&lt;/li&gt;
&lt;li&gt;PKMAP_BASE到FIXADDR_START是持久映射空间，通常为4M，内核使用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/gfp.h#L555&#34;&gt;alloc_pages&lt;/a&gt;获得&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/mm_types.h#L68&#34;&gt;struct page&lt;/a&gt;结构，然后调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/highmem.h#L48&#34;&gt;kmap&lt;/a&gt;将其映射到这个区域。&lt;/li&gt;
&lt;li&gt;FIXADDR_START到FIXADDR_TOP为固定映射区域，留作特定用途。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;64位的内核态布局就较为简单了，毕竟128TB太大不需要扣内存。

&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/memory-management-kernel-mode-memory-layout-64.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/memory-management-kernel-mode-memory-layout-64.png&#34; alt=&#34;&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;内核空间从0xffff800000000000开始，之后有8T空洞。&lt;/li&gt;
&lt;li&gt;0xFFFF880000000000到0xFFFFC80000000000是直接映射区，同32位。&lt;/li&gt;
&lt;li&gt;0xFFFFC90000000000到0xFFFFE90000000000是动态映射区，同32位。&lt;/li&gt;
&lt;li&gt;然后就是存放物理页表，同32位持久映射区域。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;3-物理地址空间的管理&#34;&gt;3. 物理地址空间的管理&lt;/h1&gt;
&lt;p&gt;讲完了虚拟地址空间的管理，现在再来看一下Linux是如何管理物理内存的。&lt;/p&gt;
&lt;p&gt;传统的x86架构的工作模式中，多处理器与一个集中存储器相连时，所有CPU都要通过总线去访问内存。也就是对称多处理器模式&lt;a href=&#34;https://en.wikipedia.org/wiki/Symmetric_multiprocessing&#34;&gt;SMP（Symmetric multiprocessing）&lt;/a&gt;。

&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/memory-management-symmetric-multiprocessing.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/memory-management-symmetric-multiprocessing.png&#34; alt=&#34;&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;


由于所有的内存访问都要经过总线，所以总线会成为瓶颈。&lt;/p&gt;
&lt;p&gt;为了提高性能和扩展性，诞生了一种更高级的模式，非一致性内存访问&lt;a href=&#34;https://en.wikipedia.org/wiki/Non-uniform_memory_access&#34;&gt;NUMA（Non-uniform memory access）&lt;/a&gt;。这种模式下每个CPU有自己本地的内存，当本地内存不足时才会访问其他NUMA节点的内存。这样就提高了访问的效率。

&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/memory-management-physical-memory.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/memory-management-physical-memory.png&#34; alt=&#34;&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;p&gt;值得注意的一点就是Mysql对NUMA支持不友好，NUMA在默认在本地CPU上分配内存，会导致CPU节点之间内存分配不均衡，当某个CPU节点的内存不足会使用Swap而不是直接从远程节点分配内存。经常内存还有耗尽，Mysql就已经使用Swap照成抖动，这就是&amp;quot;Swap Insanity&amp;rdquo;。所以单机部署Mysql的时候最好将NUMA关掉。&lt;/p&gt;
&lt;h2 id=&#34;节点&#34;&gt;节点&lt;/h2&gt;
&lt;p&gt;接下来我们就看一下当前主流的模式NUMA，NUMA模式中内存分节点，每个CPU有本地内存，内核中用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/mmzone.h#L726&#34;&gt;typedef struct pglist_data pg_data_t&lt;/a&gt;表示节点。我们来看一下这个结构体重点的变量。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; pglist_data {
	&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; zone node_zones[MAX_NR_ZONES];
	&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; zonelist node_zonelists[MAX_ZONELISTS];
	&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; nr_zones; &lt;span style=&#34;color:#75715e&#34;&gt;/* number of populated zones in this node */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#ifdef CONFIG_FLAT_NODE_MEM_MAP	&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/* means !SPARSEMEM */&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; page &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;node_mem_map;
&lt;span style=&#34;color:#75715e&#34;&gt;#ifdef CONFIG_PAGE_EXTENSION
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	...
	&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; node_start_pfn;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; node_present_pages; &lt;span style=&#34;color:#75715e&#34;&gt;/* total number of physical pages */&lt;/span&gt;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; node_spanned_pages; &lt;span style=&#34;color:#75715e&#34;&gt;/* total size of physical page
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;					     range, including holes */&lt;/span&gt;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; node_id;
	...
} pg_data_t;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;节点ID，node_id。&lt;/li&gt;
&lt;li&gt;node_mem_map 就是这个节点的 struct page 数组，用于描述这个节点里面的所有的页。&lt;/li&gt;
&lt;li&gt;node_start_pfn 是这个节点的起始页号。&lt;/li&gt;
&lt;li&gt;node_spanned_pages 是这个节点中包含不连续的物理内存地址的页面数。&lt;/li&gt;
&lt;li&gt;node_present_pages 是真正可用的物理页面的数目。&lt;/li&gt;
&lt;li&gt;节点内再将页分成区，存放在node_zones数组中。大小是MAX_NR_ZONES。&lt;/li&gt;
&lt;li&gt;nr_zones表示节点的区域数量。&lt;/li&gt;
&lt;li&gt;node_zonelists是备用节点和它的内存区域的情况。当本地内存不足时会使用到。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;区域的类型如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;enum&lt;/span&gt; zone_type {
&lt;span style=&#34;color:#75715e&#34;&gt;#ifdef CONFIG_ZONE_DMA
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	ZONE_DMA,
&lt;span style=&#34;color:#75715e&#34;&gt;#endif
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#ifdef CONFIG_ZONE_DMA32
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	ZONE_DMA32,
&lt;span style=&#34;color:#75715e&#34;&gt;#endif
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	ZONE_NORMAL,
&lt;span style=&#34;color:#75715e&#34;&gt;#ifdef CONFIG_HIGHMEM
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	ZONE_HIGHMEM,
&lt;span style=&#34;color:#75715e&#34;&gt;#endif
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	ZONE_MOVABLE,
&lt;span style=&#34;color:#75715e&#34;&gt;#ifdef CONFIG_ZONE_DEVICE
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	ZONE_DEVICE,
&lt;span style=&#34;color:#75715e&#34;&gt;#endif
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	__MAX_NR_ZONES
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;ZONE_DMA直接内存读取区域，DMA是一种机制，要把外设的数据读入内存或把内存的数据传送到外设，原来都要通过 CPU 控制完成，但是这会占用 CPU，影响 CPU 处理其他事情，所以有了 DMA 模式。CPU 只需向 DMA 控制器下达指令，让 DMA 控制器来处理数据的传送，数据传送完毕再把信息反馈给 CPU，这样就可以解放 CPU。对于64位系统有两个DMA区域ZONE_DMA、ZONE_DMA32，后者只能被32位设备访问。&lt;/li&gt;
&lt;li&gt;ZONE_NORMAL直接映射区，内核虚拟地址空间讲过，就是地址加上一个常量与虚拟地址空间映射。&lt;/li&gt;
&lt;li&gt;ZONE_HIGHMEM高端内存区，64位系统是不需要的。&lt;/li&gt;
&lt;li&gt;ZONE_MOVABLE可移动区，通过将内存划分为可移动区和不可移动区来避免碎片。&lt;/li&gt;
&lt;li&gt;ZONE_DEVICE为支持热插拔设备而分配的Non Volatile Memory非易失性内存&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;区&#34;&gt;区&lt;/h2&gt;
&lt;p&gt;内核将内存分区的目的是形成不同内存池，从而根据用途进行分配。内核使用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/mmzone.h#L448&#34;&gt;struct zone&lt;/a&gt;表示区。区就是本节点一个个页集合了。我们再来看一下这个结构体。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; zone {
	...
	&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; pglist_data	&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;zone_pgdat;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; per_cpu_pageset __percpu &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;pageset;
	...
	&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt;		zone_start_pfn;
	atomic_long_t		managed_pages;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt;		spanned_pages;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt;		present_pages;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;		&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;name;
	...
	&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; free_area	free_area[MAX_ORDER];
	&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt;		flags;
	spinlock_t		lock;
	...
} ____cacheline_internodealigned_in_smp;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;zone_start_pfn表示这个区中第一页。&lt;/li&gt;
&lt;li&gt;spanned_pages表示和节点中的node_spanned_pages变量类似，都是不连续物理页数，就是终止页减去起始页(中间可能有空洞，但是不管)。&lt;/li&gt;
&lt;li&gt;present_pages实际物理页数量。&lt;/li&gt;
&lt;li&gt;managed_pages被伙伴系统管理的所有的 page 数目。&lt;/li&gt;
&lt;li&gt;pageset用于区分冷热页，前面将分段机制时说过80386架构CS、DS等段寄存器由单纯表示段地址升级为段选择子和段描述符缓存器。就是说有些经常被访问的页会被缓存在寄存器中，被缓存的就是热页，这个变量就是用于区分冷热页。&lt;/li&gt;
&lt;li&gt;free_area空闲页。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;页&#34;&gt;页&lt;/h2&gt;
&lt;p&gt;然后就到了最基本的内存单元——页，内核使用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/mm_types.h#L68&#34;&gt;struct page&lt;/a&gt;表示物理页。结构体中有很多union，用于不同模式时的表示。主要有两种模式，1. 整页分配使用伙伴系统、2. 小内存分配使用slab allocator技术。&lt;/p&gt;
&lt;h2 id=&#34;页的分配&#34;&gt;页的分配&lt;/h2&gt;
&lt;p&gt;页的分配有两种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;按页分配&lt;/li&gt;
&lt;li&gt;Slab分配（通常分配大小小于一页）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;按页分配&#34;&gt;按页分配&lt;/h3&gt;
&lt;p&gt;使用伙伴系统分配，&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/mmzone.h#L448&#34;&gt;struct zone&lt;/a&gt;中的free_area数组每个元素都是一个链表首地址，每条链表有1、2、4、8、16、32、64、128、256、512 和 1024 个连续页。也就是说最多可以分配4MB的连续内存，每个页块的地址物理页地址是页块大小的整数倍。

&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/memory-management-free-area.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/memory-management-free-area.png&#34; alt=&#34;&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;


分配使用函数&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/gfp.h#L545&#34;&gt;alloc_pages&lt;/a&gt;，该函数返回连续物理页的第一页的&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/mm_types.h#L68&#34;&gt;struct page&lt;/a&gt;的地址。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/gfp.h#L545&#34;&gt;alloc_pages&lt;/a&gt;调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/mempolicy.c#L2256&#34;&gt;alloc_pages_current&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/mempolicy.c#L2256&#34;&gt;alloc_pages_current&lt;/a&gt;中根据参数gfp判断分配什么类型的页，GFP_USER用户空间页，GFP_KERNEL内核空间页，GFP_HIGHMEM高端内存页。参数order表示分配$2^{order}$个页。之后调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/page_alloc.c#L4917&#34;&gt;__alloc_pages_nodemask&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/page_alloc.c#L4917&#34;&gt;__alloc_pages_nodemask&lt;/a&gt;是伙伴系统的核心方法，大概逻辑就是先看当前区空闲页是否足够，不够就看备用区，遍历每个区时，比如要分配128个页，就会从128个页的块往上找，例如128没有，256有，就将256分割称128和128，一个用于分配，另一个放入128页为一块的链表中。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;释放页使用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/page_alloc.c#L5020&#34;&gt;free_pages&lt;/a&gt;，参数addr和order分别为page地址和要是释放的页数，释放页数为$2^{order}$。&lt;/p&gt;
&lt;h3 id=&#34;slab分配&#34;&gt;Slab分配&lt;/h3&gt;
&lt;p&gt;内核以及用户空间几乎很少用到按页分配的情况，普遍使用都是像malloc那样小段内存申请，并且操作十分频繁。这种频繁的操作通常会使用空闲链表，空闲链表缓存被释放的结构，下次分配是直接从链表抓取而不是申请。&lt;/p&gt;
&lt;p&gt;内核中，空闲链表面临的主要问题是不能全局控制，当可用内存紧缺时，内核无法通知每个空闲链表收缩从而释放一些内存。事实上内核根本不知道存在哪些空闲链表。为了弥补这一缺陷，Linux内核提供了Slab层。Slab分配器来充当通用数据结构缓存层的角色，以感知所有缓存链表状态。&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/memory-management-slab-allocator.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/memory-management-slab-allocator.png&#34; alt=&#34;&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;p&gt;Slab分配模式中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个结构体对应一个高速缓存，由&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/slab.h#L147&#34;&gt;kmem_cache_create&lt;/a&gt;函数创建，由&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/slab.h#L155&#34;&gt;kmem_cache_destroy&lt;/a&gt;函数销毁。例如进程线程的结构体&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/sched.h#L640&#34;&gt;struct task_struct&lt;/a&gt;对应高速缓存为&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/kernel/fork.c#L166&#34;&gt;task_struct_cachep&lt;/a&gt;，进程虚拟内存管理结构体&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/mm_types.h#L388&#34;&gt;struct mm_struct&lt;/a&gt;对应高速缓存为&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/kernel/fork.c#L342&#34;&gt;mm_cachep&lt;/a&gt;，每个高速缓存都使用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/slub_def.h#L83&#34;&gt;struct kmem_cache&lt;/a&gt;表示。这里的&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/slub_def.h#L83&#34;&gt;struct kmem_cache&lt;/a&gt;是&lt;code&gt;include/linux/slub_def.h&lt;/code&gt;下的，高速缓存中有多个slab。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;内核最开始只有slab，后来开发者对slab逐渐完善，就出现了slob和slub。slob针对嵌入式等内存有限的机器，slub针对large NUMA系统的大型机。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;每个slab里面存放了若干个连续物理页用于分配，物理页按照结构体大小分割。工程师通过&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/slab.h#L390&#34;&gt;kmem_cache_alloc&lt;/a&gt;申请结构体，通过&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/slab.h#L391&#34;&gt;kmem_cache_free&lt;/a&gt;释放结构体(放回)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;先分析一下高速缓存&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/slub_def.h#L83&#34;&gt;struct kmem_cache&lt;/a&gt;。

&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/memory-management-kmem-cache.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/memory-management-kmem-cache.png&#34; alt=&#34;&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;cpu_slab 是每个CPU本地缓存。
&lt;ul&gt;
&lt;li&gt;void **freelist 空闲对象链表&lt;/li&gt;
&lt;li&gt;struct page *page 所有连续的物理页&lt;/li&gt;
&lt;li&gt;struct page *partial 部分分配的物理页，这是备用的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;list 是高速缓存所在链表。&lt;/li&gt;
&lt;li&gt;node[MAX_NUMNODES] 是该高速缓存所有的slab的数组，每个slab都有一个状态(1.满的，2.空的，3.半满)，本地缓存不够时根据这个状态去找其他的slab。另外还用链表维护着这三个状态的slab。
&lt;ul&gt;
&lt;li&gt;struct list_head slabs_partial 存放半满的slab&lt;/li&gt;
&lt;li&gt;struct list_head slabs_full 存放已满的slab&lt;/li&gt;
&lt;li&gt;struct list_head slabs_free 存放空的slab&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面我们根据调用系统调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/fs/exec.c#L2054&#34;&gt;execve&lt;/a&gt;加载二进制文件的例子来看一下NUMA环境中Slab分配内存的完整过程。既然要加载二进制文件，那么进程结构体&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/sched.h#L640&#34;&gt;struct task_struct&lt;/a&gt;中内存管理变量&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/mm_types.h#L388&#34;&gt;struct mm_struct&lt;/a&gt;当然要申请了。&lt;/p&gt;
&lt;p&gt;调用链为&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/fs/exec.c#L2054&#34;&gt;execve&lt;/a&gt;-&amp;gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/fs/exec.c#L1977&#34;&gt;do_execve&lt;/a&gt; -&amp;gt; &lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/fs/exec.c#L1855&#34;&gt;do_execveat_common&lt;/a&gt; -&amp;gt; &lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/fs/exec.c#L1484&#34;&gt;alloc_bprm&lt;/a&gt; -&amp;gt; &lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/fs/exec.c#L363&#34;&gt;bprm_mm_init&lt;/a&gt; -&amp;gt; &lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/kernel/fork.c#L1059&#34;&gt;mm_alloc&lt;/a&gt; -&amp;gt; &lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/kernel/fork.c#L669&#34;&gt;allocate_mm&lt;/a&gt; -&amp;gt; &lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/slab.h#L390&#34;&gt;kmem_cache_alloc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;到这里可以看到高速缓存申请的接口&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/slab.h#L390&#34;&gt;kmem_cache_alloc&lt;/a&gt;，其中参数&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/slub_def.h#L83&#34;&gt;struct kmem_cache&lt;/a&gt;是&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/mm_types.h#L388&#34;&gt;struct mm_struct&lt;/a&gt;对应的高速缓存。再看一下这个函数做了哪些事情：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/slub.c#L2896&#34;&gt;slab_alloc&lt;/a&gt;，紧接着调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/slub.c#L2807&#34;&gt;slab_alloc_node&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/slub.c#L2807&#34;&gt;slab_alloc_node&lt;/a&gt;中首先在CPU本地缓存cpu_slab中分配，这就是注释中说的快速通道，分配到了直接返回，否则就调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/slub.c#L2660&#34;&gt;__slab_alloc&lt;/a&gt;去其他slab中分配，这就是普通通道。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/slub.c#L2660&#34;&gt;__slab_alloc&lt;/a&gt;中首先再尝试从本地缓存cpu_slab中分配，没有的话就跳到&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/slub.c#L2732&#34;&gt;new_slab&lt;/a&gt;先考虑从本地缓存cpu_slab备用物理页partial中分配，再没有的话就调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/slub.c#L2564&#34;&gt;new_slab_objects&lt;/a&gt;去其他slab中分配了。如果在没有就只能在申请物理页了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;到现在已经说完slab分配对象的逻辑了，但是还有一个问题，就是空闲缓存的回收，由于有了slab层内核已经可以感知所有空闲链表的状态了，所以回收问题是可以解决的。初始化时内核就会注册回收任务，每隔两秒进行一次检查，检查是否需要收缩空闲链表。调用链是&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/slab.c#L1311&#34;&gt;cpucache_init&lt;/a&gt; -&amp;gt; &lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/slab.c#L1077&#34;&gt;slab_online_cpu&lt;/a&gt; -&amp;gt; &lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/slab.c#L510&#34;&gt;start_cpu_timer&lt;/a&gt; 将&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/slab.c#L3951&#34;&gt;cache_reap&lt;/a&gt;注册为定时回调函数。&lt;/p&gt;
&lt;h2 id=&#34;页换出&#34;&gt;页换出&lt;/h2&gt;
&lt;p&gt;不管32位还是64位操作系统，不一定非得按照操作系统要求装内存条，例如32位最大4G虚拟地址空间，但是用户就买了2G怎么办？超过2G的虚拟地址空间不用了吗？不会的，现在几乎所有操作系统都是支持SWAP，就是将不活跃的物理页暂时缓存到磁盘上。&lt;/p&gt;
&lt;p&gt;一般页换出有两种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主动（当申请内存时，内存紧张就考虑将部分页缓存到磁盘）&lt;/li&gt;
&lt;li&gt;被动（Linux 内核线程&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/vmscan.c#L3862&#34;&gt;kswapd&lt;/a&gt;定时检查是否需要换出部分页）
&lt;ul&gt;
&lt;li&gt;调用链为&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/vmscan.c#L3542&#34;&gt;balance_pgdat&lt;/a&gt; -&amp;gt; &lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/vmscan.c#L3494&#34;&gt;kswapd_shrink_node&lt;/a&gt; -&amp;gt; &lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/vmscan.c#L2667&#34;&gt;shrink_node&lt;/a&gt; -&amp;gt; &lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/vmscan.c#L2610&#34;&gt;shrink_node_memcgs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/vmscan.c#L2610&#34;&gt;shrink_node_memcgs&lt;/a&gt;就是处理页换出的函数了，里面有个LRU表，根据最近最少未使用的原则换出。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;4-内存映射&#34;&gt;4. 内存映射&lt;/h1&gt;
&lt;p&gt;上边讲完了虚拟地址空间和物理地址空间是如何管理的，还剩下最后一个问题，这俩是怎么映射的？其实虚拟地址不止可以和物理内存映射，还可以和文件等映射。物理内存只是一种特殊的情况。&lt;/p&gt;
&lt;h2 id=&#34;用户态映射&#34;&gt;用户态映射&lt;/h2&gt;
&lt;p&gt;首先来看一下用户态映射方式。

&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/memory-management-user-mode-memory-mapping.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/memory-management-user-mode-memory-mapping.png&#34; alt=&#34;&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;


前边说堆的时候，malloc函数只讲了小内存brk的方式，当申请内存较大时会使用mmap（不是系统调用那个），对于堆来说就是将虚拟地址映射到物理地址。另外如果想将文件映射到内存也可以调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/arch/x86/kernel/sys_x86_64.c#L89&#34;&gt;mmap&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我们先来分析一下&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/arch/x86/kernel/sys_x86_64.c#L89&#34;&gt;mmap&lt;/a&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/mmap.c#L1591&#34;&gt;ksys_mmap_pgoff&lt;/a&gt;参数有fd，通过fd找到对应&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/fs.h#L916&#34;&gt;struct file&lt;/a&gt;。接下来调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/util.c#L494&#34;&gt;vm_mmap_pgoff&lt;/a&gt; -&amp;gt; &lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/mmap.c#L1404&#34;&gt;do_mmap&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/mmap.c#L1404&#34;&gt;do_mmap&lt;/a&gt;中：
&lt;ol&gt;
&lt;li&gt;首先调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/mmap.c#L2256&#34;&gt;get_unmapped_area&lt;/a&gt;在进程地址空间里找到一个没映射的区域(那棵红黑树)。&lt;/li&gt;
&lt;li&gt;然后调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/mmap.c#L1726&#34;&gt;mmap_region&lt;/a&gt;将文件映射到这个区域，并且调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/fs.h#L1906&#34;&gt;call_mmap&lt;/a&gt;执行file-&amp;gt;f_op-&amp;gt;mmap接口把这个区域的&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/mm_types.h#L305&#34;&gt;struct vm_area_struct&lt;/a&gt;结构的内存操作接口换成那个文件的操作函数，也就是说对这段虚拟内存读写，就相当于执行该文件的读写函数。如果是ext4文件系统对应的mmap接口就是&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/fs/ext4/file.c#L748&#34;&gt;ext4_file_mmap&lt;/a&gt;。&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/fs/ext4/file.c#L748&#34;&gt;ext4_file_mmap&lt;/a&gt;中执行内存操作替换为文件操作vma-&amp;gt;vm_ops = &amp;amp;ext4_file_vm_ops;&lt;/li&gt;
&lt;li&gt;然后将&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/mm_types.h#L305&#34;&gt;struct vm_area_struct&lt;/a&gt;挂到进程的&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/mm_types.h#L388&#34;&gt;struct mm_struct&lt;/a&gt;上。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;现在文件已经和虚拟内存地址有映射了。还没有与物理内存产生关系，而物理内存的映射是用到的时候才映射。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;缺页&#34;&gt;缺页&lt;/h3&gt;
&lt;p&gt;访问某个虚拟地址时，如果没有对应的物理页就会触发缺页中断&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/arch/x86/mm/fault.c#L1416&#34;&gt;handle_page_fault&lt;/a&gt;这里会判断是内核态缺页还是用户态缺页，我们先来看用户态的，会调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/arch/x86/mm/fault.c#L1213&#34;&gt;do_user_addr_fault&lt;/a&gt;。这个函数中：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;找到缺页区域对应的&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/mm_types.h#L305&#34;&gt;struct vm_area_struct&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;然后调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/memory.c#L4579&#34;&gt;handle_mm_fault&lt;/a&gt;-&amp;gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/memory.c#L4423&#34;&gt;__handle_mm_fault&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/memory.c#L4423&#34;&gt;__handle_mm_fault&lt;/a&gt;中首先会创建前面一直提的页表，然后调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/memory.c#L4330&#34;&gt;handle_pte_fault&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/memory.c#L4330&#34;&gt;handle_pte_fault&lt;/a&gt;中有三种情况：
&lt;ol&gt;
&lt;li&gt;PTE表为空，说明是缺页(新的)
&lt;ul&gt;
&lt;li&gt;如果映射到物理内存就调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/memory.c#L3469&#34;&gt;do_anonymous_page&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;如果映射到文件就调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/memory.c#L4098&#34;&gt;do_fault&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PTE表不为空，说明页表创建过了，是被换出到磁盘的就调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/memory.c#L3241&#34;&gt;do_swap_page&lt;/a&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一个个分析，首先看映射到物理页的函数&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/memory.c#L3469&#34;&gt;do_anonymous_page&lt;/a&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/mm.h#L2231&#34;&gt;pte_alloc&lt;/a&gt;分配一个页表。&lt;/li&gt;
&lt;li&gt;页表有了，就要申请一个物理页放到页表项里了，调用链是&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/highmem.h#L274&#34;&gt;alloc_zeroed_user_highpage_movable&lt;/a&gt; -&amp;gt; &lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/highmem.h#L251&#34;&gt;__alloc_zeroed_user_highpage&lt;/a&gt; -&amp;gt; &lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/gfp.h#L565&#34;&gt;alloc_page_vma&lt;/a&gt; -&amp;gt; &lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/mempolicy.c#L2173&#34;&gt;alloc_pages_vma&lt;/a&gt; -&amp;gt; &lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/page_alloc.c#L4917&#34;&gt;__alloc_pages_nodemask&lt;/a&gt;。又看到熟悉的函数了&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/page_alloc.c#L4917&#34;&gt;__alloc_pages_nodemask&lt;/a&gt;就是前边说过的伙伴系统核心函数。&lt;/li&gt;
&lt;li&gt;调用mk_pte创建一个页表项并把物理页放进去，最后调用set_pte_at将页表项放入页表。至此页表里面有对应物理页了，虚拟地址就有映射了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;再来看下映射到文件的函数&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/memory.c#L4098&#34;&gt;do_fault&lt;/a&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/memory.c#L4098&#34;&gt;do_fault&lt;/a&gt;也有几种不同情况但最终都会调到&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/memory.c#L3585&#34;&gt;__do_fault&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/memory.c#L3585&#34;&gt;__do_fault&lt;/a&gt;中会调用vma-&amp;gt;vm_ops-&amp;gt;fault接口，之前文件映射是说过在缺页之前已经将内存操作接口换成文件操作接口了，所以如果是ext4文件系统，这里的vm_ops就应该是ext4_file_vm_ops，也就是调用了&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/fs/ext4/inode.c#L6186&#34;&gt;ext4_filemap_fault&lt;/a&gt;。紧接着调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/filemap.c#L2709&#34;&gt;filemap_fault&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/filemap.c#L2709&#34;&gt;filemap_fault&lt;/a&gt;首先调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/pagemap.h#L332&#34;&gt;find_get_page&lt;/a&gt;查找一下物理内存里事先有没有缓存好的，如果找到了就调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/filemap.c#L2662&#34;&gt;do_async_mmap_readahead&lt;/a&gt;从文件中预读一些数据到内存。没有的话就调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/filemap.c#L1787&#34;&gt;pagecache_get_page&lt;/a&gt;分配一个物理页并且把物理页加到LRU表里，然后调用struct address_space *mapping-&amp;gt;a_ops-&amp;gt;readpage接口将文件内容缓存到物理页中。ext4文件系统readpage接口对应&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/fs/ext4/inode.c#L3228&#34;&gt;ext4_readpage&lt;/a&gt;，这个函数又调用到&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/fs/ext4/inline.c#L498&#34;&gt;ext4_readpage_inline&lt;/a&gt; -&amp;gt; &lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/fs/ext4/inline.c#L464&#34;&gt;ext4_read_inline_page&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/fs/ext4/inline.c#L464&#34;&gt;ext4_read_inline_page&lt;/a&gt;中首先调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/linux/highmem.h#L92&#34;&gt;kmap_atomic&lt;/a&gt;映射到内核的虚拟地址空间得到虚拟地址kaddr，本来的目的是将物理内存映射到用户虚拟地址空间，但是从文件读取内容缓存到物理内存又不能用物理地址(除了内存管理模块其他操作都得是虚拟地址)，所以这里kaddr只是临时虚拟地址，读取完再把kaddr取消就行。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后一种是交换空间类型的，函数&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/memory.c#L3241&#34;&gt;do_swap_page&lt;/a&gt;，swap类型的和映射到文件的差不多，都是需要从把磁盘文件映射到内存。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/swap_state.c#L369&#34;&gt;lookup_swap_cache&lt;/a&gt;查看swap文件在内存有没有缓存页，有就直接用，没有就调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/swap_state.c#L891&#34;&gt;swapin_readahead&lt;/a&gt;将swap文件读到内存页中缓存，再调用mk_pte创建页表项，调用set_pte_at将页表项放入页表。&lt;/li&gt;
&lt;li&gt;读swap文件过程和上一步映射到文件的差不多。&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/swapfile.c#L1357&#34;&gt;swap_free&lt;/a&gt;释放掉swap文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;处理完缺页之后，物理页有内容、进程空间有页表，接下来就可以通过虚拟地址找到物理地址了。&lt;/p&gt;
&lt;p&gt;为了加快映射速度，我们引进了&lt;a href=&#34;https://en.wikipedia.org/wiki/Translation_lookaside_buffer&#34;&gt;TLB&lt;/a&gt;专门来做地址映射的硬件，缓存了部分页表。查询时先查快表TLB查到了直接用物理内存，查不到再到内存访问页表。&lt;/p&gt;
&lt;h2 id=&#34;内核态映射&#34;&gt;内核态映射&lt;/h2&gt;
&lt;p&gt;首先内核页表和用户态页表不同，内核页表在初始化时就创建了。内核&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/mm/init-mm.c#L31&#34;&gt;初始化时&lt;/a&gt;将swapper_pg_dir赋值给顶级目录pgd。&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/arch/x86/include/asm/pgtable_64.h#L29&#34;&gt;swapper_pg_dir&lt;/a&gt;指向顶级目录init_top_pgt。&lt;/p&gt;
&lt;p&gt;系统初始化函数&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/arch/x86/kernel/setup.c#L771&#34;&gt;setup_arch&lt;/a&gt;调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/arch/x86/include/asm/processor.h#L255&#34;&gt;load_cr3(swapper_pg_dir)&lt;/a&gt;刷新TLB说明页表已经构建完了。&lt;/p&gt;
&lt;p&gt;实际初始化在&lt;a href=&#34;https://github.com/torvalds/linux/blob/v5.10/arch/x86/kernel/head_64.S&#34;&gt;arch/x86/kernel/head_64.S&lt;/a&gt;中。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#if defined(CONFIG_XEN_PV) || defined(CONFIG_PVH)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;SYM_DATA_START_PTI_ALIGNED(init_top_pgt)
	.quad   level3_ident_pgt &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; __START_KERNEL_map &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; _KERNPG_TABLE_NOENC
	.org    init_top_pgt &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; L4_PAGE_OFFSET&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
	.quad   level3_ident_pgt &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; __START_KERNEL_map &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; _KERNPG_TABLE_NOENC
	.org    init_top_pgt &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; L4_START_KERNEL&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
	&lt;span style=&#34;color:#75715e&#34;&gt;/* (2^48-(2*1024*1024*1024))/(2^39) = 511 */&lt;/span&gt;
	.quad   level3_kernel_pgt &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; __START_KERNEL_map &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; _PAGE_TABLE_NOENC
	.fill	PTI_USER_PGD_FILL,&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
SYM_DATA_END(init_top_pgt)

SYM_DATA_START_PAGE_ALIGNED(level3_ident_pgt)
	.quad	level2_ident_pgt &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; __START_KERNEL_map &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; _KERNPG_TABLE_NOENC
	.fill	&lt;span style=&#34;color:#ae81ff&#34;&gt;511&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
SYM_DATA_END(level3_ident_pgt)
SYM_DATA_START_PAGE_ALIGNED(level2_ident_pgt)
	&lt;span style=&#34;color:#75715e&#34;&gt;/*
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;	 * Since I easily can, map the first 1G.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;	 * Don&amp;#39;t set NX because code runs from these pages.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;	 *
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;	 * Note: This sets _PAGE_GLOBAL despite whether
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;	 * the CPU supports it or it is enabled.  But,
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;	 * the CPU should ignore the bit.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;	 */&lt;/span&gt;
	PMDS(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, __PAGE_KERNEL_IDENT_LARGE_EXEC, PTRS_PER_PMD)
SYM_DATA_END(level2_ident_pgt)
&lt;span style=&#34;color:#75715e&#34;&gt;#else
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;SYM_DATA_START_PTI_ALIGNED(init_top_pgt)
	.fill	&lt;span style=&#34;color:#ae81ff&#34;&gt;512&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
	.fill	PTI_USER_PGD_FILL,&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
SYM_DATA_END(init_top_pgt)
&lt;span style=&#34;color:#75715e&#34;&gt;#endif
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;缺页-1&#34;&gt;缺页&lt;/h3&gt;
&lt;p&gt;内核空间缺页同样会调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/arch/x86/mm/fault.c#L1416&#34;&gt;handle_page_fault&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&#34;5-总结&#34;&gt;5. 总结&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Linux虚拟地址空间采用分页机制，多级页表来减小页表占用空间。其原因就是越往后的页表项没用到的可以不用建。&lt;/li&gt;
&lt;li&gt;物理地址管理:
&lt;ol&gt;
&lt;li&gt;内核管理单元管理。主流采用NUMA模型，每个CPU有本地内存(节点)，本地内存根据用途再分区，每个区里就是物理页集合。&lt;/li&gt;
&lt;li&gt;物理页申请时:
&lt;ol&gt;
&lt;li&gt;大内存按页分配通过伙伴系统&lt;/li&gt;
&lt;li&gt;小内存通过slab分配器。那个结构体对应一个高速缓存，结构体申请释放都通过高速缓存，高速缓存里有很多slab，每个CPU又一个本地slab。slab里面就是很多待分配的结构体了。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;物理内存紧张时会换出部分页面到磁盘上，也就是swap文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;地址映射
&lt;ol&gt;
&lt;li&gt;虚拟地址映射到物理地址&lt;/li&gt;
&lt;li&gt;虚拟地址映射到文件&lt;/li&gt;
&lt;li&gt;用到虚拟地址是会检查是否有对应物理地址没有的话，就缺页。
&lt;ol&gt;
&lt;li&gt;虚拟地址映射到物理地址的缺页——分配物理页。&lt;/li&gt;
&lt;li&gt;虚拟地址映射到文件的缺页——分配物理页，加载部分数据到物理页。&lt;/li&gt;
&lt;li&gt;物理地址映射到磁盘swap文件——分配物理页，将swap文件加载进来。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://book.douban.com/subject/6097773/&#34;&gt;Linux内核设计与实现第三版&lt;/a&gt; &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
  </item>
  
  <item>
    <title>backlog参数指的是什么？</title>
    <link>https://journey-c.github.io/what-is-the-backlog/</link>
    <pubDate>Sun, 31 Jan 2021 03:35:33 +0800</pubDate>
    
    <guid>https://journey-c.github.io/what-is-the-backlog/</guid>
    <description>&lt;h1 id=&#34;背景介绍&#34;&gt;背景介绍&lt;/h1&gt;
&lt;p&gt;服务端编程中涉及网络交互的服务几乎都会监听一个端口，然后等待客户端的请求，然后交互。在Linux中监听的&lt;a href=&#34;https://journey-c.github.io/what-is-system-call&#34;&gt;系统调用&lt;/a&gt;是listen。glibc的接口如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;listen&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; sockfd, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; backlog);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中参数sockfd为已经bind过端口和地址的fd，而backlog就是本文介绍的对象。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.freebsd.org/cgi/man.cgi?query=listen&amp;amp;apropos=0&amp;amp;sektion=0&amp;amp;manpath=FreeBSD+12.2-RELEASE+and+Ports&amp;amp;arch=default&amp;amp;format=html&#34;&gt;BSD手册中&lt;/a&gt;给它的定义是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;the maximum length the queue of pending connections may grow to.（由未处理连接构成的队列可能增长的最大长度）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这句话并没有解释backlog到底是处于SYN_RCVD状态的连接数还是处于ESTABLISHED状态的连接数。或者是处于两者皆可。&lt;/p&gt;
&lt;h1 id=&#34;linux中的backlog是如何实现&#34;&gt;Linux中的backlog是如何实现&lt;/h1&gt;
&lt;p&gt;下面我们从Linux实现来一步步揭开backlog的真面目。&lt;/p&gt;
&lt;p&gt;首先listen涉及与网卡的交互，这种涉及与硬件交互的操作Linux都是通过系统调用来实现的，既然是系统调用那么目标就明确了，从listen的系统调用入口开始看。&lt;/p&gt;
&lt;p&gt;listen函数的入口是&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/net/socket.c#L1697&#34;&gt;SYSCALL_DEFINE2(listen, int, fd, int, backlog)&lt;/a&gt;参数正如glibc的listen接口，第一个参数是listen用的socket，第二个参数是backlog。这个函数没有做任何事情只是调用了&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/net/socket.c#L1676&#34;&gt;__sys_listen&lt;/a&gt;，&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/net/socket.c#L1676&#34;&gt;__sys_listen&lt;/a&gt;就是具体的listen实现了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先根据传入的fd调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/net/socket.c#L494&#34;&gt;sockfd_lookup_light&lt;/a&gt;找到对应的socket对象。&lt;/li&gt;
&lt;li&gt;将backlog和Linux配置中的&lt;code&gt;somaxconn(/proc/sys/net/core/somaxconn，默认128)&lt;/code&gt;比较，如果比somaxconn大，就用somaxconn替换。&lt;/li&gt;
&lt;li&gt;调用struct socket结构里面ops的listen函数，拿TCP来说，创建socket时type=SOCK_STREAM，protocol=IPPROTO_TCP的ops是&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/net/ipv4/af_inet.c#L1018&#34;&gt;inet_stream_ops&lt;/a&gt;，对应的listen函数是&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/net/ipv4/af_inet.c#L196&#34;&gt;inet_listen&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/net/ipv4/af_inet.c#L196&#34;&gt;inet_listen&lt;/a&gt;中判断一下socket状态还不是LISTEN的话，会调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/net/ipv4/inet_connection_sock.c#L911&#34;&gt;inet_csk_listen_start&lt;/a&gt;进入监听状态。另外还会将backlog值赋给socket的sk_max_ack_backlog参数，后边虽然调用一直带着backlog参数，实际没用了，socket中已经有了。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/net/ipv4/inet_connection_sock.c#L911&#34;&gt;inet_csk_listen_start&lt;/a&gt;中会创建一个新结构&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/net/inet_connection_sock.h#L80&#34;&gt;struct inet_connection_sock&lt;/a&gt;。这个结构体是维护连接状态的，里面包含了各种状态队列和超时以及拥塞控制的变量，其中我们关心的是icsk_accept_queue队列。内核会为每个socket维护两个队列，一个是三次握手完成处于ESTABLISHED状态的连接队列，另一个是三次握手进行中处于SYN_RCVD状态的连接队列，icsk_accept_queue就是前者。而用户调用accept实际是从icsk_accept_queue队列取出连接。&lt;/li&gt;
&lt;li&gt;初始化完之后，将 TCP 的状态设置为 TCP_LISTEN，再次调用 get_port 判断端口是否冲突。listen的逻辑就结束了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上面已经介绍完listen的整个逻辑了，与咱们讨论的backlog有关的就是icsk_accept_queue队列。&lt;/p&gt;
&lt;p&gt;当内核收到网卡收到数据而触发的硬中断之后，并且数据传递到四层时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果是ipv4的tcp包会调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/net/ipv4/tcp_ipv4.c#L1915&#34;&gt;tcp_v4_rcv&lt;/a&gt;，处理完tcp头以及其他一些信息之后就调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/net/ipv4/tcp_ipv4.c#L1655&#34;&gt;tcp_v4_do_rcv&lt;/a&gt;，这个函数中分两种情况：处于ESTABLISHED状态的socket和未处于ESTABLISHED状态的socket。&lt;/li&gt;
&lt;li&gt;我们关心的是未处于ESTABLISHED状态的socket，会调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/net/ipv4/tcp_input.c#L6303&#34;&gt;tcp_rcv_state_process&lt;/a&gt;，这个函数中，当socket状态是LISTEN时（因为客户端的连接包是发给listen fd的），会调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/net/inet_connection_sock.h#L80&#34;&gt;struct inet_connection_sock&lt;/a&gt;(listen系统调用时创建的)icsk_af_ops对象的conn_request接口，对应&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/net/ipv4/tcp_input.c#L6743&#34;&gt;tcp_conn_request&lt;/a&gt;函数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/net/ipv4/tcp_input.c#L6743&#34;&gt;tcp_conn_request&lt;/a&gt;会调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/2c85ebc57b3e1817b6ce1a6b703928e113a90442/include/net/inet_connection_sock.h#L279&#34;&gt;inet_csk_reqsk_queue_is_full&lt;/a&gt;函数判断当前icsk_accept_queue长度是否超过sk_max_ack_backlog，如果超过就给客户端发一个RST包，客户端就当SYN包丢了，然后一直重试，第一次6s超时，然后24s，直到75s还没收到SYNACK就返回用户连接超时。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/backlog.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/backlog.png&#34; alt=&#34;&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;p&gt;到目前为止得出结论，backlog是指&lt;strong&gt;用户&lt;/strong&gt;未处理的连接数量，例如backlog为1，有三个客户端在同时连接，第一个连接可以正常三次握手，第二个连接SYN包到来时内核只会回一个RST包，客户端就当SYN包丢了不停重试，当用户调用accept获取了第一个连接之后，第二个内核才会给第二个连接回复SYNACK继续握手。&lt;/p&gt;
&lt;p&gt;当然icsk_accept_queue最大长度不是绝对为backlog，而是backlog*模糊因子，下面是不同操作系统的backlog的设置。

&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/backlog_1.jpeg&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/backlog_1.jpeg&#34; alt=&#34;&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;


图片转自《UNIX网络编程卷一》&lt;/p&gt;
</description>
  </item>
  
  <item>
    <title>Linux的I/O多路复用机制</title>
    <link>https://journey-c.github.io/io-multiplexing/</link>
    <pubDate>Sun, 20 Dec 2020 21:58:31 +0800</pubDate>
    
    <guid>https://journey-c.github.io/io-multiplexing/</guid>
    <description>&lt;h1 id=&#34;1-文件系统简介&#34;&gt;1. 文件系统简介&lt;/h1&gt;
&lt;p&gt;Linux平台万物皆文件，这句话实际是在夸Linux出色的虚拟文件系统，Linux将所有设备抽象为文件，与设备的数据交互抽象为文件的I/O。&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/file.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/file.png&#34; alt=&#34;file&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;p&gt;Linux的虚拟文件系统大概分为四块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;超级块&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;文件系统(ext3,ext4以及windows上的NTFS、FAT32、FAT16等)&lt;/li&gt;
&lt;li&gt;内核结构对应&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/fs.h#L1415&#34;&gt;super_block&lt;/a&gt;，对应操作对象&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/fs.h#L1921&#34;&gt;super_operations&lt;/a&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;索引节点&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;操作系统以块为单位对磁盘操作(块是扇区大小的整数倍)。索引节点记录了文件在磁盘上所有的物理块(文件内容)，以及其他信心(更新时间，操作时间等)。&lt;/li&gt;
&lt;li&gt;内核结构对应&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/fs.h#L615&#34;&gt;inode&lt;/a&gt;，对应操作对象&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/fs.h#L1843&#34;&gt;inode_operations&lt;/a&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;目录项&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;可以理解为文件的路径(不是目录，Linux上目录也是文件)，进程操作文件时通过目录项找到实际文件。&lt;/li&gt;
&lt;li&gt;内核结构对应&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/dcache.h#L89&#34;&gt;dentry&lt;/a&gt;，对应操作对象&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/dcache.h#L135&#34;&gt;dentry_operations&lt;/a&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;文件&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;由进程打开的文件。&lt;/li&gt;
&lt;li&gt;内核结构对应&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/fs.h#L921&#34;&gt;file&lt;/a&gt;，对应操作对象&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/fs.h#L1801&#34;&gt;file_operations&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通常服务里例如socket，pipe等对象的read，write实际就是file对应的file_operations的操作，而本文讲解I/O相关事情。&lt;/p&gt;
&lt;h1 id=&#34;2-几种io模型&#34;&gt;2. 几种I/O模型&lt;/h1&gt;
&lt;h2 id=&#34;21-blocking-io&#34;&gt;2.1 Blocking I/O&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;传统的阻塞I/O，对一个文件描述符操作(FD)时，如果操作没有响应就会一直等待，直到内核有反馈。缺点就是单线程一次只能操作一个FD。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/io_block.jpeg&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/io_block.jpeg&#34; alt=&#34;io_block&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;h2 id=&#34;22-nonblocking-io&#34;&gt;2.2 Nonblocking I/O&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;非阻塞I/O，对FD操作时，如果内核没反馈不会一直等待。非阻塞I/O会将所有FD放入FD set，一直轮询所有FD，直到有反馈的。缺点就是每次轮询时没有事件的FD也会被操作，浪费CPU。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/io_noblock.jpeg&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/io_noblock.jpeg&#34; alt=&#34;io_noblock&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;h2 id=&#34;23-signal-driven-io&#34;&gt;2.3 Signal Driven I/O&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;信号驱动I/O的基本原理就是首先注册signal handler，当FD有事件到来时，内核会像进程发送信号，然后应用进程执行signal handler。缺点就是，编程难度高，信号处理起来复杂。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/io_signal.jpeg&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/io_signal.jpeg&#34; alt=&#34;io_signal&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;h2 id=&#34;24-asynchronous-io&#34;&gt;2.4 Asynchronous I/O&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;异步I/O和信号驱动I/O都是异步的，区别是:信号驱动I/O是FD满足条件时内核通知应用程序可以进行I/O了，而异步I/O是应用程序将I/O操作交给内核，当内核做完之后再通知应用程序I/O做完了。缺点是异步的并发量不好控制。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/io_async.jpeg&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/io_async.jpeg&#34; alt=&#34;io_async&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;h2 id=&#34;25-io-multiplexing&#34;&gt;2.5 I/O Multiplexing&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;多路复用实际不是一个技术而是一个理念，在I/O多路复用之前就有通讯线路的频分复用和时分复用，大概就是合理的安排每个单位使用资源的时间和位置，看起来所有单位一起在使用原本只能允许少量单位同时使用的资源。&lt;/li&gt;
&lt;li&gt;Linux的I/O多路复用机制就是本文要讲的内容了。I/O多路复用就是将所有的FD注册到内核，然后当哪个FD可用时，那个会通知应用程序可用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/io_multi.jpeg&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/io_multi.jpeg&#34; alt=&#34;io_multi&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;p&gt;应用程序使用Linux提供的I/O多路复用机制都是通过&lt;a href=&#34;https://journey-c.github.io/2020/11/27/what-is-system-call&#34;&gt;系统调用&lt;/a&gt;使用的。最初Linux只提供了Select，在哪个服务端fd使用数量普遍不高的年代是够用的，后来随着网络的发展，1024个FD的限制已经不够用了，所以Linux提供了Poll，Poll只优化了存储结构，Select使用BitMap来存储FD，Poll使用数组来存储FD，不再限制数量，但是遍历时间复杂度还是$O(lg^N)$。终于在Linux 2.5.44版本，epoll闪亮登场，这是现在普遍使用的I/O多路复用机制。&lt;/p&gt;
&lt;h1 id=&#34;3-select&#34;&gt;3. Select&lt;/h1&gt;
&lt;h2 id=&#34;31-使用&#34;&gt;3.1 使用&lt;/h2&gt;
&lt;p&gt;Select是Linux最初提供的I/O多路复用函数。下面是libc库使用select的调用接口。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;select&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; nfds, fd_set &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;readfds, fd_set &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;writefds, fd_set &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;exceptfds, &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; timeval &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;timeout);
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;FD_SET&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; fd, fd_set &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;set);
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;FD_CLR&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; fd, fd_set &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;set);
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;FD_ISSET&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; fd, fd_set &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;set);
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;FD_ZERO&lt;/span&gt;(fd_set &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;set);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Select总共三部分参数&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;传入FD(文件描述符)最大的+1&lt;/li&gt;
&lt;li&gt;传入的FD，分三类
&lt;ul&gt;
&lt;li&gt;1). 监听读&lt;/li&gt;
&lt;li&gt;2). 监听写&lt;/li&gt;
&lt;li&gt;3). 监听异常&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果一直没有满足条件的fd，最多等多久(超时时间)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;select用一个&lt;code&gt;__FD_SETSIZE&lt;/code&gt;位的BitMap表示输入参数，&lt;code&gt;__FD_SETSIZE&lt;/code&gt;默认为1024。因为没有1024位那么长的数，所以用一个数组表示，因为数组元素地址连续，所以实际就是一个1024位的数，比如第1位为1，表示这次输入有fd1(标准输出fd)。这个地方也限制了&lt;code&gt;select最多支持1024个fd，并且fd的号码不能大于等于1024。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/fd_set.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/fd_set.png&#34; alt=&#34;fd_set&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;p&gt;解释完fd_set的构造，FD_SET、FD_CLR等操作也就明白了，FD_SET(d, s)就是d是几号fd就将s的第几位置1，其他的类似。&lt;/p&gt;
&lt;h2 id=&#34;32-实现&#34;&gt;3.2 实现&lt;/h2&gt;
&lt;p&gt;Linux的select函数是通过系统调用的机制提供给用户，我们来一起看一下Select的流程:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;系统调用函数入口在&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L722&#34;&gt;SYSCALL_DEFINE5&lt;/a&gt;，可能是历史原因想保留这个接口，所以这个函数没做事情直接调用了&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L700&#34;&gt;kern_select&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;Select传入的时间是一个相对时间，&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L700&#34;&gt;kern_select&lt;/a&gt;判断如果时间参数不为空的话，就调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L273&#34;&gt;poll_select_set_timeout&lt;/a&gt;将相对时间转化为绝对时间(准确的几点几分几秒)，然后就调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L621&#34;&gt;core_sys_select&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L621&#34;&gt;core_sys_select&lt;/a&gt;主要的工作就是为Select工作分配资源空间。
&lt;ul&gt;
&lt;li&gt;获取&lt;a href=&#34;https://en.wikipedia.org/wiki/Read-copy-update&#34;&gt;rcu锁&lt;/a&gt;，check一下第一个参数n是不是比进程最大可打开文件描述符数还大，如果还大的话修正n为最大可打开文件描述符数。释放&lt;a href=&#34;https://en.wikipedia.org/wiki/Read-copy-update&#34;&gt;rcu锁&lt;/a&gt;，rcu实际就是延迟更新，读操作不需要获取锁，只需要标记一下还有用户在读。写操作时拷贝一份数据，更新副本，当所有没有读者读旧数据的时候再将副本数据更新到原始数据上。&lt;/li&gt;
&lt;li&gt;接下来就是给输入的三个变量fds.in, fds.out, fds.ex，保存结果的三个变量(fds.res_in, fds.res_out, fds.res_ex)分配存储空间，先从&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L630&#34;&gt;栈&lt;/a&gt;分配，栈空间不够时从&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L658&#34;&gt;堆&lt;/a&gt;分配。&lt;/li&gt;
&lt;li&gt;资源分配结束后就调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L476&#34;&gt;do_select&lt;/a&gt;开始真正的检查每个FD是否可用。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L476&#34;&gt;do_select&lt;/a&gt;是select的核心，流程如下:
&lt;ul&gt;
&lt;li&gt;首先调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L419&#34;&gt;max_select_fd&lt;/a&gt;找出传入FD的最大值+1，比较一下参数n是不是比最大FD+1还大，如果是就修正n为最大FD+1(&lt;code&gt;这里之所以总是将n修正为最大值+1，是因为do_select遍历范围是[0,n)&lt;/code&gt;)，顺便检查下，传入的FD是不是有已关闭或者未打开的，如果有就报错&lt;code&gt;EBADF&lt;/code&gt;:
&lt;ul&gt;
&lt;li&gt;传入fd_set是long的数组，openfiles也是long的数组，因为之前n根据线程最大打开文件数修正过，所以通过(n/(long的位数))可以最高位可以比较的数组下表，然后fd_set数组的那一位根据(n % (long的位数))来去掉不满足条件的FD&lt;/li&gt;
&lt;li&gt;然后就从最高位开始fd_set和open_file做AND操作，第一个匹配的就是最大FD。&lt;/li&gt;
&lt;li&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/max_select_fd.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/max_select_fd.png&#34; alt=&#34;max_select_fd&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L121&#34;&gt;poll_initwait&lt;/a&gt;初始化&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L103&#34;&gt;poll_wqueues&lt;/a&gt;(维护select/poll任务的主要struct)，并且将&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L221&#34;&gt;__pollwait&lt;/a&gt;注册为&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L43&#34;&gt;poll_table&lt;/a&gt;的proc函数，file_operations-&amp;gt;poll会调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L48&#34;&gt;poll_wait&lt;/a&gt;将此时所在线程(task)放入队列，poll_wait对调用__poll_wait，这个_poll_wait此时注册的函数。主要作用就是将任务放入队列，以及做一些其他任务。&lt;/li&gt;
&lt;li&gt;如果timeout不为空，调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L236&#34;&gt;poll_schedule_timeout&lt;/a&gt;设置超时时间。&lt;/li&gt;
&lt;li&gt;重复遍历所有fd_set:
&lt;ul&gt;
&lt;li&gt;这个循环是个死循环，跳出条件为:
&lt;ul&gt;
&lt;li&gt;超时时间到(如果设置了超时时间)。&lt;/li&gt;
&lt;li&gt;线程被唤醒。&lt;/li&gt;
&lt;li&gt;当前线程被信号唤醒。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/file.h#L63&#34;&gt;fdget&lt;/a&gt;获取fd对应的file结构体。&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L86&#34;&gt;vfs_poll&lt;/a&gt;，获取file的事件mask，如果有in，out，ex就放入对应结果的fd_set中。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L86&#34;&gt;vfs_poll&lt;/a&gt;最终会调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/fs.h#L1801&#34;&gt;file_operations&lt;/a&gt;的poll函数获取FD的事件状态mask，vfs_poll会调用file_operations-&amp;gt;poll函数检查FD的事件，如果没有就调用poll_wait将线程放入等待队列。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/file.h#L43&#34;&gt;fdput&lt;/a&gt;释放fd对应file结构体。&lt;/li&gt;
&lt;li&gt;如果本次遍历一个有事件的FD也没有就调用cond_resched出让CPU，并且把线程状态设为INTERRUPTIBLE(睡眠可打断状态)，休眠直到被唤醒。&lt;/li&gt;
&lt;li&gt;等到有&lt;a href=&#34;#event_callback&#34;&gt;事件回调&lt;/a&gt;，就会重新遍历FD集合这次肯定有事件了，如果超时或者被信号唤醒也有相应操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L476&#34;&gt;do_select&lt;/a&gt;将可用FD返回之后，调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L688&#34;&gt;set_fd_set&lt;/a&gt;拷贝回用户空间。&lt;/li&gt;
&lt;li&gt;如果传入参数的BitsMap一开始是分配在堆上的就释放调。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L297&#34;&gt;poll_select_finish&lt;/a&gt;将剩余时间拷贝回用户空间。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;33-小结&#34;&gt;3.3 小结&lt;/h2&gt;
&lt;p&gt;select的流程简单来讲就是，将FD通过BitsMap传入内核，轮询所有的FD通过调用file-&amp;gt;poll函数查询是否有对应事件，没有就将task加入FD对应file的待唤醒队列，等待事件来临被唤醒。(例如网卡来数据了)&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/select_process.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/select_process.png&#34; alt=&#34;select_process&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;select使用BitsMap来传入和接受FD，每次调用都会在用户空间和内核空间之间拷贝。&lt;/li&gt;
&lt;li&gt;select的BitsMap限制只能监听FD 0~1023。&lt;/li&gt;
&lt;li&gt;轮询的方式监听所有FD，$O(n)$的复杂度&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;4-poll&#34;&gt;4. Poll&lt;/h1&gt;
&lt;h2 id=&#34;41-使用&#34;&gt;4.1 使用&lt;/h2&gt;
&lt;p&gt;随着互联网的发展Select 1024个FD的限制已经不满足众多服务了，于是出现了Poll，不再用BitsMap来传入FD，取而代之用动态数组传入FD，但获取事件状态的方式还是轮询。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;poll&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; pollfd &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;fds, nfds_t nfds, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; timeout);
&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; pollfd {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;   fd;         &lt;span style=&#34;color:#75715e&#34;&gt;/* file descriptor */&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;short&lt;/span&gt; events;     &lt;span style=&#34;color:#75715e&#34;&gt;/* requested events */&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;short&lt;/span&gt; revents;    &lt;span style=&#34;color:#75715e&#34;&gt;/* returned events */&lt;/span&gt;
};

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;1.fds: 传入fd集合，由pollfd构成
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;fd: 文件描述符&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;events: 监听事件&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;revents: 返回FD是因为什么事件返回的&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2.nfds: fds的长度&lt;/li&gt;
&lt;li&gt;3.timeout: 超时时间，单位毫秒&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;42-实现&#34;&gt;4.2 实现&lt;/h2&gt;
&lt;p&gt;Poll和Select的入口都在&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c&#34;&gt;fs/select.c&lt;/a&gt;中，下面我们来看一下Poll内核实现的流程:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Poll的入口在&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L1057&#34;&gt;SYSCALL_DEFINE3&lt;/a&gt;，&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L1057&#34;&gt;SYSCALL_DEFINE3&lt;/a&gt;的主要工作是将timeout由相对时间转化为绝对时间。然后调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L970&#34;&gt;do_sys_poll&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L970&#34;&gt;do_sys_poll&lt;/a&gt;流程:
&lt;ul&gt;
&lt;li&gt;检查nfds是否超过进程最大可打开文件数，如果是就报错-EINVAL。&lt;/li&gt;
&lt;li&gt;给输入参数分配空间再从用户空间拷贝过来，先试图在栈上分配，如果不够再从堆上分配。&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L121&#34;&gt;poll_initwait&lt;/a&gt;初始化poll_wqueues(和select一样)，然后调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L881&#34;&gt;do_poll&lt;/a&gt;，do_poll主要流程为:
&lt;ul&gt;
&lt;li&gt;调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L75&#34;&gt;select_estimate_accuracy&lt;/a&gt;设置过期时间。&lt;/li&gt;
&lt;li&gt;然后就轮训所有的FD，调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L851&#34;&gt;do_pollfd&lt;/a&gt;检查FD的事件。do_pollfd也是调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L86&#34;&gt;vfs_poll&lt;/a&gt;来检测FD事件的，如果没有就将线程放入对应FD的等待队列等待被激活，自己休眠。(和select一样)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L138&#34;&gt;poll_freewait&lt;/a&gt;释放刚刚初始化的poll_wqueues。&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;__put_user&lt;/code&gt;将结果拷贝回用户空间。&lt;/li&gt;
&lt;li&gt;如果最开始参数是在堆上分配的，就释放内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;43-小结&#34;&gt;4.3 小结&lt;/h2&gt;
&lt;p&gt;poll和select差不多，区别就是BitsMap换成了链表，FD数量只受poll可用内核内存大小限制。&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/poll_process.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/poll_process.png&#34; alt=&#34;poll_process&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;poll监听FD数量不再有限制(除线程本身限制外)，但是每次调用poll还是要将FD集合拷贝到内核态，完成后再拷贝回来。&lt;/li&gt;
&lt;li&gt;监听所有FD的方式还是轮训，$O(n)$的复杂度。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;5-epoll&#34;&gt;5. Epoll&lt;/h1&gt;
&lt;h2 id=&#34;51-使用&#34;&gt;5.1 使用&lt;/h2&gt;
&lt;p&gt;正因为select和poll有着各自的缺点，所以linux 2.5.44版本提供了新的I/O复用机制Epoll，在后续的版本中继续做了很多优化。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; epoll_event {
    uint32_t     events;      &lt;span style=&#34;color:#75715e&#34;&gt;/* Epoll events */&lt;/span&gt;
    epoll_data_t data;        &lt;span style=&#34;color:#75715e&#34;&gt;/* User data variable */&lt;/span&gt;
};
&lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;union&lt;/span&gt; epoll_data {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;ptr;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;          fd;
    uint32_t     u32;
    uint64_t     u64;
} epoll_data_t;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 创建用于epoll工作的FD
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;epoll_create&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; size);

&lt;span style=&#34;color:#75715e&#34;&gt;// 对事件操作：增、删等
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;epoll_ctl&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; epfd, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; op, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; fd, &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; epoll_event &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;event); 

&lt;span style=&#34;color:#75715e&#34;&gt;// 等待事件
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;epoll_wait&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; epfd, &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; epoll_event &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;events, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; maxevents, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; timeout);  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;epoll_create&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;size: 监听fd的数量，Linux 2.6.8就去掉了这个参数，因为要兼容，所以留着这个参数，但实际内核没用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;epoll_ctl&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;epfd: epoll对应的FD&lt;/li&gt;
&lt;li&gt;op: 操作码，增(EPOLL_CTL_ADD),删(EPOLL_CTL_DEL),改(EPOLL_CTL_MOD)&lt;/li&gt;
&lt;li&gt;fd: 对epoll操作的源FD，例如要添加删除修改的FD&lt;/li&gt;
&lt;li&gt;event: 要监听的事件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;epoll_wait&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;epfd: epoll对应的FD&lt;/li&gt;
&lt;li&gt;events: 要等待的事件数组&lt;/li&gt;
&lt;li&gt;maxevents: 监听事件数量&lt;/li&gt;
&lt;li&gt;timeout: 超时时间，单位毫秒&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;52-实现&#34;&gt;5.2 实现&lt;/h2&gt;
&lt;h3 id=&#34;521-epoll_create&#34;&gt;5.2.1 epoll_create&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;epoll_create的入口在&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L2088&#34;&gt;SYSCALL_DEFINE1&lt;/a&gt;，这个函数只是简单的检查了一下size是否为0，epoll_create的size参数随便填只要大于0即可，不使用的。然后调用了&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L2040&#34;&gt;do_epoll_create&lt;/a&gt;对epoll_create操作统一处理。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L2040&#34;&gt;do_epoll_create&lt;/a&gt;流程如下:
&lt;ul&gt;
&lt;li&gt;检查一下flags除了EPOLL_CLOEXEC，还有没有其他的flag&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1006&#34;&gt;ep_alloc&lt;/a&gt;申请一个&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L181&#34;&gt;eventpoll&lt;/a&gt;结构，这是存储epoll所有数据的数据结构。&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/file.c#L561&#34;&gt;get_unused_fd_flags&lt;/a&gt;根据flags申请一个本进程最小未使用的fd。&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/anon_inodes.c#L74&#34;&gt;anon_inode_getfile&lt;/a&gt;创建一个对应匿名inode的file，file的私有数据存的是eventpoll结构体。inode在VFS中对应一个文件，记录了此文件在磁盘那些块以及文件各种信息，匿名inode就是将此文件的dentry(目录项)删掉了，在文件系统中一般是通过dentry(目录项)来查找使用文件，这样其他进程就用不了这个文件。相当于创建一个临时文件。&lt;/li&gt;
&lt;li&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/anonymous_inode.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/anonymous_inode.png&#34; alt=&#34;anonymous_inode&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;现在file(由进程打开的文件)有了，fd有了，把file和fd的关系放入本进程的open_files中，就相当于本进程打开了这个文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;522-epoll_ctl&#34;&gt;5.2.2 epoll_ctl&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;epoll_ctl的入口在&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L2272&#34;&gt;SYSCALL_DEFINE4&lt;/a&gt;，首先根据op选择要不要从用户空间拷贝参数(只要不是DEL都需要拷贝)，之后就调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L2108&#34;&gt;do_epoll_ctl&lt;/a&gt;做主要的工作了。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L2108&#34;&gt;do_epoll_ctl&lt;/a&gt;主要流程如下:
&lt;ul&gt;
&lt;li&gt;参数获取:
&lt;ul&gt;
&lt;li&gt;调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/file.h#L63&#34;&gt;fdget&lt;/a&gt;根据epfd获得epoll对应的file(epoll_create时创建的)，根据参数传入的fd获取对应的file。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;参数 :
&lt;ul&gt;
&lt;li&gt;调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L81&#34;&gt;file_can_poll&lt;/a&gt;判断该文件支不支持poll函数，实际就是判断该文件对应的file_operation的poll函数为不为空。&lt;/li&gt;
&lt;li&gt;判断系统支不支持autosleep功能，如果支持且用户也传入了EPOLLWAKEUP标志，就调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/uapi/linux/eventpoll.h#L83&#34;&gt;ep_take_care_of_epollwakeup&lt;/a&gt;将标志加到事件中，否则就将EPOLLWAKEUP事件丢弃。&lt;/li&gt;
&lt;li&gt;check一下要操作的fd是不是epfd(操作自己epoll的fd)和epfd是不是一个epoll fd。&lt;/li&gt;
&lt;li&gt;EPOLLEXCLUSIVE(since Linux 3.5)是一个FD被多个epoll监听时，当这个FD事件来临只有一个epoll会被唤起(避免惊群效应)。而epoll只允许add的时传入不允许mod时传入，这里就是check一下这种情况。&lt;/li&gt;
&lt;li&gt;处理一种Epoll A包含Epoll B的FD，Epoll B也包含Epoll A的FD的情况，这时候如果其中一个FD有了事件，那么两个Epoll会循环被唤醒。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;接下来就是核心操作:
&lt;ul&gt;
&lt;li&gt;根据file地址和fd大小 调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1041&#34;&gt;ep_find&lt;/a&gt; 查找传入fd是否在eventpoll结构体中的rbtree(存储所有监听的fd)已存在。rbtree的key就是&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L107&#34;&gt;epoll_filefd&lt;/a&gt;，比较规则，先比较file的地址，相同的话在比较fd的大小。&lt;/li&gt;
&lt;li&gt;如果是ADD就调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1490&#34;&gt;ep_insert&lt;/a&gt;:
&lt;ul&gt;
&lt;li&gt;当前用用户的epoll_watch和&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1502&#34;&gt;max_user_watches&lt;/a&gt;检查是否还有可用空间，内核给每个用户的epoll可以用空间限制为syscall可使用空间的$1/25$。&lt;/li&gt;
&lt;li&gt;从缓存中创建一个新的epitem(&lt;a href=&#34;https://journey-c.github.io/2020/10/22/red-black-tree&#34;&gt;红黑树&lt;/a&gt;的value)。&lt;/li&gt;
&lt;li&gt;初始化rdllink(满足事件链表)，fllink(链接fd对应的file链表)，pwqlist(poll等待队列)。&lt;/li&gt;
&lt;li&gt;初始化epitem的参数，调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L322&#34;&gt;ep_set_ffd&lt;/a&gt;根据file，fd生成&lt;a href=&#34;https://journey-c.github.io/2020/10/22/red-black-tree&#34;&gt;红黑树&lt;/a&gt;的key(struct epoll_filefd)等。&lt;/li&gt;
&lt;li&gt;向插入fd对应file的epoll事件链表(f_ep_links)中新增事件。&lt;/li&gt;
&lt;li&gt;将epitem插入&lt;a href=&#34;https://journey-c.github.io/2020/10/22/red-black-tree&#34;&gt;红黑树&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L75&#34;&gt;init_poll_funcptr&lt;/a&gt;注册poll回调函数&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1309&#34;&gt;ep_ptable_queue_proc&lt;/a&gt;。在前select一节有描述。这里回调函数&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1309&#34;&gt;ep_ptable_queue_proc&lt;/a&gt;除了将task放入FD对应file的等待队列之外，事件来临还会调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1204&#34;&gt;ep_poll_callback&lt;/a&gt;函数。&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L877&#34;&gt;ep_item_poll&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;如果不是epoll的FD就调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L86&#34;&gt;vfs_poll&lt;/a&gt;-&amp;gt;file_operations.poll查询FD事件如果有就返回，没有就插入等待队列。&lt;/li&gt;
&lt;li&gt;如果是epoll的FD，就调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L677&#34;&gt;ep_scan_ready_list&lt;/a&gt;将epoll的rdllist(已就绪的FD)传入用户空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果有事件的话并且之前不在就绪链表rdllist，就放入就绪链表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果是DEL就调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L767&#34;&gt;ep_remove&lt;/a&gt;:
&lt;ul&gt;
&lt;li&gt;调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L618&#34;&gt;ep_unregister_pollwait&lt;/a&gt;注销epoll_add时注册的file对应的poll_wait函数。&lt;/li&gt;
&lt;li&gt;从各链表中删除。&lt;/li&gt;
&lt;li&gt;从&lt;a href=&#34;https://journey-c.github.io/2020/10/22/red-black-tree&#34;&gt;红黑树&lt;/a&gt;中删除。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果是MOD就调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1622&#34;&gt;ep_modify&lt;/a&gt;:
&lt;ul&gt;
&lt;li&gt;修改FD事件。&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L877&#34;&gt;ep_item_poll&lt;/a&gt;查询是否修改后有事件，有的话就放入rdllist就绪链表。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;523-epoll_wait&#34;&gt;5.2.3 epoll_wait&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;epoll_wait入口在&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L2330&#34;&gt;SYSCALL_DEFINE4&lt;/a&gt;，之后调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L2288&#34;&gt;do_epoll_wait&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L2288&#34;&gt;do_epoll_wait&lt;/a&gt;主要流程:
&lt;ul&gt;
&lt;li&gt;检查参数，参数是否正确，返回结果地址是否正确，要操作的epollfd是否正确。&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1818&#34;&gt;ep_poll&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;如果有timeout不为零，就将时间转化为绝对时间，如果为0就检查一下当前就绪队列是否为空，如果有事件直接返回，没有事件就返回空。&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L375&#34;&gt;ep_events_available&lt;/a&gt;检查当前有无就绪FD，有就直接返回，或者当前file_operations-&amp;gt;poll函数正忙就等等，看工作完有没有。&lt;/li&gt;
&lt;li&gt;如果没有就进入死循环，和select一样，将task设为TASK_INTERRUPTIBLE，等待被唤醒或被信号唤醒或超时。&lt;/li&gt;
&lt;li&gt;直到被唤醒依然调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L375&#34;&gt;ep_events_available&lt;/a&gt;检查有没有就绪FD，有的话就调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1778&#34;&gt;ep_send_events&lt;/a&gt;将结果传回用户空间。
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1778&#34;&gt;ep_send_events&lt;/a&gt;调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L677&#34;&gt;ep_scan_ready_list&lt;/a&gt;扫描rdllist链表并且调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1694&#34;&gt;ep_send_events_proc&lt;/a&gt;将事件发回用户空间，如果FD的使用的epoll的模式为EPOLLET(水平触发)发送完之后重新被加入rdllist链表，等待下次epoll_wait时，如果fd在rdllink中且已经不可读了就不再加入rdllist中了。&lt;/li&gt;
&lt;li&gt;发送会用户空间之后，将因为rdllist发送时加锁而没加入的事件(放入了ovflist)加入rdllist。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;53-小结&#34;&gt;5.3 小结&lt;/h2&gt;
&lt;p&gt;select和poll的模式都是，一次将参数拷贝到内核空间，等有结果了再一次拷贝出去，类似无状态服务。而epoll则只是在epoll_ctl(ADD)时将数据拷入，epoll_wait时在将数据拷出，多次复用没有其他数据拷贝，大大节省了数据拷贝。epoll采用&lt;a href=&#34;https://journey-c.github.io/2020/10/22/red-black-tree&#34;&gt;红黑树&lt;/a&gt;存储所有被监听的FD是的查找删除时间复杂度由$O(N)$缩短为$O(log^N)$。&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/epoll_process.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/epoll_process.png&#34; alt=&#34;epoll_process&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;epoll_create创建eventpoll结构。&lt;/li&gt;
&lt;li&gt;epoll_ctl:
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;ADD检查FD事件，有就加入rdllist队列，没有就将task放入FD对应file的待唤醒列表，将FD加入&lt;a href=&#34;https://journey-c.github.io/2020/10/22/red-black-tree&#34;&gt;红黑树&lt;/a&gt;维护。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;DEL从eventpoll的各个资源中删除。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;MOD修改事件，并再次检查FD事件，有就加入rdllist队列，没有就将task放入FD对应file的待唤醒列表并且注册事件回调函数——有事件来临就加入rdllist。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;epoll_wait检查rdllist有没有已经就绪的FD，没有就等待时间来临唤醒，有事件就返回用户空间，并且清空rdllist链表，如果FD是EPOLLLET模式的就重新加入rdllist链表中，等待下次epoll_wait看情况清理。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;6-selectpollepoll对比&#34;&gt;6. select、poll、epoll对比&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;监听FD数量&lt;/th&gt;
&lt;th&gt;数据拷贝&lt;/th&gt;
&lt;th&gt;操作复杂度&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;select&lt;/td&gt;
&lt;td&gt;1024&lt;/td&gt;
&lt;td&gt;每次操作从用户空间拷入内核空间然后拷出&lt;/td&gt;
&lt;td&gt;$O(N)$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;poll&lt;/td&gt;
&lt;td&gt;内核限制sys内存大小&lt;/td&gt;
&lt;td&gt;每次操作从用户空间拷入内核空间然后拷出&lt;/td&gt;
&lt;td&gt;$O(N)$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;epoll&lt;/td&gt;
&lt;td&gt;内核限制sys内存大小&lt;/td&gt;
&lt;td&gt;ADD时拷贝一次，epoll_wait时利用MMAP和用户共享空间，直接拷贝数据到用户控件&lt;/td&gt;
&lt;td&gt;$O(1)$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;span id = &#34;event_callback&#34;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h1 id=&#34;7-事件回调&#34;&gt;7. 事件回调&lt;/h1&gt;
&lt;p&gt;select/poll/epoll最后都会调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L86&#34;&gt;vfs_poll&lt;/a&gt;，检查FD是否有相应事件。
&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L86&#34;&gt;vfs_poll&lt;/a&gt;的核心流程就是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先检查FD对应的file目前是否已有事件，如果没有则将当前task(linux中线程进程都是task)加入到file的wait_queue，然后就让出CPU，等待被激活。&lt;/li&gt;
&lt;li&gt;当file对应的设备有事件来临时，会激活file的wait_queue中所有等待的task(将task从等待态变为运行态，重新加入到调度列表中)。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;CPU1                CPU2
sys_select          receive packet
...                 ...
__add_wait_queue    update tp&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;rcv_nxt
...                 ...
tp&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;rcv_nxt check   sock_def_readable
...                 {
schedule               rcu_read_lock();
                       wq &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rcu_dereference(sk&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;sk_wq);
                       &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (wq &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; waitqueue_active(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;wq&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;wait))
                           wake_up_interruptible(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;wq&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;wait)
                       ...
                    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;71-流程&#34;&gt;7.1 流程&lt;/h2&gt;
&lt;p&gt;下面我们以socket为例，分析一下事件是如何回调的。&lt;/p&gt;
&lt;p&gt;设备驱动层主要做的事情是，网卡作为一个硬件，当收到网络包的时候如何通知操作系统。没错，是硬件中断，硬件和操作系统打交道的方式基本都是硬件中断。而网卡与内核交互采用了硬件中断+下半部（主要是拷贝数据太耗时，放在中断处理程序中不妥）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设备给中断控制器引脚发送信号。&lt;/li&gt;
&lt;li&gt;中断控制器收到后给CPU发送信号。&lt;/li&gt;
&lt;li&gt;CPU收到信号后产生中断，根据中断号在中断向量表中执行内核实现的中断处理程序。(执行程序实际就是已经与内核通讯了)

&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/event_driver.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/event_driver.png&#34; alt=&#34;event_driver&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以intel的ixgb网卡为例。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;网卡程序初始化时调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L116&#34;&gt;ixgb_init_module&lt;/a&gt;注册驱动&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L92&#34;&gt;ixgb_driver&lt;/a&gt;，并且调用驱动的probe函数&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L359&#34;&gt;ixgb_probe&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L359&#34;&gt;ixgb_probe&lt;/a&gt;中与本文相关的有:
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;创建一个&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/netdevice.h#L1863&#34;&gt;struct net_device&lt;/a&gt;表示网络设备。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;设置网卡的相关操作&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L331&#34;&gt;ixgb_netdev_ops&lt;/a&gt;，其中ndo_open函数是网卡激活时执行的函数，对应ixgb网卡的&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L593&#34;&gt;ixgb_open&lt;/a&gt;函数。调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L6600&#34;&gt;netif_napi_add&lt;/a&gt;为这个网络设备注册一个轮询 poll 函数 &lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L1752&#34;&gt;ixgb_clean&lt;/a&gt;，将来一旦出现网络包的时候，就是要通过它来轮询了。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L593&#34;&gt;ixgb_open&lt;/a&gt;中调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L171&#34;&gt;ixgb_up&lt;/a&gt;注册硬件中断，类型为IRQF_SHARED，中断设备名字ixgb，并且中断处理程序为&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L1721&#34;&gt;ixgb_intr&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当网卡有数据来临时，网卡给中断控制器发送信号，中断控制器给CPU发送信号，CPU执行对应的中断处理函数&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L1721&#34;&gt;ixgb_intr&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L1721&#34;&gt;ixgb_intr&lt;/a&gt;中调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L6281&#34;&gt;__napi_schedule&lt;/a&gt;和&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L4240&#34;&gt;___napi_schedule&lt;/a&gt;将设备标记，触发软件中断NET_RX_SOFTIRQ，软件中断号对应的中断处理函数为&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L6735&#34;&gt;net_rx_action&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L6735&#34;&gt;net_rx_action&lt;/a&gt;调用napi_poll轮询所有的网络设备，napi_poll调用网卡注册是注册的poll函数&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L1752&#34;&gt;ixgb_clean&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L1752&#34;&gt;ixgb_clean&lt;/a&gt;调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L1929&#34;&gt;ixgb_clean_rx_irq&lt;/a&gt;读取数据并将数据存放到struct sk_buff中，然后调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L5553&#34;&gt;netif_receive_skb&lt;/a&gt;处理二层的数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;从&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L5553&#34;&gt;netif_receive_skb&lt;/a&gt;开始处理二层的数据，调用链&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L5478&#34;&gt;netif_receive_skb_internal&lt;/a&gt;-&amp;gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L5380&#34;&gt;__netif_receive_skb&lt;/a&gt;-&amp;gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L5079&#34;&gt;__netif_receive_skb_core&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L5079&#34;&gt;__netif_receive_skb_core&lt;/a&gt;中根据协议头将数据交给三层对应的协议栈。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;现在就开始处理三层的数据里，假如当前的包是一个IPv4的包，数据就会流向&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/ip_input.c#L530&#34;&gt;ip_rcv&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/ip_input.c#L530&#34;&gt;ip_rcv&lt;/a&gt;中得到IP的报头，然后调用NF_HOOK判断路由，不是本机的包就发走，是本机的包就调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/ip_input.c#L414&#34;&gt;ip_rcv_finish&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/ip_input.c#L414&#34;&gt;ip_rcv_finish&lt;/a&gt;调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/ip_input.c#L314&#34;&gt;ip_rcv_finish_core&lt;/a&gt;然后根据IP报头中的协议把数据交给四层的协议栈。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;千辛万苦数据终于来到了四层，假如当前是一个TCP包的话。会调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/tcp_ipv4.c#L1886&#34;&gt;tcp_v4_rcv&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/tcp_ipv4.c#L1886&#34;&gt;tcp_v4_rcv&lt;/a&gt;根据IP以及tcp报头内容在&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/tcp_ipv4.c#L91&#34;&gt;tcp_hashinfo&lt;/a&gt; (&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/net/inet_hashtables.h#L124&#34;&gt;inet_hashinfo&lt;/a&gt;)找到对应socket&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;接下来根据socket的不同状态进行处理，socket根据情况进入三个不同队列，这一步主要是先将包找个地方放一下，赶紧离开中断状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;backlog 当前没有用户在读数据，就将socket 放入backlog中，离开软件中断状态(到之前为止一直在软件中断中)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;prequeue 如果当前有用户在读数据，且一个窗口的包还没收集完就放入prequeue&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;sk_receive_queue 当一个窗口的包准确收集完了，就放入sk_receive_queue中，用户可读取了。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;当一个窗口的包准确收集完之后，就会调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/tcp_input.c#L4849&#34;&gt;tcp_data_queue&lt;/a&gt;将数据放入sk_receive_queue，然后调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/tcp_input.c#L4837&#34;&gt;tcp_data_ready&lt;/a&gt;，在调用sock的sk_data_ready函数&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/sock.c#L2901&#34;&gt;sock_def_readable&lt;/a&gt;，&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/sock.c#L2901&#34;&gt;sock_def_readable&lt;/a&gt;会唤醒之前因为调用file_operations.poll为阻塞的进程或线程。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;这就到了咱们最关心的问题了，&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/tcp_input.c#L4837&#34;&gt;tcp_data_ready&lt;/a&gt;唤醒的是哪些task。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;72-流程图&#34;&gt;7.2 流程图&lt;/h2&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/net_callback.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/net_callback.png&#34; alt=&#34;net_callback&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
</description>
  </item>
  
  <item>
    <title>系统调用</title>
    <link>https://journey-c.github.io/what-is-system-call/</link>
    <pubDate>Fri, 27 Nov 2020 20:58:31 +0800</pubDate>
    
    <guid>https://journey-c.github.io/what-is-system-call/</guid>
    <description>&lt;h1 id=&#34;1-简介&#34;&gt;1 .简介&lt;/h1&gt;
&lt;p&gt;系统调用就是操作系统提供给用户态应用与硬件交互的一组接口。在用户空间和硬件之间添加一个中间层(系统调用)主要的作用有:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为用户空间提供抽象接口，用户不需要关心硬件种类介质等。&lt;/li&gt;
&lt;li&gt;保障系统的稳定和安全，避免用户错误的使用硬件危害系统或者窃取其他进程的资源。&lt;/li&gt;
&lt;li&gt;由于Linux进程都是运行在虚拟系统中，如果操作系统对用户访问硬件一无所知，就几乎无法实现多任务和虚拟内存。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/unix_arch.jpeg&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/unix_arch.jpeg&#34; alt=&#34;unix_arch&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;div&gt;
	&lt;center&gt;图片来源&lt;a href=&#34;https://www.amazon.com/Advanced-Programming-UNIX-Environment-3rd/dp/0321637739&#34;&gt;《Advanced Programming in the UNIX Environment, 3rd Edition》&lt;/a&gt;&lt;/center&gt;
&lt;/div&gt;
&lt;h1 id=&#34;2-三种使用系统调用方式&#34;&gt;2. 三种使用系统调用方式&lt;/h1&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/syscall_method.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/syscall_method.png&#34; alt=&#34;syscall_method&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;h2 id=&#34;21-软件中断&#34;&gt;2.1 软件中断&lt;/h2&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/interrupt.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/interrupt.png&#34; alt=&#34;interrupt&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;p&gt;没有外界打扰的情况下处理器会一直执行给定指令，中断就是打断处理器的执行并且告诉他先执行另一段指令，执行完毕再接着执行中断前的指令。从中断指令发出的对象可以分为硬件中断和软件中断。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;硬件中断就是硬件通过传输电信号到中断控制器的输入引脚，中断控制器收到电信号之后会给处理器发送一个电信号，处理器一经检测到电信号之后就中断当前工作转而处理中断。之后会通知操作系统已经产生中断，进而操作系统可以处理这个中断了。&lt;/li&gt;
&lt;li&gt;软件中断就是处理器执行特定指令时触发的中断，之后也会通知操作系统。&lt;/li&gt;
&lt;li&gt;除了系统调用，还有中断下半部tasklet也是用软件中断实现的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在x86的机器上可以使用$INT$指令触发软件中断，Linux早期的时候就是使用软件中断来处理系统调用，中断号为128。
软件中断执行系统调用的流程为:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户将中断号放入$eax$寄存器，前六个参数按顺序放入$ebx$、$ecx$、$edx$、$esi$、$edi$、$ebp$寄存器，六个以上的情况，需要把所有参数放在用户空间的一段连续内存中(类似用struct传参)，然后将指向该内存区域的指针放入$ebx$中。&lt;/li&gt;
&lt;li&gt;执行$int$ 0x80指令，处理器在中断向量表(&lt;a href=&#34;https://en.wikipedia.org/wiki/Interrupt_descriptor_table&#34;&gt;IDT&lt;/a&gt;)中查找对应的中端处理程序，执行中断处理程序(操作系统由ring3进入ring0)&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/arch/x86/entry/entry_32.S#L1052&#34;&gt;entry_INT80_32&lt;/a&gt;:
&lt;ul&gt;
&lt;li&gt;a. 调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/arch/x86/entry/entry_32.S#L1056&#34;&gt;SAVE_ALL&lt;/a&gt;将当前上下文保存到内核栈，然后调用&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/arch/x86/entry/common.c#L84&#34;&gt;do_int80_syscall_32&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;b. &lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/arch/x86/entry/common.c#L84&#34;&gt;do_int80_syscall_32&lt;/a&gt; 从用户空间进入内核空间然后调用 &lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/arch/x86/entry/common.c#L72&#34;&gt;do_syscall_32_irqs_on&lt;/a&gt;，退出内核空间返回用户空间。&lt;/li&gt;
&lt;li&gt;c. &lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/arch/x86/entry/common.c#L72&#34;&gt;do_syscall_32_irqs_on&lt;/a&gt; 检查系统调用号，从系统调用表&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/arch/x86/entry/syscall_32.c#L18&#34;&gt;ia32_sys_call_table&lt;/a&gt; &lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/arch/x86/entry/syscalls/syscall_32.tbl&#34;&gt;syscall_32.tbl&lt;/a&gt;中找出对应函数，并且将参数传给对应系统调用函数，唤起软件中断，将返回值放入$eax$寄存器。&lt;/li&gt;
&lt;li&gt;d. 从内核栈恢复上下文。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/interrupt_call.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/interrupt_call.png&#34; alt=&#34;interrupt_call&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;


下面就是一个通过软件中断调用write系统调用的例子:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;global _start

section .text
_start:
    mov eax,4      ; system call number
    mov ebx,1      ; args 1: fd&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;STDOUT&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
    mov ecx,msg    ; args 2: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello World!&amp;#34;&lt;/span&gt;
    mov edx,msglen ; args 3: len&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello World!&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
    int 0x80       ; soft interrupt
    mov eax,1      ; syscall exit number
    mov ebx,0      ; args 1: &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;exit&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;0&lt;span style=&#34;color:#f92672&#34;&gt;))&lt;/span&gt;
    int 0x80       ; soft interrupt

section .rodata
    msg: db &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello, World!&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
    msglen: equ $ - msg 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;nasm -g -f elf64 -o sys_call.o sys_call.s
ld -o sys_call sys_call.o
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;22-汇编指令&#34;&gt;2.2 汇编指令&lt;/h2&gt;
&lt;p&gt;由于中断实现的系统调用在个别处理器上表现非常差，Linux在较新版本上使用了intel和amd上实现的快速系统调用指令syscall/sysret(64)和sysenter/sysexit(32)。这也是目前最常用的系统调用方式。

&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/asm.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/asm.png&#34; alt=&#34;asm&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;p&gt;具体流程为:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;cpu初始化&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/arch/x86/kernel/cpu/common.c#L1869&#34;&gt;cpu_init&lt;/a&gt; 调用 &lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/arch/x86/kernel/cpu/common.c#L1702&#34;&gt;syscall_init&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/arch/x86/kernel/cpu/common.c#L1702&#34;&gt;syscall_init&lt;/a&gt; 将系统调用处理函数&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/arch/x86/entry/entry_64.S#L95&#34;&gt;entry_SYSCALL_64&lt;/a&gt;和&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/arch/x86/entry/entry_32.S#L903&#34;&gt;entry_SYSENTER_32&lt;/a&gt;注册到&lt;a href=&#34;https://en.wikipedia.org/wiki/Model-specific_register&#34;&gt;MSR&lt;/a&gt;寄存器，&lt;a href=&#34;https://en.wikipedia.org/wiki/Model-specific_register&#34;&gt;MSR&lt;/a&gt;寄存器是用于控制CPU运行、功能开关、调试、跟踪程序执行、监测CPU性能等方面的寄存器。&lt;/li&gt;
&lt;li&gt;触发系统调用后，它会在&lt;a href=&#34;https://en.wikipedia.org/wiki/Model-specific_register&#34;&gt;MSR&lt;/a&gt;中读取需要执行的函数然后执行。&lt;/li&gt;
&lt;li&gt;剩余流程和软件中断方式差不多。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/asm_call.png&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/asm_call.png&#34; alt=&#34;asm_call&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;h2 id=&#34;23-vdos&#34;&gt;2.3 vDOS&lt;/h2&gt;
&lt;p&gt;Linux平台的用户使用系统调用的方式大多是通过&lt;a href=&#34;https://www.gnu.org/software/libc/&#34;&gt;libc&lt;/a&gt;, 由于&lt;a href=&#34;https://www.gnu.org/software/libc/&#34;&gt;libc&lt;/a&gt;库要兼容BSD，SysV Windows等平台，所以每当Linux新增系统调用时，&lt;a href=&#34;https://www.gnu.org/software/libc/&#34;&gt;libc&lt;/a&gt;库都要间隔一段时间才会支持。并且有的用户升级Linux时并不会顺带升级&lt;a href=&#34;https://www.gnu.org/software/libc/&#34;&gt;libc&lt;/a&gt;，导致双方都带有沉重历史包袱。&lt;/p&gt;
&lt;p&gt;后来Linux实现了快速系统调用vsyscall，内核提供.so通过动态链接直接map到进程空间里供用户使用，但是vsyscall有一个风险点——map 的起始地址固定（0xffffffffff600000)，有潜在的安全风险。&lt;/p&gt;
&lt;p&gt;为了改善vsyscall的局限性，设计了&lt;a href=&#34;https://en.wikipedia.org/wiki/VDSO&#34;&gt;vDSO&lt;/a&gt;。但为了兼容vsyscall现在还保留着。&lt;/p&gt;
&lt;p&gt;vDSO利用&lt;a href=&#34;https://en.wikipedia.org/wiki/Address_space_layout_randomization&#34;&gt;ASLR&lt;/a&gt;增强里安全性，随机地址。&lt;/p&gt;
&lt;p&gt;可以看到Linux中的进程大多包含vDSO的动态库&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;➜  ~ ldd /bin/cat 
	linux-vdso.so.1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&amp;gt;  &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;0x00007ffc03be0000&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
	libc.so.6 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&amp;gt; /lib/x86_64-linux-gnu/libc.so.6 &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;0x00007f52236dd000&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
	/lib64/ld-linux-x86-64.so.2 &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;0x00007f5223aa7000&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但是并不存在实际的.so文件，vsyscall以及vDOS将系统调用变为函数调用，并把他们映射到用户空间，明显的提高了系统调用的性能。
Linux 2.6时，vsyscall就支持了clock_gettime, gettimeofday, time。&lt;a href=&#34;https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/arch/x86/entry/vdso/vdso.lds.S&#34;&gt;vdso.lds.S&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://journey-c.github.io/images/vdso.jpeg&#34;&gt;
&lt;img src=&#34;https://journey-c.github.io/images/vdso.jpeg&#34; alt=&#34;vdso&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;p&gt;看到这里的时候突然想到，刚参加工作的时候一位前辈和我说获取时间可以不使用系统调用，当时一脸懵逼，现在想想确实知道的太少。一些知识不是需要多高的智商才能学到，而是就摆在那，看了就不知道，不看就不知道。&lt;/p&gt;
&lt;h1 id=&#34;3-总结&#34;&gt;3. 总结&lt;/h1&gt;
&lt;p&gt;系统调用是用户和硬件交互的媒介&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;软中断实现是最初Linux实现系统调用方式，但现在还有使用的方式，例如golang在一些架构上系统调用还是使用软中断的方式，因为golang团队在做基准测试的时候发现，软中断方式和快速指令方式效率差不多。&lt;a href=&#34;https://go-review.googlesource.com/c/go/+/16996/&#34;&gt;runtime, syscall: use int $0x80 to invoke syscalls on android/386&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;快速汇编指令，intel和amd专门用于系统调用的指令。&lt;/li&gt;
&lt;li&gt;vsyscall和vDSO通过动态库的方式。&lt;/li&gt;
&lt;/ol&gt;
</description>
  </item>
  
</channel>
</rss>
