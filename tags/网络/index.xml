<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>网络 on Journey-C</title>
    <link>https://journey-c.github.io/tags/%E7%BD%91%E7%BB%9C/</link>
    <description>Recent content in 网络 on Journey-C</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 21 Oct 2020 22:48:31 +0800</lastBuildDate>
    
	<atom:link href="https://journey-c.github.io/tags/%E7%BD%91%E7%BB%9C/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>长连接平滑重启</title>
      <link>https://journey-c.github.io/long-connection-smooth-restart-realization/</link>
      <pubDate>Wed, 21 Oct 2020 22:48:31 +0800</pubDate>
      
      <guid>https://journey-c.github.io/long-connection-smooth-restart-realization/</guid>
      <description>最近小编一直在做长连接相关的事情，最大的感触就是发版太痛苦，一个个踢掉连接然后发版，导致发版时长过长，操作繁琐。所以在想能不能实现优雅重启, 发版时客户端无感知。
 1.难点   如何做到不中断接收连接
  如何做到已有连接不中断
  2.解决 2.1 如何做到不中断接受连接 以下是linux源码中bind的实现(linux-1.0)
// linux-1.0/net/socket.c 536 static int sock_bind(int fd, struct sockaddr *umyaddr, int addrlen) { struct socket *sock; int i; DPRINTF((net_debug, &amp;#34;NET: sock_bind: fd = %d\n&amp;#34;, fd)); if (fd &amp;lt; 0 || fd &amp;gt;= NR_OPEN || current-&amp;gt;filp[fd] == NULL) return(-EBADF); //获取fd对应的socket结构  if (!(sock = sockfd_lookup(fd, NULL))) return(-ENOTSOCK); // 转调用bind指向的函数，下层函数(inet_bind)  if ((i = sock-&amp;gt;ops-&amp;gt;bind(sock, umyaddr, addrlen)) &amp;lt; 0) { DPRINTF((net_debug, &amp;#34;NET: sock_bind: bind failed\n&amp;#34;)); return(i); } return(0); } // linux-1.</description>
    </item>
    
  </channel>
</rss>