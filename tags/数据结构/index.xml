<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数据结构 on Journey-C</title>
    <link>https://journey-c.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
    <description>Recent content in 数据结构 on Journey-C</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 22 Oct 2020 21:58:31 +0800</lastBuildDate>
    
	<atom:link href="https://journey-c.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>红黑树</title>
      <link>https://journey-c.github.io/red-black-tree/</link>
      <pubDate>Thu, 22 Oct 2020 21:58:31 +0800</pubDate>
      
      <guid>https://journey-c.github.io/red-black-tree/</guid>
      <description>红黑树是一种自平衡二叉搜索树。二叉搜索树就是插入的时候，比当前节点小的放到左子树，大的放到右子树。这样查找的时候可以沿着树的一条路径找到想要的值，所以时间复杂度是树的深度，最坏$O(N)$，平均$O(lg^N)$。
正因为二叉搜索树由于数据的不确定性可能造成树建的不平衡，导致树过深，时间复杂度过高。所以出现了自平衡二叉搜索树像红黑树。
红黑树所有的性质和特点都是想让树尽可能的平衡。
1. 性质  每个节点或是红色，或是黑色 根结点是黑色 每个叶节点(NIL)是黑色 如果一个节点是红色，则它两个子节点必须是黑色 对每个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点  另外其他二叉树叶子结点一般为nil，红黑树为了节省内存空间，将所有叶子节点指向一个哨兵节点，哨兵节点color为BLACK，其他属性p、left、right、key为任意值，根结点的父节点也指向哨兵节点。
2. 为什么红黑树可以平衡 2.1 引理  一棵有n个内部节点的红黑树的高度至多为$2lg^{(n+1)}$
 如果可以证明上述引理，那么红黑树的查找最坏的时间复杂度也是$O(2lg^{(n+1)})$，因为在一棵高度为h的树上操作时间复杂度是$O(h)$，就是咱们要的平衡。
2.2 证明 首先证明红黑树以任意一个节点x为根的子树中至少包含$2^{bh(x)}-1$个内部节点(从节点x出发，不包含x到达一个叶子节点的任意一条简单路径上黑节点的个数成为x节点的黑高，记为$bh(x)$)。
下面用数学归纳法证明
  当高度为0时 即子树为空，满足内部节点不超过$2^{0}-1=0$的要求。
  当高度为k时 假设以x为根的子树内部节点不超过$2^{bh(x)}-1$。
  当高度为k-1时 即当前节点是x(这个x节点是高度为k时假设的那个)的儿子，黑高为$bh(x)$或$bh(x)-1$，取决于儿子是黑还是红。所以以儿子节点为根的子树至少有$2^{bh(x)-1}-1$内部节点。于是，由儿子节点推父节点x内部节点的个数不超过$(2^{bh(x)-1}-1)+(2^{bh(x)-1}-1)=(2^{bh(x)}-1)$，由此假设成立。
  现在来证明引理。设h为树的高度，根据性质4得出从根节点到叶节点的任何一条简单路径上都至少有一半节点是黑色，所以根的黑高至少时h/2。于是有
n为树的节点个数，这个公式上边证明过了。将1放到左边，然后取对数得到
由此得到结论，高度小于等于$2lg^{(n+1)}$，所以只要满足红黑树性质的n节点二叉树高度最大为$2lg^{(n+1)}$。
3. 红黑树如何实现自平衡 3.1 旋转 由于插入和删除操作会对红黑树修改，有可能会不符合红黑树的性质，所以必须通过调整节点的颜色和指针结构来重新满足性质，而调整指针结构的操作是旋转，有左旋、右旋。 下图α,β,γ代表一棵子树(可能为空)
3.1.1 左旋 上图为例，左旋就是从右边树结构变成左边树结构的操作。 当在某点例如x点做左旋时:
 以x-y这条路径当轴，逆时针旋转(左旋)，x变成y的左儿子，y到原来x的位置。 因为x变成了y的左儿子，所以要考虑y之前是否有左儿子，如果有的话就要将左儿子β在左子树中重新找位置了，之前β是在x的右边所以比x大，刚好x的右儿子旋转后是空的，所以β就放到x的右儿子的位置。就得到了左边树的结构。  3.1.2 右旋 和左旋步骤是一样的，方向相反。
3.2 插入  插入节点颜色设置为红色。 首先从根结点开始遍历，插入节点比当前节点小就去左子树，否则就去右子树，直到遍历到叶子结点，然后比较插入节点和父节点大小选择作为父节点的左儿子还是右儿子。 现在已经将节点插入了，由于插入节点颜色是红色，所以可能破坏红节点儿子只能是黑节点的性质。所以从插入节点向上遍历修复破坏性质的地方，直到完全符合性质。  3.2.1 修复 回想一下插入新节点的过程，然后对比一下可能违反什么性质。
   性质编号 描述 是否可能违反     1 每个节点或是红色，或是黑色 不会违反，除非插入第三种颜色   2 根结点是黑色 可能违反，只有树为空的时候，插入节点(红色)作为根结点   3 每个叶节点(NIL)是黑色 不会违反，插入节点不会改变叶节点的颜色，叶节点永远都是T.</description>
    </item>
    
  </channel>
</rss>