<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>源码 on Journey-C</title>
    <link>https://journey-c.github.io/tags/%E6%BA%90%E7%A0%81/</link>
    <description>Recent content in 源码 on Journey-C</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 29 Oct 2020 20:58:31 +0800</lastBuildDate>
    
	<atom:link href="https://journey-c.github.io/tags/%E6%BA%90%E7%A0%81/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>channel 源码阅读</title>
      <link>https://journey-c.github.io/channel-read/</link>
      <pubDate>Thu, 29 Oct 2020 20:58:31 +0800</pubDate>
      
      <guid>https://journey-c.github.io/channel-read/</guid>
      <description>年初的时候go语言的学习提上了日程，前一篇sync.pool阅读之后，阅读代码进度本该更快些，奈何身体被掏空，所以这篇文章断断续续一个月终于攒起来了。
 1. 简介 channel是golang中用于goroutine之间通讯的数据结构，有以下特点：
 线程安全 创建channel时返回的是指针，不需要考虑拷贝的问题 顺序通讯，写入和读出的顺序一致  2. 数据部分 源码位置go/src/runtime/chan.go
2.1 hchan channel对应的数据结构
type hchan struct { qcount uint dataqsiz uint buf unsafe.Pointer elemsize uint16 closed uint32 elemtype *_type sendx uint recvx uint recvq waitq sendq waitq // lock protects all fields in hchan, as well as several 	// fields in sudogs blocked on this channel. 	// 	// Do not change another G&amp;#39;s status while holding this lock 	// (in particular, do not ready a G), as this can deadlock 	// with stack shrinking.</description>
    </item>
    
    <item>
      <title>goroutine 源码阅读</title>
      <link>https://journey-c.github.io/golang-schedule/</link>
      <pubDate>Thu, 29 Oct 2020 20:58:31 +0800</pubDate>
      
      <guid>https://journey-c.github.io/golang-schedule/</guid>
      <description>1.数据结构 调度相关的数据结构有三个，M(线程)，P(调度器)，G(goroutine) M表示线程，P作为调度器用来帮助每个线程管理自己的goroutine，G就是golang的协程。我们可以通过runtime.GOMAXPROCS(n int)函数设置P的个数，注意P的个数并不代表M的个数，例如程序启动时runtime代码会出实话procs个P，但开始的时候只会启动一个M，就是M0和一个栈为64K(其他goroutine默认初始栈大小2K)来执行runtime代码。
那其他线程是什么时候创建的呐? 当goroutine被唤醒时，要在M上运行(恢复goroutine的上下文)，P是帮助M管理goroutine的，恢复上下文的操作也由P来完成。如果被唤醒时发现还有空闲的P，并且没有其他M在窃取goroutine(M发现本地goroutine队列和全局goroutine队列都没有goroutine的时候，会去其他线程窃取goroutine)，说明其他M都在忙，就会创建一个M让这个空闲的P帮他来管理goroutine。 总之一句话，开始的时候创建一个M，当发现调度不过来且还有空闲P没有工作就在创建新的，直到创建procs个M(procs通过runtime.GOMAXPROCS设置)
1.1 G golang 用结构体g表示goroutine
 g  type g struct { stack stack // 当前栈的范围[stack.lo, stack.hi) 	stackguard0 uintptr // 用于抢占的，一般情况值为stack.lo + StackGuard 	stackguard1 uintptr // 用于C语言的抢占 	_panic *_panic // 最内侧的panic函数 	_defer *_defer // 最外侧的defer函数 	m *m // 当前goroutine属于哪个m 	sched gobuf // 调度相关信息 	... schedlink guintptr // sched是全局的goroutine链表，schedlink表示这个goroutine在链表中的下一个goroutine的指针 	... preempt bool // 抢占标志，如果需要抢占就将preempt设置为true 	... }  gobuf gobuf保存goroutine的调度信息，当一个goroutine被调度的时，本质上就是把这个goroutine放到cpu，恢复各个寄存器的值，然后运行  type gobuf struct { sp uintptr // 栈指针 	pc uintptr // 程序计数器 	g guintptr // 当前被哪个goroutine持有 	ctxt unsafe.</description>
    </item>
    
    <item>
      <title>sync.pool 源码阅读</title>
      <link>https://journey-c.github.io/sync-pool-read/</link>
      <pubDate>Tue, 27 Oct 2020 20:58:31 +0800</pubDate>
      
      <guid>https://journey-c.github.io/sync-pool-read/</guid>
      <description>阅读项目代码的时候发现很多地方用到了golang的sync.pool，所以好奇golang的sync.pool底层实现是什么样的，有哪些优化。 本文是基于go1.13.10做讲解。
 在golang开发中sync.pool是最常用的缓存池，当一个对象被频繁创建和释放时会用到，但一般不作为连接池使用因为sync.pool中的对象随时会被释放掉，对象生命周期一般为两个GC间隔，且释放时机用户无感知。
1. 设计原理 sync.pool的操纵都是线程安全的，每个P都有自己私有的存储空间和共享的存储空间。
 GET 获取对象时，一般先在当前P的私有空间获取，如果没有，再到当前P的共享空间获取，如果还没有就窃取其他P的共享空间，如果还没有就访问上次GC遗留的对象。上述操作完成后还没有获取到，则调用New函数创建对象。 PUT 对象放回池子时，先判断当前P的私有空间是否为空，为空就放入，不为空就放入共享空间。  当GET/PUT非常频繁的时候，一般都只访问当前P的空间就可以完成操作。 GET/PUT不频繁时，即使访问到其他P的空间(有锁)，由于操作不频繁所以锁是可以接受的。
2. 数据结构 Pool是sync.Pool的核心数据结构。先了解一下该结构体的内部字段。
type Pool struct { noCopy noCopy local unsafe.Pointer // local fixed-size per-P pool, actual type is [P]poolLocal 	localSize uintptr // size of the local array  victim unsafe.Pointer // local from previous cycle 	victimSize uintptr // size of victims array  // New optionally specifies a function to generate 	// a value when Get would otherwise return nil.</description>
    </item>
    
  </channel>
</rss>