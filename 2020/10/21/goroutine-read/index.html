

<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <link rel="shortcut icon" type="image/png" href="/favicon.png"/>
    
<link rel="stylesheet" href="/libs/highlight/styles/atom-one-dark.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="journey-c" type="application/atom+xml">
</head>

<title>goroutine 源码阅读</title>

<body>
    <div class="hd">
    <ol class="breadcrumb">
        
            <li><a class="ba" href="/">首页</a></li>
        
            <li><a class="ba" href="/tags">标签</a></li>
        
            <li><a class="ba" href="/about">关于</a></li>
        
            <li><a class="ba" href="/sketch">随笔</a></li>
        
            <li><a class="ba" target="_blank" rel="noopener" href="https://github.com/journey-c">Github</a></li>
        
            <li><a class="ba" target="_blank" rel="noopener" href="https://www.cnblogs.com/wuwangchuxin0924">博客园</a></li>
        
    </ol>
    <hr class="breadcrumbhr">
</div>


<div class="toc">
    <!-- 右侧导航栏 -->
    
    	<div>
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">1.数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-G"><span class="toc-text">1.1 G</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-M"><span class="toc-text">1.2 M</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-P"><span class="toc-text">1.3 P</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-schedt"><span class="toc-text">1.4 schedt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E9%87%8D%E8%A6%81%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-text">1.5 重要的全局变量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%88%86%E6%AD%A5%E9%AA%A4%E5%89%96%E6%9E%90%E8%B0%83%E5%BA%A6%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">2.分步骤剖析调度的初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E7%BC%96%E8%AF%91"><span class="toc-text">2.1 编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E8%B0%83%E8%AF%95"><span class="toc-text">2.2 调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">2.3 初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E8%B0%83%E5%BA%A6%E5%BE%AA%E7%8E%AF"><span class="toc-text">2.4 调度循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E8%A7%A6%E5%8F%91%E8%B0%83%E5%BA%A6"><span class="toc-text">2.5 触发调度</span></a></li></ol></li></ol>
    	</div>
    
</div>

<div class="hd posts">

    
  


    
    	<a href="/"><i class="fa fa-reply replay-btn" aria-hidden="true"></i></a>
    
    <div class="post-title">
        <p>
            goroutine 源码阅读
        </p>
        <hr>
    </div>
    
    
   	<!-- tags 和 时间 -->
   	<div style="float: right">
   	    2020-10-21
   	</div>

   	
   	    <div>
   	         

<a href="/tags/Golang/">#Golang</a> <a href="/tags/源码/">#源码</a>

   	    </div>
   	
	<br>
    

    <div class="post-content">
        <h1 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1.数据结构"></a>1.数据结构</h1><p>调度相关的数据结构有三个，M(线程)，P(调度器)，G(goroutine)<br>M表示线程，P作为调度器用来帮助每个线程管理自己的goroutine，G就是golang的协程。我们可以通过runtime.GOMAXPROCS(n int)函数设置P的个数，<strong>注意</strong>P的个数并不代表M的个数，例如程序启动时runtime代码会出实话procs个P，但开始的时候只会启动一个M，就是M0和一个栈为64K(其他goroutine默认初始栈大小2K)来执行runtime代码。</p>
<a id="more"></a>

<p><strong>那其他线程是什么时候创建的呐?</strong><br>当goroutine被唤醒时，要在M上运行(恢复goroutine的上下文)，P是帮助M管理goroutine的，恢复上下文的操作也由P来完成。如果被唤醒时发现还有空闲的P，并且没有其他M在窃取goroutine(M发现本地goroutine队列和全局goroutine队列都没有goroutine的时候，会去其他线程窃取goroutine)，说明其他M都在忙，就会创建一个M让这个空闲的P帮他来管理goroutine。<br>总之一句话，开始的时候创建一个M，当发现调度不过来且还有空闲P没有工作就在创建新的，直到创建procs个M(procs通过runtime.GOMAXPROCS设置)</p>
<p><img src="/images/model.png" alt="model"></p>
<h2 id="1-1-G"><a href="#1-1-G" class="headerlink" title="1.1 G"></a>1.1 G</h2><p>golang 用结构体g表示goroutine</p>
<ul>
<li>g</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">	stack       stack   <span class="comment">// 当前栈的范围[stack.lo, stack.hi)</span></span><br><span class="line">	stackguard0 <span class="keyword">uintptr</span> <span class="comment">// 用于抢占的，一般情况值为stack.lo + StackGuard</span></span><br><span class="line">	stackguard1 <span class="keyword">uintptr</span> <span class="comment">// 用于C语言的抢占</span></span><br><span class="line">	_panic         *_panic <span class="comment">// 最内侧的panic函数</span></span><br><span class="line">	_defer         *_defer <span class="comment">// 最外侧的defer函数</span></span><br><span class="line">	m              *m      <span class="comment">// 当前goroutine属于哪个m</span></span><br><span class="line">	sched          gobuf <span class="comment">// 调度相关信息</span></span><br><span class="line">	...</span><br><span class="line">	schedlink      guintptr <span class="comment">// sched是全局的goroutine链表，schedlink表示这个goroutine在链表中的下一个goroutine的指针</span></span><br><span class="line">	...</span><br><span class="line">	preempt        <span class="keyword">bool</span>       <span class="comment">// 抢占标志，如果需要抢占就将preempt设置为true</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>gobuf<br>gobuf保存goroutine的调度信息，当一个goroutine被调度的时，本质上就是把这个goroutine放到cpu，恢复各个寄存器的值，然后运行</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> gobuf <span class="keyword">struct</span> &#123;</span><br><span class="line">	sp   <span class="keyword">uintptr</span> <span class="comment">// 栈指针</span></span><br><span class="line">	pc   <span class="keyword">uintptr</span> <span class="comment">// 程序计数器</span></span><br><span class="line">	g    guintptr <span class="comment">// 当前被哪个goroutine持有</span></span><br><span class="line">	ctxt unsafe.Pointer</span><br><span class="line">	ret  sys.Uintreg <span class="comment">// 系统调用返回值，防止系统调用后被其他goroutine抢占，所以有个地方保存返回值</span></span><br><span class="line">	lr   <span class="keyword">uintptr</span></span><br><span class="line">	bp   <span class="keyword">uintptr</span> <span class="comment">// 保存CPU的rip寄存器的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-M"><a href="#1-2-M" class="headerlink" title="1.2 M"></a>1.2 M</h2><p>golang中M表示实际操作系统的线程</p>
<ul>
<li>m</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;</span><br><span class="line">	g0      *g     <span class="comment">// g0帮M处理大小事务的goroutine，他是m中的第一个goroutine</span></span><br><span class="line">	...</span><br><span class="line">	gsignal       *g           <span class="comment">// 用于信号处理的goroutine</span></span><br><span class="line">	tls           [<span class="number">6</span>]<span class="keyword">uintptr</span>   <span class="comment">// 线程私有空间</span></span><br><span class="line">	mstartfn      <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">	curg          *g       <span class="comment">// current running goroutine</span></span><br><span class="line">	...</span><br><span class="line">	p             puintptr <span class="comment">// 当前正在运行的p(处理器)</span></span><br><span class="line">	nextp         puintptr <span class="comment">// 暂存的p</span></span><br><span class="line">	oldp          puintptr <span class="comment">// 执行系统调用之前的p</span></span><br><span class="line">	...</span><br><span class="line">	spinning      <span class="keyword">bool</span> <span class="comment">// 表示当前m没有goroutine了，正在从其他m偷取goroutine</span></span><br><span class="line">	blocked       <span class="keyword">bool</span> <span class="comment">// m is blocked on a note</span></span><br><span class="line">	...</span><br><span class="line">	park          note <span class="comment">// m没有goroutine的时候会在park上sleep，需要其他m在park中wake up这个m</span></span><br><span class="line">	alllink       *m <span class="comment">// on allm // 所有m的链表</span></span><br><span class="line">	...</span><br><span class="line">	thread        <span class="keyword">uintptr</span> <span class="comment">// thread handle</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-P"><a href="#1-3-P" class="headerlink" title="1.3 P"></a>1.3 P</h2><p>golang中P表示一个调度器，为M提供上下文环境，使得M可以执行多个goroutine</p>
<ul>
<li>p</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">	m           muintptr   <span class="comment">// 与哪个M关联(可能为空的)</span></span><br><span class="line">	...</span><br><span class="line">	runqhead <span class="keyword">uint32</span> <span class="comment">// p本地goroutine队列的头</span></span><br><span class="line">	runqtail <span class="keyword">uint32</span> <span class="comment">// p本地goroutine队列的尾</span></span><br><span class="line">	runq     [<span class="number">256</span>]guintptr <span class="comment">// 队列指针，和sync.pool中数据结构一样也是循环队列</span></span><br><span class="line">	...</span><br><span class="line">	sudogcache []*sudog <span class="comment">// sudog缓存，channel用的</span></span><br><span class="line">	sudogbuf   [<span class="number">128</span>]*sudog <span class="comment">// 也是防止false sharing</span></span><br><span class="line">	...</span><br><span class="line">	pad cpu.CacheLinePad <span class="comment">// 防止false sharing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-schedt"><a href="#1-4-schedt" class="headerlink" title="1.4 schedt"></a>1.4 schedt</h2><p>schedt结构体用来保存P的状态信息和goroutine的全局运行队列</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> schedt <span class="keyword">struct</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	lock mutex <span class="comment">// 全局锁</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 维护空闲的M</span></span><br><span class="line">	midle        muintptr <span class="comment">// 等待中的M链表</span></span><br><span class="line">	nmidle       <span class="keyword">int32</span>    <span class="comment">// 等待中的M的数量</span></span><br><span class="line">	nmidlelocked <span class="keyword">int32</span>    <span class="comment">// number of locked m&#x27;s waiting for work</span></span><br><span class="line">	mnext        <span class="keyword">int64</span>    <span class="comment">// number of m&#x27;s that have been created and next M ID</span></span><br><span class="line">	maxmcount    <span class="keyword">int32</span>    <span class="comment">// 最多创建多少个M(10000)</span></span><br><span class="line">	nmsys        <span class="keyword">int32</span>    <span class="comment">// number of system m&#x27;s not counted for deadlock</span></span><br><span class="line">	nmfreed      <span class="keyword">int64</span>    <span class="comment">// cumulative number of freed m&#x27;s</span></span><br><span class="line"></span><br><span class="line">	ngsys <span class="keyword">uint32</span> <span class="comment">// number of system goroutines; updated atomically</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 维护空闲的P</span></span><br><span class="line">	pidle      puintptr <span class="comment">// idle p&#x27;s</span></span><br><span class="line">	npidle     <span class="keyword">uint32</span></span><br><span class="line">	nmspinning <span class="keyword">uint32</span> <span class="comment">// See &quot;Worker thread parking/unparking&quot; comment in proc.go.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// goroutine的全局队列</span></span><br><span class="line">	runq     gQueue</span><br><span class="line">	runqsize <span class="keyword">int32</span></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 全局缓存已经退出的goroutine链表，下次再创建的时候直接用</span></span><br><span class="line">	<span class="comment">// Global cache of dead G&#x27;s.</span></span><br><span class="line">	gFree <span class="keyword">struct</span> &#123;</span><br><span class="line">		lock    mutex</span><br><span class="line">		stack   gList <span class="comment">// Gs with stacks</span></span><br><span class="line">		noStack gList <span class="comment">// Gs without stacks</span></span><br><span class="line">		n       <span class="keyword">int32</span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-5-重要的全局变量"><a href="#1-5-重要的全局变量" class="headerlink" title="1.5 重要的全局变量"></a>1.5 重要的全局变量</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">allgs    []*g   <span class="comment">// 保存所有的g</span></span><br><span class="line">allm     *m     <span class="comment">// 所有的m构成的一个链表，包括下面的m0</span></span><br><span class="line">allp     []*p  <span class="comment">// 保存所有的p，len(allp) == gomaxprocs</span></span><br><span class="line"></span><br><span class="line">ncpu         <span class="keyword">int32</span>  <span class="comment">// 系统中cpu核的数量，程序启动时由runtime代码初始化</span></span><br><span class="line">gomaxprocs   <span class="keyword">int32</span>  <span class="comment">// p的最大值，默认等于ncpu，但可以通过GOMAXPROCS修改</span></span><br><span class="line"></span><br><span class="line">sched     schedt    <span class="comment">// 调度器结构体对象，记录了调度器的工作状态</span></span><br><span class="line"></span><br><span class="line">m0 m        <span class="comment">// 代表进程的主线程</span></span><br><span class="line">g0  g       <span class="comment">// m0的g0，也就是m0.g0 = &amp;g0</span></span><br></pre></td></tr></table></figure>

<h1 id="2-分步骤剖析调度的初始化"><a href="#2-分步骤剖析调度的初始化" class="headerlink" title="2.分步骤剖析调度的初始化"></a>2.分步骤剖析调度的初始化</h1><p>下面是用go实现的hello world，代码里并没有关于调度的初始化，所以程序的入口并非是main.main，下面通过gdb一步步找到go是如何初始化调度的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;hello, world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-1-编译"><a href="#2-1-编译" class="headerlink" title="2.1 编译"></a>2.1 编译</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -gcflags &quot;-N -l&quot; test.go</span><br></pre></td></tr></table></figure>

<p><strong>使用OS X的同学注意，go1.11之后压缩的debug信息，OS X的同学需要同时做以下设置参考<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/52534287/debug-go-program-with-gdb-on-macos">Debug Go Program With Gdb On Macos</a></strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export GOFLAGS=&quot;-ldflags=-compressdwarf=false&quot;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-调试"><a href="#2-2-调试" class="headerlink" title="2.2 调试"></a>2.2 调试</h2><ul>
<li>利用断点可以找出目标文件的信息，在入口处打一个断点，找到程序入口在rt0_darwin_amd64.s的第8行</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜  sudo gdb test </span><br><span class="line">(gdb) info files</span><br><span class="line">Symbols from &quot;/Users/journey/workspace/src/tool/gdb/test&quot;.</span><br><span class="line">Local exec file:</span><br><span class="line">	`/Users/journey/workspace/src/tool/gdb/test&#x27;, file type mach-o-x86-64.</span><br><span class="line">	Entry point: 0x104cd00</span><br><span class="line">	0x0000000001001000 - 0x00000000010515b1 is .text</span><br><span class="line">	0x00000000010515c0 - 0x000000000108162a is __TEXT.__rodata</span><br><span class="line">	0x0000000001081640 - 0x0000000001081706 is __TEXT.__symbol_stub1</span><br><span class="line">	0x0000000001081720 - 0x0000000001081e80 is __TEXT.__typelink</span><br><span class="line">	0x0000000001081e80 - 0x0000000001081e88 is __TEXT.__itablink</span><br><span class="line">	0x0000000001081e88 - 0x0000000001081e88 is __TEXT.__gosymtab</span><br><span class="line">	0x0000000001081ea0 - 0x00000000010bfacd is __TEXT.__gopclntab</span><br><span class="line">	0x00000000010c0000 - 0x00000000010c0020 is __DATA.__go_buildinfo</span><br><span class="line">	0x00000000010c0020 - 0x00000000010c0128 is __DATA.__nl_symbol_ptr</span><br><span class="line">	0x00000000010c0140 - 0x00000000010c0d08 is __DATA.__noptrdata</span><br><span class="line">	0x00000000010c0d20 - 0x00000000010c27f0 is .data</span><br><span class="line">	0x00000000010c2800 - 0x00000000010ddc90 is .bss</span><br><span class="line">	0x00000000010ddca0 - 0x00000000010e01e8 is __DATA.__noptrbss</span><br><span class="line">(gdb) b *0x104cd00</span><br><span class="line">Breakpoint 1 at 0x104cd00: file /usr/local/go/src/runtime/rt0_darwin_amd64.s, line 8.</span><br></pre></td></tr></table></figure>

<ul>
<li>进入上面找到的文件rt0_darwin_amd64.s(不同的架构文件是不同的)</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  runtime ls rt0_*</span><br><span class="line">rt0_aix_ppc64.s       rt0_darwin_amd64.s    rt0_freebsd_arm.s     rt0_linux_arm64.s     rt0_nacl_386.s        rt0_netbsd_arm64.s    rt0_plan9_amd64.s</span><br><span class="line">rt0_android_386.s     rt0_darwin_arm.s      rt0_illumos_amd64.s   rt0_linux_mips64x.s   rt0_nacl_amd64p32.s   rt0_openbsd_386.s     rt0_plan9_arm.s</span><br><span class="line">rt0_android_amd64.s   rt0_darwin_arm64.s    rt0_js_wasm.s         rt0_linux_mipsx.s     rt0_nacl_arm.s        rt0_openbsd_amd64.s   rt0_solaris_amd64.s</span><br><span class="line">rt0_android_arm.s     rt0_dragonfly_amd64.s rt0_linux_386.s       rt0_linux_ppc64.s     rt0_netbsd_386.s      rt0_openbsd_arm.s     rt0_windows_386.s</span><br><span class="line">rt0_android_arm64.s   rt0_freebsd_386.s     rt0_linux_amd64.s     rt0_linux_ppc64le.s   rt0_netbsd_amd64.s    rt0_openbsd_arm64.s   rt0_windows_amd64.s</span><br><span class="line">rt0_darwin_386.s      rt0_freebsd_amd64.s   rt0_linux_arm.s       rt0_linux_s390x.s     rt0_netbsd_arm.s      rt0_plan9_386.s       rt0_windows_arm.s</span><br></pre></td></tr></table></figure>

<ul>
<li>打开文件go/src/runtime/rt0_darwin_amd64.s:8<br>这里没有做什么就调了函数_rt0_amd64</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TEXT _rt0_amd64_darwin(SB),NOSPLIT,$<span class="number">-8</span> <span class="comment">// 参数+返回值共8字节</span></span><br><span class="line">	JMP	_rt0_amd64(SB)</span><br></pre></td></tr></table></figure>

<ul>
<li>然后在打断点看看_rt0_amd64在哪<br>在ams_amd64.s第15行</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b _rt0_amd64</span><br><span class="line">Breakpoint 2 at 0x1049350: file /usr/local/go/src/runtime/asm_amd64.s, line 15.</span><br></pre></td></tr></table></figure>

<p>这里首先把参数放到DI，SI寄存器中，然后调用runtime.rt0_go，这就是进程初始化主要函数了<br>参数0放在DI通用寄存器<br>参数1放在SI通用寄存器<br>参数2放在DX通用寄存器<br>参数3放在CX通用寄存器</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TEXT _rt0_amd64(SB),NOSPLIT,$<span class="number">-8</span> <span class="comment">// 参数+返回值共8字节</span></span><br><span class="line">	MOVQ	<span class="number">0</span>(SP), DI	<span class="comment">// argc</span></span><br><span class="line">	LEAQ	<span class="number">8</span>(SP), SI	<span class="comment">// argv</span></span><br><span class="line">	JMP	runtime·rt0_go(SB)</span><br></pre></td></tr></table></figure>

<ul>
<li>然后跳转到runtime.rt0_go</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b runtime.rt0_go</span><br><span class="line">Breakpoint 3 at 0x1049360: file /usr/local/go/src/runtime/asm_amd64.s, line 89.</span><br></pre></td></tr></table></figure>

<h2 id="2-3-初始化"><a href="#2-3-初始化" class="headerlink" title="2.3 初始化"></a>2.3 初始化</h2><p>这个函数有点长，下面我们分段来看rt0_go这个函数</p>
<ul>
<li>初始化参数以及创建g0</li>
</ul>
<ol>
<li>首先将之前放入通用寄存器的参数放入AX，BX寄存器，然后调整栈顶指针(真SP寄存器)的位置，SP指针先减39，关于16字节向下对齐(因为CPU有一组 SSE 指令，这些指令中出现的内存地址必须是16的倍数)，然后把参数放到SP+16字节和SP+24字节处</li>
</ol>
<p><strong>golang的汇编有抽象出来的寄存器，通过是否有前缀变量区分真假寄存器，例如a+8(SP)就是golang的寄存器，8(SP)就是真的寄存器</strong></p>
<ol start="2">
<li>创建g0，并初始化g.stackgruard0，g.stackguard1以及g.stack.lo，g.stack.hi的值(实际上是分配一段内存，然后分割成小段，约定哪小段表示哪个变量)</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·rt0_go(SB),NOSPLIT,$<span class="number">0</span></span><br><span class="line">	MOVQ	DI, AX		<span class="comment">// argc</span></span><br><span class="line">	MOVQ	SI, BX		<span class="comment">// argv</span></span><br><span class="line">	SUBQ	$(<span class="number">4</span>*<span class="number">8</span>+<span class="number">7</span>), SP		<span class="comment">// 2args 2auto</span></span><br><span class="line">	ANDQ	$~<span class="number">15</span>, SP</span><br><span class="line">	MOVQ	AX, <span class="number">16</span>(SP)</span><br><span class="line">	MOVQ	BX, <span class="number">24</span>(SP)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化g0，g0就是go的第一个协程</span></span><br><span class="line">	<span class="comment">// 给g0分配栈空间大概64K</span></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	MOVQ	$runtime·g0(SB), DI</span><br><span class="line">	LEAQ	(<span class="number">-64</span>*<span class="number">1024</span>+<span class="number">104</span>)(SP), BX <span class="comment">// BX = SP - 64 * 1024 + 104</span></span><br><span class="line">	MOVQ	BX, g_stackguard0(DI) <span class="comment">// g0.g_stackguard0 = SP - 64 * 1024 + 104</span></span><br><span class="line">	MOVQ	BX, g_stackguard1(DI) <span class="comment">// g0.g_stackguard1 = SP - 64 * 1024 + 104</span></span><br><span class="line">	MOVQ	BX, (g_stack+stack_lo)(DI) <span class="comment">// g0.stack.lo = SP - 64 * 1024 + 104</span></span><br><span class="line">	MOVQ	SP, (g_stack+stack_hi)(DI) <span class="comment">// g0.stack.hi = SP</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建完g0的内存分布</p>
<p><img src="/images/stack_0.png" alt="stack_0"></p>
<p>然后略过一段CPU型号检测和CGO初始化的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li>创建m0</li>
</ul>
<ol>
<li>创建将m0.tls放入DI寄存器，然后调用runtime.settls将m0设置为线程私有变量(mac下什么也没干)，将m0与主线程绑定，然后对m0.tls进行存取操作验证是否能用，不能用就直接退出</li>
<li>绑定m0和g0的关系，m0.g0 = g0，g0.m = m0</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// 将m0与主线程绑定</span></span><br><span class="line">	LEAQ	runtime·m0+m_tls(SB), DI <span class="comment">// 将m0的thread local store成员的地址到DI</span></span><br><span class="line">	CALL	runtime·settls(SB) <span class="comment">// 调用settls设置线程本地存储(mac 下settls什么都没做，线程已经设置好本地存储了)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过往TLS存0x123在判断tls[0]是不是0x123验证TLS是否可用，如果不可用就abort</span></span><br><span class="line">	get_tls(BX)</span><br><span class="line">	MOVQ	$<span class="number">0x123</span>, g(BX)</span><br><span class="line">	MOVQ	runtime·m0+m_tls(SB), AX</span><br><span class="line">	CMPQ	AX, $<span class="number">0x123</span></span><br><span class="line">	JEQ <span class="number">2</span>(PC)</span><br><span class="line">	CALL	runtime·abort(SB)</span><br><span class="line">ok:</span><br><span class="line">	<span class="comment">// 把g0存入m0的本地存储tls[0]</span></span><br><span class="line">	get_tls(BX) <span class="comment">// 将m0.tls[0]地址放入BX</span></span><br><span class="line">	LEAQ	runtime·g0(SB), CX <span class="comment">// 将g0地址放入CX</span></span><br><span class="line">	MOVQ	CX, g(BX) <span class="comment">// m0.tls[0] = &amp;g0</span></span><br><span class="line">	LEAQ	runtime·m0(SB), AX <span class="comment">// 将m0地址放入AX</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将m0和g0建立映射关系</span></span><br><span class="line">	<span class="comment">// save m-&gt;g0 = g0</span></span><br><span class="line">	MOVQ	CX, m_g0(AX) <span class="comment">// m0.g0 = g0</span></span><br><span class="line">	<span class="comment">// save m0 to g0-&gt;m</span></span><br><span class="line">	MOVQ	AX, g_m(CX) <span class="comment">// g0.m = m0</span></span><br><span class="line"></span><br><span class="line">	CLD				<span class="comment">// convention is D is always left cleared</span></span><br><span class="line">	CALL	runtime·check(SB)</span><br></pre></td></tr></table></figure>

<p>创建完m0之后的内存分布</p>
<p><img src="/images/stack_1.png" alt="stack_1"></p>
<ul>
<li>m0和g0的关系</li>
</ul>
<ol>
<li>m0表示主线程，g0表示主线程的第一个goroutine</li>
<li>g0主要是记录主线程的栈信息，执行调度函数(schedule后边会讲)时会用，而用户goroutine有自己的栈，执行的时候会从g0栈切换到用户goroutine栈</li>
</ol>
<ul>
<li>初始化调度</li>
</ul>
<p>g0和m0都创建并初始化好了，下面就该进行调度初始化了</p>
<ol>
<li>将参数放入AX(初始化g0时将参数放入SP+16和SP+24的位置</li>
<li>runtime.args初始化参数的</li>
<li>runtime.osinit是初始化CPU核数的</li>
<li>重点看runtime.schedinit<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化m0</span></span><br><span class="line"><span class="comment">// 将argc和argv入栈</span></span><br><span class="line">MOVL	<span class="number">16</span>(SP), AX		<span class="comment">// copy argc</span></span><br><span class="line">MOVL	AX, <span class="number">0</span>(SP)</span><br><span class="line">MOVQ	<span class="number">24</span>(SP), AX		<span class="comment">// copy argv</span></span><br><span class="line">MOVQ	AX, <span class="number">8</span>(SP)</span><br><span class="line"><span class="comment">// 处理参数</span></span><br><span class="line">CALL	runtime·args(SB)</span><br><span class="line"><span class="comment">// 获取cpu的核数</span></span><br><span class="line">CALL	runtime·osinit(SB)</span><br><span class="line"><span class="comment">// 调度系统初始化</span></span><br><span class="line">CALL	runtime·schedinit(SB)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>runtime.schedinit<br>下面函数省略了调度无关的代码，大概流程:</li>
</ul>
<ol>
<li>设置最大线程数</li>
<li>根据GOMAXPROCS设置procs(P的数量)</li>
<li>调用procresizeprocs调整P的数量</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 取出g0</span></span><br><span class="line">	_g_ := getg()</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		_g_.racectx, raceprocctx0 = raceinit()</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置最大线程数</span></span><br><span class="line">	sched.maxmcount = <span class="number">10000</span></span><br><span class="line">	</span><br><span class="line">	...	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化m0, 前边已经将m0和g0的关系绑定好了</span></span><br><span class="line">	<span class="comment">// 只是检查一下各种变量，然后将m0挂到allm链表中</span></span><br><span class="line">	mcommoninit(_g_.m)</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	sched.lastpoll = <span class="keyword">uint64</span>(nanotime())</span><br><span class="line">	<span class="comment">// ncpu在osinit时已经获取</span></span><br><span class="line">	procs := ncpu</span><br><span class="line">	<span class="comment">// 如果GOMAXPROCS设置并且合法就将procs的设置为GOMAXPROCS</span></span><br><span class="line">	<span class="keyword">if</span> n, ok := atoi32(gogetenv(<span class="string">&quot;GOMAXPROCS&quot;</span>)); ok &amp;&amp; n &gt; <span class="number">0</span> &#123;</span><br><span class="line">		procs = n</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> procresize(procs) != <span class="literal">nil</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;unknown runnable goroutine during bootstrap&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>runtime.procresize</p>
</li>
<li><p>调度初始化最后一步</p>
</li>
</ul>
<ol>
<li>更新最后一次修改P数量动作的时间戳并累加花费时间</li>
<li>根据nprocs调整P的数量(加锁)<ol>
<li>nprocs &gt; 现有P数量，就扩展allp(p的全局数组)的长度为nprocs</li>
<li>nprocs &lt; 现有P数量，就缩容allp的长度为nprocs</li>
</ol>
</li>
<li>如果上一步是扩容了，就从堆中创建新P，并把P放入扩容出来的位置</li>
<li>通过g0找到m0，然后将allp[0]和m0绑定</li>
<li>如果allp缩容了，就将多余的p销毁</li>
<li>将空闲的p加入空闲链表<br>到目前为止，创建了m0，g0，和nprocs个P，但是还是没有让调度真正的跑起来</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">func procresize(nprocs int32) *p &#123;</span><br><span class="line">	old :&#x3D; gomaxprocs</span><br><span class="line">	if old &lt; 0 || nprocs &lt;&#x3D; 0 &#123;</span><br><span class="line">		throw(&quot;procresize: invalid arg&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	if trace.enabled &#123;</span><br><span class="line">		traceGomaxprocs(nprocs)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; update statistics</span><br><span class="line">	now :&#x3D; nanotime()</span><br><span class="line">	if sched.procresizetime !&#x3D; 0 &#123;</span><br><span class="line">		sched.totaltime +&#x3D; int64(old) * (now - sched.procresizetime)</span><br><span class="line">	&#125;</span><br><span class="line">	sched.procresizetime &#x3D; now</span><br><span class="line"></span><br><span class="line">	if nprocs &gt; int32(len(allp)) &#123; &#x2F;&#x2F; 初始化的len(allp) &#x3D;&#x3D; 0</span><br><span class="line">		lock(&amp;allpLock)</span><br><span class="line">		if nprocs &lt;&#x3D; int32(cap(allp)) &#123; &#x2F;&#x2F; 需要缩容</span><br><span class="line">			allp &#x3D; allp[:nprocs]</span><br><span class="line">		&#125; else &#123; &#x2F;&#x2F; 扩容</span><br><span class="line">			nallp :&#x3D; make([]*p, nprocs)</span><br><span class="line">			&#x2F;&#x2F; Copy everything up to allp&#39;s cap so we</span><br><span class="line">			&#x2F;&#x2F; never lose old allocated Ps.</span><br><span class="line">			copy(nallp, allp[:cap(allp)])</span><br><span class="line">			allp &#x3D; nallp</span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;allpLock)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for i :&#x3D; old; i &lt; nprocs; i++ &#123;</span><br><span class="line">		pp :&#x3D; allp[i]</span><br><span class="line">		if pp &#x3D;&#x3D; nil &#123;</span><br><span class="line">			pp &#x3D; new(p)</span><br><span class="line">		&#125;</span><br><span class="line">		pp.init(i)</span><br><span class="line">		atomicstorep(unsafe.Pointer(&amp;allp[i]), unsafe.Pointer(pp))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_g_ :&#x3D; getg() &#x2F;&#x2F; 获取g0</span><br><span class="line">	if _g_.m.p !&#x3D; 0 &amp;&amp; _g_.m.p.ptr().id &lt; nprocs &#123; &#x2F;&#x2F; 进程初始化时g0.m与p没有绑定，所以g0.m.p &#x3D;&#x3D; 0</span><br><span class="line">		_g_.m.p.ptr().status &#x3D; _Prunning</span><br><span class="line">		_g_.m.p.ptr().mcache.prepareForSweep()</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		if _g_.m.p !&#x3D; 0 &#123;</span><br><span class="line">			if trace.enabled &#123;</span><br><span class="line">				traceGoSched()</span><br><span class="line">				traceProcStop(_g_.m.p.ptr())</span><br><span class="line">			&#125;</span><br><span class="line">			_g_.m.p.ptr().m &#x3D; 0</span><br><span class="line">		&#125;</span><br><span class="line">		_g_.m.p &#x3D; 0</span><br><span class="line">		_g_.m.mcache &#x3D; nil</span><br><span class="line">		p :&#x3D; allp[0]</span><br><span class="line">		p.m &#x3D; 0</span><br><span class="line">		p.status &#x3D; _Pidle</span><br><span class="line">		acquirep(p) &#x2F;&#x2F; 把allp[0]和m0关联起来</span><br><span class="line">		if trace.enabled &#123;</span><br><span class="line">			traceGoStart()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 如果有需要销毁的p，就是销毁</span><br><span class="line">	for i :&#x3D; nprocs; i &lt; old; i++ &#123;</span><br><span class="line">		p :&#x3D; allp[i]</span><br><span class="line">		p.destroy()</span><br><span class="line">		&#x2F;&#x2F; can&#39;t free P itself because it can be referenced by an M in syscall</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if int32(len(allp)) !&#x3D; nprocs &#123;</span><br><span class="line">		lock(&amp;allpLock)</span><br><span class="line">		allp &#x3D; allp[:nprocs]</span><br><span class="line">		unlock(&amp;allpLock)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 将空闲p放入空闲链表</span><br><span class="line">	var runnablePs *p</span><br><span class="line">	for i :&#x3D; nprocs - 1; i &gt;&#x3D; 0; i-- &#123;</span><br><span class="line">		p :&#x3D; allp[i]</span><br><span class="line">		if _g_.m.p.ptr() &#x3D;&#x3D; p &#123; &#x2F;&#x2F; allp[0]已经和m0关联了，所以不用放入空闲链表</span><br><span class="line">			continue</span><br><span class="line">		&#125;</span><br><span class="line">		p.status &#x3D; _Pidle</span><br><span class="line">		if runqempty(p) &#123;</span><br><span class="line">			pidleput(p)</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			p.m.set(mget())</span><br><span class="line">			p.link.set(runnablePs)</span><br><span class="line">			runnablePs &#x3D; p</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	stealOrder.reset(uint32(nprocs))</span><br><span class="line">	var int32p *int32 &#x3D; &amp;gomaxprocs &#x2F;&#x2F; make compiler check that gomaxprocs is an int32</span><br><span class="line">	atomic.Store((*uint32)(unsafe.Pointer(int32p)), uint32(nprocs))</span><br><span class="line">	return runnablePs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.4 创建”第一个”goroutine</p>
<p>我们返回runtime·rt0_go接着看</p>
<ol>
<li>将runtime.main地址放入AX</li>
<li>参数AX, 0入栈(函数参数入栈由右向左)</li>
<li>然后调用runtime.newproc创建goroutine</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a new goroutine to start program</span></span><br><span class="line"><span class="comment">// 创建第一个goroutine执行runtime.main，源码里没搜到runtime.mainPC，在schedinit函数前注释里找到的runtime.mainPC就是runtime.main</span></span><br><span class="line">MOVQ	$runtime·mainPC(SB), AX		<span class="comment">// entry AX = func(runtime.main)</span></span><br><span class="line">PUSHQ	AX</span><br><span class="line">PUSHQ	$<span class="number">0</span>			<span class="comment">// arg size runtime.main没有参数所以入栈0</span></span><br><span class="line">CALL	runtime·newproc(SB)     <span class="comment">// 创建goroutine执行runtime.main(还没执行，只是将goroutine加入待运行队列)</span></span><br><span class="line">POPQ	AX                      <span class="comment">// 出栈</span></span><br><span class="line">POPQ	AX                      <span class="comment">// 出栈</span></span><br></pre></td></tr></table></figure>

<ul>
<li>newproc</li>
</ul>
<ol>
<li>首先获取参数地址</li>
<li>获取当前所在goroutine(初始化时runtime代码都在g0执行)</li>
<li>获取要执行指令地址</li>
<li>在gp的栈上执行runtime.newproc1(在g0栈上执行)</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc</span><span class="params">(siz <span class="keyword">int32</span>, fn *funcval)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取函数fn的第一个参数的位置</span></span><br><span class="line">	argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)</span><br><span class="line">	<span class="comment">// 获取当前所有goroutine ---- g0</span></span><br><span class="line">	gp := getg()</span><br><span class="line">	<span class="comment">// 获取要执行指令的位置</span></span><br><span class="line">	pc := getcallerpc()</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	systemstack是将函数切换到g0的栈上运行，初始化时本来就在g0的栈上，所以直接调用函数返回</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		newproc1(fn, (*<span class="keyword">uint8</span>)(argp), siz, gp, pc)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>newproc1函数主要的工作<br>这个函数有点长分段来看</li>
</ul>
<ol>
<li>首先获得当前所在goroutine(g0)</li>
<li>禁止抢占</li>
<li>计算参数位置</li>
<li>计算下参数是否过大</li>
<li>获取当前goroutine所在m的p，前边讲过g0对应的m是m0，m0对应的p是allp[0]</li>
<li>创建一个goroutine(先从p的缓存里找，找不到就new一个)，并且确认goroutine栈边界是初始化好的(方式p缓存里的goroutine参数没初始化)</li>
<li>计算栈顶的地址，如果有参数就将参数放到新创建的这个goroutine上</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc1</span><span class="params">(fn *funcval, argp *<span class="keyword">uint8</span>, narg <span class="keyword">int32</span>, callergp *g, callerpc <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取当前所在goroutine，初始化的是g0</span></span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> fn == <span class="literal">nil</span> &#123;</span><br><span class="line">		_g_.m.throwing = <span class="number">-1</span> <span class="comment">// do not dump full stacks</span></span><br><span class="line">		throw(<span class="string">&quot;go of nil func value&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 禁止抢占，把p固定在本地变量</span></span><br><span class="line">	acquirem() <span class="comment">// disable preemption because it can be holding p in a local var</span></span><br><span class="line">	siz := narg</span><br><span class="line">	siz = (siz + <span class="number">7</span>) &amp;^ <span class="number">7</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查一下参数是否需要空间是否过大，参数大小 和 栈大小 - (额外栈底空间(猜的)) - 返回需要的栈大小</span></span><br><span class="line">	<span class="keyword">if</span> siz &gt;= _StackMin<span class="number">-4</span>*sys.RegSize-sys.RegSize &#123;</span><br><span class="line">		throw(<span class="string">&quot;newproc: function arguments too large for new goroutine&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// _p_ = allp[0]</span></span><br><span class="line">	_p_ := _g_.m.p.ptr()</span><br><span class="line">	<span class="comment">// 从_p_的缓存中取一个g，初始化的时候没有可用的g所以newg==nil</span></span><br><span class="line">	newg := gfget(_p_)</span><br><span class="line">	<span class="keyword">if</span> newg == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 创建一个新g，栈空间2k, 并且给stack,stackguard0,stackguard1初始化</span></span><br><span class="line">		newg = malg(_StackMin)</span><br><span class="line">		<span class="comment">// 将g的状态设置为_Gdead</span></span><br><span class="line">		casgstatus(newg, _Gidle, _Gdead)</span><br><span class="line">		<span class="comment">// 将g加入allg链表</span></span><br><span class="line">		allgadd(newg) <span class="comment">// publishes with a g-&gt;status of Gdead so GC scanner doesn&#x27;t look at uninitialized stack.</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 确认刚才的初始化是否有效</span></span><br><span class="line">	<span class="keyword">if</span> newg.stack.hi == <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;newproc1: newg missing stack&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> readgstatus(newg) != _Gdead &#123;</span><br><span class="line">		throw(<span class="string">&quot;newproc1: new g is not Gdead&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略一段调整sp指针的函数，并且如果有参数就将参数放入new goroutine的栈中</span></span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p>设置各个寄存器的值(在cpu上恢复上下文时使用)<br>    1) 清理sched<br>    2) 设置栈顶置针位置<br>    3) 设置pc寄存器值(goexit函数第二条指令，常理应该是goroutine本身函数的第一条指令，这个妙用后边说)<br>    4) 设置goroutine地址<br>    5) 调用gostartcallfn，参数是sched和goroutine的参数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清理sched(各参数清零)</span></span><br><span class="line">memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))</span><br><span class="line"><span class="comment">// 设置sched, 在CPU上运行的相关参数</span></span><br><span class="line">newg.sched.sp = sp</span><br><span class="line">newg.stktopsp = sp</span><br><span class="line"><span class="comment">// 设置pc，被调度时第一条指令的位置，将pc设置为goexit函数一个偏移量的位置(goexit函数第二条指令)</span></span><br><span class="line"><span class="comment">// 这里把pc设置为goexit函数的第二条指令的作用就是，伪装成goexit函数调用的fn函数，当fn执行完跳回goexit函数继续做退出需要的操作</span></span><br><span class="line">newg.sched.pc = funcPC(goexit) + sys.PCQuantum <span class="comment">// +PCQuantum so that previous instruction is in same function</span></span><br><span class="line">newg.sched.g = guintptr(unsafe.Pointer(newg))</span><br><span class="line">gostartcallfn(&amp;newg.sched, fn)</span><br></pre></td></tr></table></figure>

<p>判断一下goroutine的函数是否为空，然后调用gostartcall</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gostartcallfn</span><span class="params">(gobuf *gobuf, fv *funcval)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> fn unsafe.Pointer</span><br><span class="line">	<span class="keyword">if</span> fv != <span class="literal">nil</span> &#123;</span><br><span class="line">		fn = unsafe.Pointer(fv.fn)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fn = unsafe.Pointer(funcPC(nilfunc))</span><br><span class="line">	&#125;</span><br><span class="line">	gostartcall(gobuf, fn, unsafe.Pointer(fv))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>获取sp，现在新goroutine的栈上之后本身的函数，sp指向函数的第一个参数</li>
<li>将sp指向pc里面的指令地址，也就是goexit的第二条指令，然后重新设置新goroutinesp地址</li>
<li>这时候pc才指向goroutine自己的函数</li>
</ol>
<p>gostartcall的主要作用就是将goexit入栈，然后设置goroutine的pc指向自身函数，伪装成是goexit调用的自身函数，当自身函数执行完时返回goexit清理线程，大概就是下面这样</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	goroutine自身函数()</span><br><span class="line">	清理现场()	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gostartcall</span><span class="params">(buf *gobuf, fn, ctxt unsafe.Pointer)</span></span> &#123;</span><br><span class="line">	sp := buf.sp</span><br><span class="line">	<span class="keyword">if</span> sys.RegSize &gt; sys.PtrSize &#123;</span><br><span class="line">		sp -= sys.PtrSize</span><br><span class="line">		*(*<span class="keyword">uintptr</span>)(unsafe.Pointer(sp)) = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 预留返回值空间</span></span><br><span class="line">	sp -= sys.PtrSize</span><br><span class="line">	<span class="comment">// sp指向pc指令的位置，前边已经将goexit第二条指令的地址放入pc</span></span><br><span class="line">	*(*<span class="keyword">uintptr</span>)(unsafe.Pointer(sp)) = buf.pc </span><br><span class="line">	<span class="comment">// 然后设置sp</span></span><br><span class="line">	buf.sp = sp</span><br><span class="line">	<span class="comment">// 这时候的pc才是goroutine的函数</span></span><br><span class="line">	buf.pc = <span class="keyword">uintptr</span>(fn)</span><br><span class="line">	buf.ctxt = ctxt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再回到newproc函数，剩下的就是设置goroutine的状态，然后把goroutine放入p的待执行队列中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">	newg.gopc = callerpc <span class="comment">// 用于traceback</span></span><br><span class="line">	newg.ancestors = saveAncestors(callergp)</span><br><span class="line">	<span class="comment">// newg的函数从哪里开始执行依赖于sched.pc 不依赖于startpc</span></span><br><span class="line">	newg.startpc = fn.fn</span><br><span class="line">	<span class="keyword">if</span> _g_.m.curg != <span class="literal">nil</span> &#123;</span><br><span class="line">		newg.labels = _g_.m.curg.labels</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> isSystemGoroutine(newg, <span class="literal">false</span>) &#123;</span><br><span class="line">		atomic.Xadd(&amp;sched.ngsys, +<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	newg.gcscanvalid = <span class="literal">false</span></span><br><span class="line">	<span class="comment">// 设置newg状态为_Grunnable, 到这里newg就可以运行了</span></span><br><span class="line">	casgstatus(newg, _Gdead, _Grunnable)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _p_.goidcache == _p_.goidcacheend &#123;</span><br><span class="line">		_p_.goidcache = atomic.Xadd64(&amp;sched.goidgen, _GoidCacheBatch)</span><br><span class="line">		_p_.goidcache -= _GoidCacheBatch - <span class="number">1</span></span><br><span class="line">		_p_.goidcacheend = _p_.goidcache + _GoidCacheBatch</span><br><span class="line">	&#125;</span><br><span class="line">	newg.goid = <span class="keyword">int64</span>(_p_.goidcache)</span><br><span class="line">	_p_.goidcache++</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		newg.racectx = racegostart(callerpc)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGoCreate(newg, newg.startpc)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将newg加入p的待运行队列</span></span><br><span class="line">	runqput(_p_, newg, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;sched.npidle) != <span class="number">0</span> &amp;&amp; atomic.Load(&amp;sched.nmspinning) == <span class="number">0</span> &amp;&amp; mainStarted &#123;</span><br><span class="line">		wakep()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 取消m的固定</span></span><br><span class="line">	releasem(_g_.m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下创建第一个goroutine执行runtime.main的过程(只是创建啊，整个调度这时候还是没有跑起来)<br><img src="/images/creat_goroutine_main.png" alt="create_goroutine_main"></p>
<h2 id="2-4-调度循环"><a href="#2-4-调度循环" class="headerlink" title="2.4 调度循环"></a>2.4 调度循环</h2><p>我们再返回runtime·rt0_go继续看，总结一下到目前为止已经准备好的事情</p>
<ol>
<li>将m0与主线程绑定了(将m0结构体设为主线程的私有变量)</li>
<li>创建了g0，并且与m0绑定</li>
<li>创建了procs个p并且初始化，将allp[0]与m0绑定，形成初步的GMP模型(g0,m0,p0)</li>
<li>创建了一个执行runtime.main(不是代码里的main.main，runtime.main会做加载init函数等操作然后调用main.main)的goroutine并且放入了p0的待运行队列</li>
</ol>
<p>接下来就是调度循环了，调用runtime.mstart，这个函数就是调度循环，除非程序退出否则永远阻塞住</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start this M</span></span><br><span class="line"><span class="comment">// 运行runtime.mstart这个函数会阻塞住，运行结束的时候就是程序退出的时候</span></span><br><span class="line">CALL	runtime·mstart(SB)</span><br><span class="line"></span><br><span class="line">CALL	runtime·abort(SB)	<span class="comment">// mstart should never return</span></span><br><span class="line">RET</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prevent dead-code elimination of debugCallV1, which is</span></span><br><span class="line"><span class="comment">// intended to be called by debuggers.</span></span><br><span class="line">MOVQ	$runtime·debugCallV1(SB), AX</span><br><span class="line">RET</span><br></pre></td></tr></table></figure>

<ul>
<li>runtime.mstart</li>
</ul>
<ol>
<li>获取了当前所在goroutine(初始化时代码都是在g0上执行的)</li>
<li>初始化栈保护</li>
<li>调用mstart1<br>go/src/runtime/proc.go, line 1146<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func mstart() &#123;</span><br><span class="line">	_g_ :&#x3D; getg() &#x2F;&#x2F; 获取g0</span><br><span class="line"></span><br><span class="line">	osStack :&#x3D; _g_.stack.lo &#x3D;&#x3D; 0 &#x2F;&#x2F; g0.stack.lo在前边已经初始化过了，所以osStack &#x3D; false</span><br><span class="line">	if osStack &#123;</span><br><span class="line">		size :&#x3D; _g_.stack.hi</span><br><span class="line">		if size &#x3D;&#x3D; 0 &#123;</span><br><span class="line">			size &#x3D; 8192 * sys.StackGuardMultiplier</span><br><span class="line">		&#125;</span><br><span class="line">		_g_.stack.hi &#x3D; uintptr(noescape(unsafe.Pointer(&amp;size)))</span><br><span class="line">		_g_.stack.lo &#x3D; _g_.stack.hi - size + 1024</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; 初始化栈保护</span><br><span class="line">	_g_.stackguard0 &#x3D; _g_.stack.lo + _StackGuard</span><br><span class="line">	_g_.stackguard1 &#x3D; _g_.stackguard0</span><br><span class="line">	&#x2F;&#x2F; 开始m0开始运行</span><br><span class="line">	mstart1()</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Exit this thread.</span><br><span class="line">	if GOOS &#x3D;&#x3D; &quot;windows&quot; || GOOS &#x3D;&#x3D; &quot;solaris&quot; || GOOS &#x3D;&#x3D; &quot;illumos&quot; || GOOS &#x3D;&#x3D; &quot;plan9&quot; || GOOS &#x3D;&#x3D; &quot;darwin&quot; || GOOS &#x3D;&#x3D; &quot;aix&quot; &#123;</span><br><span class="line">		osStack &#x3D; true</span><br><span class="line">	&#125;</span><br><span class="line">	mexit(osStack)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>runtime.mstart1</li>
</ul>
<ol>
<li>保存g0的指令指针和栈指针，保存这两个值是理解调度循环的关键，mstart1执行完之后，g0继续执行指令，不会再返回来了，保存了指令和栈指针之后，g0要继续执行指令的时候，就会又从上面开始执行</li>
<li>做一些初始化工作</li>
<li>调用schedule开始调度<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">func mstart1() &#123;</span><br><span class="line">	&#x2F;&#x2F; 获取当前goroutine g0</span><br><span class="line">	_g_ :&#x3D; getg()</span><br><span class="line"></span><br><span class="line">	if _g_ !&#x3D; _g_.m.g0 &#123;</span><br><span class="line">		throw(&quot;bad runtime·mstart&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; save函数保存了g0再次运行时(循环调度下一次回头)调度相关信息</span><br><span class="line">	save(getcallerpc(), getcallersp())</span><br><span class="line">	&#x2F;&#x2F; asminit</span><br><span class="line">	asminit()</span><br><span class="line">	&#x2F;&#x2F; 信号相关初始化</span><br><span class="line">	minit()</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 初始化时m &#x3D;&#x3D; m0，mstartm0也是信号相关的初始化</span><br><span class="line">	if _g_.m &#x3D;&#x3D; &amp;m0 &#123;</span><br><span class="line">		mstartm0()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 初始化时fn &#x3D;&#x3D; ni</span><br><span class="line">	if fn :&#x3D; _g_.m.mstartfn; fn !&#x3D; nil &#123;</span><br><span class="line">		fn()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if _g_.m !&#x3D; &amp;m0 &#123;</span><br><span class="line">		acquirep(_g_.m.nextp.ptr())</span><br><span class="line">		_g_.m.nextp &#x3D; 0</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; 开始调度</span><br><span class="line">	schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>runtime.schedule</li>
</ul>
<p>调度开始了，m要找gorutine放到cpu上执行了</p>
<ol>
<li>每调度61次(具体为啥是61有待思考)，就从全局的goroutine列表中选goroutine</li>
<li>如果上一步没找到，就从m对应的p的缓存里找</li>
<li>如果上一步还没有找到，就调findrunnable从其他线程窃取goroutine，如果发现有就窃取一半放到自己的p缓存中，如果都没有就说明真的没有待运行的goroutine了，就陷入睡眠一直阻塞在findrunnable函数，等待被唤醒</li>
<li>直到有goroutine需要执行了，就调用execute执行goroutine</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获得g0</span></span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _g_.m.locks != <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;schedule: holding locks&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _g_.m.lockedg != <span class="number">0</span> &#123;</span><br><span class="line">		stoplockedm()</span><br><span class="line">		execute(_g_.m.lockedg.ptr(), <span class="literal">false</span>) <span class="comment">// Never returns.</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _g_.m.incgo &#123;</span><br><span class="line">		throw(<span class="string">&quot;schedule: in cgo&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">	<span class="comment">// 等待gc</span></span><br><span class="line">	<span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">		gcstopm()</span><br><span class="line">		<span class="keyword">goto</span> top</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _g_.m.p.ptr().runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">		runSafePointFn()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> gp *g</span><br><span class="line">	<span class="keyword">var</span> inheritTime <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	tryWakeP := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">if</span> trace.enabled || trace.shutdown &#123;</span><br><span class="line">		gp = traceReader()</span><br><span class="line">		<span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">			casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">			traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">			tryWakeP = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> gp == <span class="literal">nil</span> &amp;&amp; gcBlackenEnabled != <span class="number">0</span> &#123;</span><br><span class="line">		gp = gcController.findRunnableGCWorker(_g_.m.p.ptr())</span><br><span class="line">		tryWakeP = tryWakeP || gp != <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 先从全局队列中获取，每61次调度都会从全局队列中获取goroutine</span></span><br><span class="line">	<span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> _g_.m.p.ptr().schedtick%<span class="number">61</span> == <span class="number">0</span> &amp;&amp; sched.runqsize &gt; <span class="number">0</span> &#123;</span><br><span class="line">			lock(&amp;sched.lock)</span><br><span class="line">			gp = globrunqget(_g_.m.p.ptr(), <span class="number">1</span>)</span><br><span class="line">			unlock(&amp;sched.lock)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果还空就从本地队列中获取</span></span><br><span class="line">	<span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">		gp, inheritTime = runqget(_g_.m.p.ptr())</span><br><span class="line">		<span class="keyword">if</span> gp != <span class="literal">nil</span> &amp;&amp; _g_.m.spinning &#123;</span><br><span class="line">			throw(<span class="string">&quot;schedule: spinning with local work&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果本地也没有就调用findrunnable从其他线程偷一个过来，直到偷过来在运行</span></span><br><span class="line">	<span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">		gp, inheritTime = findrunnable() <span class="comment">// blocks until work is available</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">		resetspinning()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> sched.disable.user &amp;&amp; !schedEnabled(gp) &#123;</span><br><span class="line">		lock(&amp;sched.lock)</span><br><span class="line">		<span class="keyword">if</span> schedEnabled(gp) &#123;</span><br><span class="line">			unlock(&amp;sched.lock)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			sched.disable.runnable.pushBack(gp)</span><br><span class="line">			sched.disable.n++</span><br><span class="line">			unlock(&amp;sched.lock)</span><br><span class="line">			<span class="keyword">goto</span> top</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> tryWakeP &#123;</span><br><span class="line">		<span class="keyword">if</span> atomic.Load(&amp;sched.npidle) != <span class="number">0</span> &amp;&amp; atomic.Load(&amp;sched.nmspinning) == <span class="number">0</span> &#123;</span><br><span class="line">			wakep()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> gp.lockedm != <span class="number">0</span> &#123;</span><br><span class="line">		startlockedm(gp)</span><br><span class="line">		<span class="keyword">goto</span> top</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 执行这个goroutine</span></span><br><span class="line">	execute(gp, inheritTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-5-触发调度"><a href="#2-5-触发调度" class="headerlink" title="2.5 触发调度"></a>2.5 触发调度</h2><p>触发调度地方大致有:</p>
<ol>
<li>主动挂起</li>
<li>系统调用</li>
<li>协作式调度</li>
<li>正常退出</li>
</ol>
<ul>
<li><p>proc.go:1208 runtime.mstart1(调度开始)</p>
</li>
<li><p>主动挂起</p>
</li>
<li><p>proc.go:2610 runtime.park_m<br>在上一章内容里讲过<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuwangchuxin0924/p/13022386.html">golang channel源码阅读</a>，当goroutine接收一个channel为空且为阻塞的时候，goroutine会调用goparkunlock使goroutine陷入睡眠，等待send端调用goready函数唤醒函数，主动挂起就是这种情况，当goroutine由于某些条件在等待时，就会主动挂起，不放回待运行队列，等待被唤醒</p>
</li>
</ul>
<p>各种阻塞条件 -&gt; runtime.gopark() -&gt; runtime.park_m() -&gt; runtime.schedule</p>
<ol>
<li>获取当前所在m，并且固定m</li>
<li>获取当前程序所在goroutine</li>
<li>设置锁状态以及阻塞原因</li>
<li>调用runtime.park_m挂起goroutine</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gopark</span><span class="params">(unlockf <span class="keyword">func</span>(*g, unsafe.Pointer)</span> <span class="title">bool</span>, <span class="title">lock</span> <span class="title">unsafe</span>.<span class="title">Pointer</span>, <span class="title">reason</span> <span class="title">waitReason</span>, <span class="title">traceEv</span> <span class="title">byte</span>, <span class="title">traceskip</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> reason != waitReasonSleep &#123;</span><br><span class="line">		checkTimeouts() <span class="comment">// timeouts may expire while two goroutines keep the scheduler busy</span></span><br><span class="line">	&#125;</span><br><span class="line">	mp := acquirem()</span><br><span class="line">	gp := mp.curg</span><br><span class="line">	status := readgstatus(gp)</span><br><span class="line">	<span class="keyword">if</span> status != _Grunning &amp;&amp; status != _Gscanrunning &#123;</span><br><span class="line">		throw(<span class="string">&quot;gopark: bad g status&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	mp.waitlock = lock</span><br><span class="line">	mp.waitunlockf = unlockf</span><br><span class="line">	gp.waitreason = reason</span><br><span class="line">	mp.waittraceev = traceEv</span><br><span class="line">	mp.waittraceskip = traceskip</span><br><span class="line">	releasem(mp)</span><br><span class="line">	<span class="comment">// can&#x27;t do anything that might move the G between Ms here.</span></span><br><span class="line">	mcall(park_m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>获取当前goroutine</li>
<li>将goroutine状态设置为Gwaiting</li>
<li>重新调度</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">park_m</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGoPark(_g_.m.waittraceev, _g_.m.waittraceskip)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	casgstatus(gp, _Grunning, _Gwaiting)</span><br><span class="line">	dropg()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> fn := _g_.m.waitunlockf; fn != <span class="literal">nil</span> &#123;</span><br><span class="line">		ok := fn(gp, _g_.m.waitlock)</span><br><span class="line">		_g_.m.waitunlockf = <span class="literal">nil</span></span><br><span class="line">		_g_.m.waitlock = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">				traceGoUnpark(gp, <span class="number">2</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">			execute(gp, <span class="literal">true</span>) <span class="comment">// Schedule it back, never returns.</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>协作式调度</p>
</li>
<li><p>proc.go:2625 runtime.goschedImpl(协作式调度)</p>
</li>
</ul>
<ol>
<li>主动让出cpu，这个情况不会挂起goroutine，而是放回队列，等待下次调度，这个函数(GoSched)被暴露出去，可以调用，例如，线上有这种情况，写log是异步的，但由于机器磁盘老旧性能不佳，所以当log goroutine运行时还是会过多的占用cpu，这时候可以调用GoSched适当降低当前goroutine优先级</li>
</ol>
<p>runtime.Gosched -&gt; runtime.gosched_m -&gt; runtime.goschedImpl runtime.schedule</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Gosched continuation on g0.</span><br><span class="line">func gosched_m(gp *g) &#123;</span><br><span class="line">	if trace.enabled &#123;</span><br><span class="line">		traceGoSched()</span><br><span class="line">	&#125;</span><br><span class="line">	goschedImpl(gp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>调度保护，当调度器发现goroutine处于禁止的状态时就会主动调度让出cpu</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// goschedguarded is a forbidden-states-avoided version of gosched_m</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goschedguarded_m</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> gp.m.locks != <span class="number">0</span> || gp.m.mallocing != <span class="number">0</span> || gp.m.preemptoff != <span class="string">&quot;&quot;</span> || gp.m.p.ptr().status != _Prunning &#123;</span><br><span class="line">		gogo(&amp;gp.sched) <span class="comment">// never return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGoSched()</span><br><span class="line">	&#125;</span><br><span class="line">	goschedImpl(gp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>发生抢占，例如当一个goroutine运行时间过长但不像等待channel那样阻塞，一直有事情做时，其他goroutine可能会抢占cpu</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gopreempt_m</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGoPreempt()</span><br><span class="line">	&#125;</span><br><span class="line">	goschedImpl(gp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goschedImpl</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">	status := readgstatus(gp)</span><br><span class="line">	<span class="keyword">if</span> status&amp;^_Gscan != _Grunning &#123;</span><br><span class="line">		dumpgstatus(gp)</span><br><span class="line">		throw(<span class="string">&quot;bad g status&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	casgstatus(gp, _Grunning, _Grunnable)</span><br><span class="line">	dropg()</span><br><span class="line">	lock(&amp;sched.lock)</span><br><span class="line">	globrunqput(gp)</span><br><span class="line">	unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">	schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>非main goroutine结束</p>
</li>
<li><p>proc.go:2704,2727 runtime.goexit0(goroutine正常执行完)<br>非main goroutine结束后会继续调度，这个是正常继续下一次调度不做过多介绍</p>
</li>
<li><p>系统调用</p>
</li>
<li><p>proc.go:3141 runtime.exitsyscall0(系统调用)</p>
</li>
</ul>
<p>runtime·exitsyscall -&gt; runtime·exitsyscall0 -&gt; runtime.schedule</p>
<p>我们来看下系统调用的过程</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">syscall_syscall</span><span class="params">(fn, a1, a2, a3 <span class="keyword">uintptr</span>)</span> <span class="params">(r1, r2, err <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">	entersyscall()</span><br><span class="line">	libcCall(unsafe.Pointer(funcPC(syscall)), unsafe.Pointer(&amp;fn))</span><br><span class="line">	exitsyscall()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">syscall</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>首先会调用runtime.entersyscall获取当前的指令位置和栈指针，然后调用reentersyscall做goroutine进入系统调用之前的准备</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">entersyscall</span><span class="params">()</span></span> &#123;</span><br><span class="line">	reentersyscall(getcallerpc(), getcallersp())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>禁止线程抢占防止出现栈不一致的情况</li>
<li>保证当前函数不会触发栈调整(golang进程的栈初始2k，然后动态调整)</li>
<li>设置goroutine状态为Gsyscall</li>
<li>将goroutine的P暂时和M分离，并且设置P状态为Psyscall</li>
<li>释放锁</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reentersyscall</span><span class="params">(pc, sp <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获得当前goroutine</span></span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	_g_.m.locks++</span><br><span class="line"></span><br><span class="line">	_g_.stackguard0 = stackPreempt</span><br><span class="line">	_g_.throwsplit = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Leave SP around for GC and traceback.</span></span><br><span class="line">	save(pc, sp)</span><br><span class="line">	_g_.syscallsp = sp</span><br><span class="line">	_g_.syscallpc = pc</span><br><span class="line">	casgstatus(_g_, _Grunning, _Gsyscall)</span><br><span class="line">	<span class="keyword">if</span> _g_.syscallsp &lt; _g_.stack.lo || _g_.stack.hi &lt; _g_.syscallsp &#123;</span><br><span class="line">		systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;entersyscall inconsistent &quot;</span>, hex(_g_.syscallsp), <span class="string">&quot; [&quot;</span>, hex(_g_.stack.lo), <span class="string">&quot;,&quot;</span>, hex(_g_.stack.hi), <span class="string">&quot;]\n&quot;</span>)</span><br><span class="line">			throw(<span class="string">&quot;entersyscall&quot;</span>)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		systemstack(traceGoSysCall)</span><br><span class="line">		save(pc, sp)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;sched.sysmonwait) != <span class="number">0</span> &#123;</span><br><span class="line">		systemstack(entersyscall_sysmon)</span><br><span class="line">		save(pc, sp)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _g_.m.p.ptr().runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">		systemstack(runSafePointFn)</span><br><span class="line">		save(pc, sp)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_g_.m.syscalltick = _g_.m.p.ptr().syscalltick</span><br><span class="line">	_g_.sysblocktraced = <span class="literal">true</span></span><br><span class="line">	_g_.m.mcache = <span class="literal">nil</span></span><br><span class="line">	pp := _g_.m.p.ptr()</span><br><span class="line">	pp.m = <span class="number">0</span></span><br><span class="line">	_g_.m.oldp.set(pp)</span><br><span class="line">	_g_.m.p = <span class="number">0</span></span><br><span class="line">	atomic.Store(&amp;pp.status, _Psyscall)</span><br><span class="line">	<span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">		systemstack(entersyscall_gcwait)</span><br><span class="line">		save(pc, sp)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_g_.m.locks--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就进入系统调用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...</span><br></pre></td></tr></table></figure>

<ol>
<li>获得goroutine</li>
<li>线程加锁</li>
<li>调exitsyscallfast替当前goroutine找一个P<ol>
<li>如果原P处于Psyscall就让这个P接管，否则的话进行2)</li>
<li>否则的话就找空闲的P，有的话就调用exitsyscall0继续调度，否则的话进行3)</li>
<li>将goroutine设置为Grunning，加入全局队列，调用Gosched()继续调度<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exitsyscall</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	_g_.m.locks++ <span class="comment">// see comment in entersyscall</span></span><br><span class="line">	<span class="keyword">if</span> getcallersp() &gt; _g_.syscallsp &#123;</span><br><span class="line">		throw(<span class="string">&quot;exitsyscall: syscall frame is no longer valid&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_g_.waitsince = <span class="number">0</span></span><br><span class="line">	oldp := _g_.m.oldp.ptr()</span><br><span class="line">	_g_.m.oldp = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> exitsyscallfast(oldp) &#123;</span><br><span class="line">		<span class="keyword">if</span> _g_.m.mcache == <span class="literal">nil</span> &#123;</span><br><span class="line">			throw(<span class="string">&quot;lost mcache&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">			<span class="keyword">if</span> oldp != _g_.m.p.ptr() || _g_.m.syscalltick != _g_.m.p.ptr().syscalltick &#123;</span><br><span class="line">				systemstack(traceGoStart)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// There&#x27;s a cpu for us, so we can run.</span></span><br><span class="line">		_g_.m.p.ptr().syscalltick++</span><br><span class="line">		<span class="comment">// We need to cas the status and scan before resuming...</span></span><br><span class="line">		casgstatus(_g_, _Gsyscall, _Grunning)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Garbage collector isn&#x27;t running (since we are),</span></span><br><span class="line">		<span class="comment">// so okay to clear syscallsp.</span></span><br><span class="line">		_g_.syscallsp = <span class="number">0</span></span><br><span class="line">		_g_.m.locks--</span><br><span class="line">		<span class="keyword">if</span> _g_.preempt &#123;</span><br><span class="line">			<span class="comment">// restore the preemption request in case we&#x27;ve cleared it in newstack</span></span><br><span class="line">			_g_.stackguard0 = stackPreempt</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// otherwise restore the real _StackGuard, we&#x27;ve spoiled it in entersyscall/entersyscallblock</span></span><br><span class="line">			_g_.stackguard0 = _g_.stack.lo + _StackGuard</span><br><span class="line">		&#125;</span><br><span class="line">		_g_.throwsplit = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> sched.disable.user &amp;&amp; !schedEnabled(_g_) &#123;</span><br><span class="line">			<span class="comment">// Scheduling of this goroutine is disabled.</span></span><br><span class="line">			Gosched()</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_g_.sysexitticks = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		<span class="comment">// Wait till traceGoSysBlock event is emitted.</span></span><br><span class="line">		<span class="comment">// This ensures consistency of the trace (the goroutine is started after it is blocked).</span></span><br><span class="line">		<span class="keyword">for</span> oldp != <span class="literal">nil</span> &amp;&amp; oldp.syscalltick == _g_.m.syscalltick &#123;</span><br><span class="line">			osyield()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// We can&#x27;t trace syscall exit right now because we don&#x27;t have a P.</span></span><br><span class="line">		<span class="comment">// Tracing code can invoke write barriers that cannot run without a P.</span></span><br><span class="line">		<span class="comment">// So instead we remember the syscall exit time and emit the event</span></span><br><span class="line">		<span class="comment">// in execute when we have a P.</span></span><br><span class="line">		_g_.sysexitticks = cputicks()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_g_.m.locks--</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Call the scheduler.</span></span><br><span class="line">	mcall(exitsyscall0)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _g_.m.mcache == <span class="literal">nil</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;lost mcache&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Scheduler returned, so we&#x27;re allowed to run now.</span></span><br><span class="line">	<span class="comment">// Delete the syscallsp information that we left for</span></span><br><span class="line">	<span class="comment">// the garbage collector during the system call.</span></span><br><span class="line">	<span class="comment">// Must wait until now because until gosched returns</span></span><br><span class="line">	<span class="comment">// we don&#x27;t know for sure that the garbage collector</span></span><br><span class="line">	<span class="comment">// is not running.</span></span><br><span class="line">	_g_.syscallsp = <span class="number">0</span></span><br><span class="line">	_g_.m.p.ptr().syscalltick++</span><br><span class="line">	_g_.throwsplit = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/abozhang/p/10766628.html">参考资料go语言调度器源代码情景分析</a></p>

    </div>

    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
	var gitalk = new Gitalk({
    		clientID: 'a60f22cd3c5d7e6aafa8',
    		clientSecret: 'db8f7c66f2e8e20275173155975b749870291c5b',
    		repo: 'journey-c.github.io',
    		owner: 'journey-c',
    		admin: ['journey-c'],
    		id: 'goroutine 源码阅读',
    		distractionFreeMode: true
  	});
  	gitalk.render('gitalk-container');
</script>

    
</div>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-S162K82BSE"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-S162K82BSE');
</script>

    <div class="footer" id="footer">
    <p>Copyright © 2020-<script>document.write(new Date().getFullYear())</script> <a class="flink" target="_blank" rel="noopener" href="https://github.com/journey-c">Journey-C</a>. </p>
</div>


<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>


<script src="/js/js.js"></script>


<div id="totop" style="position:fixed;bottom:150px;right:50px;cursor: pointer;">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<script src="/js/totop.js"></script>

<style type="text/css">
.v * {
    color: #698fca;
}

.v .vlist .vcard .vhead .vsys {
    color: #3a3e4a;
}

.v .vlist .vcard .vh .vmeta .vat {
    color: #638fd5;
}

.v .vlist .vcard .vhead .vnick {
    color: #6ba1ff;
}

.v a {
    color: #8696b1;
}

.v .vlist .vcard .vhead .vnick:hover {
    color: #669bfc;
}
</style>

</body>

</html>
