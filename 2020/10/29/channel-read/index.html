

<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <link rel="shortcut icon" type="image/png" href="/favicon.png"/>
    
<link rel="stylesheet" href="/libs/highlight/styles/atom-one-dark.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="journey-c" type="application/atom+xml">
</head>

<title>channel 源码阅读</title>

<body>
    <div class="hd">
    <ol class="breadcrumb">
        
            <li><a class="ba" href="/">首页</a></li>
        
            <li><a class="ba" href="/about">关于</a></li>
        
            <li><a class="ba" href="/sketch">随笔</a></li>
        
            <li><a class="ba" target="_blank" rel="noopener" href="https://github.com/journey-c">Github</a></li>
        
            <li><a class="ba" target="_blank" rel="noopener" href="https://www.cnblogs.com/wuwangchuxin0924">博客园</a></li>
        
    </ol>
    <hr class="breadcrumbhr">
</div>


<div class="toc">
    <!-- 右侧导航栏 -->
    
    	<div>
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B"><span class="toc-text">1. 简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E9%83%A8%E5%88%86"><span class="toc-text">2. 数据部分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-hchan"><span class="toc-text">2.1  hchan</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E5%8F%82%E6%95%B0%E6%84%8F%E4%B9%89"><span class="toc-text">2.1.1 参数意义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-waitq"><span class="toc-text">2.2 waitq</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E5%8F%82%E6%95%B0%E6%84%8F%E4%B9%89"><span class="toc-text">2.2.1 参数意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E5%87%BD%E6%95%B0"><span class="toc-text">2.2.2 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-1-enqueue"><span class="toc-text">2.2.2.1 enqueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-2-dequeue"><span class="toc-text">2.2.2.2 dequeue</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-sudog"><span class="toc-text">2.3 sudog</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E5%88%9B%E5%BB%BAsudog%E2%80%94%E2%80%94acquireSudog"><span class="toc-text">2.3.1 创建sudog——acquireSudog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E9%94%80%E6%AF%81sudog%E2%80%94%E2%80%94releaseSudog"><span class="toc-text">2.3.2 销毁sudog——releaseSudog</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-text">3. 实现细节</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%88%9B%E5%BB%BAchannel"><span class="toc-text">3.1 创建channel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-makechan64"><span class="toc-text">3.1.1 makechan64</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-makechan"><span class="toc-text">3.1.2 makechan</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%8F%91%E9%80%81"><span class="toc-text">3.2 发送</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-chansend"><span class="toc-text">3.2.1 chansend</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-1-racereadpc"><span class="toc-text">3.2.1.1 racereadpc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-2-send"><span class="toc-text">3.2.1.2 send</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E6%8E%A5%E6%94%B6"><span class="toc-text">3.3 接收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-chanrecv"><span class="toc-text">3.3.1 chanrecv</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%85%B3%E9%97%ADchannel"><span class="toc-text">3.3 关闭channel</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-text">附录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#chan-dot"><span class="toc-text">chan.dot</span></a></li></ol></li></ol>
    	</div>
    
</div>


<div class="hd posts">

    
  


    
    	<a href="/"><i class="fa fa-reply replay-btn" aria-hidden="true"></i></a>
    
    <div class="post-title">
        <p>
            channel 源码阅读
        </p>
        <hr>
    </div>
    
    
   	<!-- tags 和 时间 -->
   	<div style="float: right">
   	    2020-10-29
   	</div>

   	
   	    <div>
   	         

<a class="article-tag" href="/tags/Golang/">Golang</a> <a class="article-tag" href="/tags/源码/">源码</a>

   	    </div>
   	
	<br>
    

    <div class="post-content">
        <p>(年初的时候go语言的学习提上了日程，前一篇sync.pool阅读之后，阅读代码进度本该更快些，奈何身体被掏空，所以这篇文章断断续续一个月终于攒起来了。)</p>
<a id="more"></a>

<p>[toc]</p>
<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>channel是golang中用于goroutine之间通讯的数据结构，有以下特点：</p>
<ol>
<li>线程安全</li>
<li>创建channel时返回的是指针，不需要考虑拷贝的问题</li>
<li>顺序通讯，写入和读出的顺序一致</li>
</ol>
<h1 id="2-数据部分"><a href="#2-数据部分" class="headerlink" title="2. 数据部分"></a>2. 数据部分</h1><p><img src="/images/chan.png"></p>
<p><strong>源码位置go/src/runtime/chan.go</strong></p>
<h2 id="2-1-hchan"><a href="#2-1-hchan" class="headerlink" title="2.1  hchan"></a>2.1  hchan</h2><p>channel对应的数据结构</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">	qcount   <span class="keyword">uint</span></span><br><span class="line">	dataqsiz <span class="keyword">uint</span></span><br><span class="line">	buf      unsafe.Pointer</span><br><span class="line">	elemsize <span class="keyword">uint16</span></span><br><span class="line">	closed   <span class="keyword">uint32</span></span><br><span class="line">	elemtype *_type</span><br><span class="line">	sendx    <span class="keyword">uint</span></span><br><span class="line">	recvx    <span class="keyword">uint</span></span><br><span class="line">	recvq    waitq</span><br><span class="line">	sendq    waitq</span><br><span class="line"></span><br><span class="line">	<span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">	<span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Do not change another G&#x27;s status while holding this lock</span></span><br><span class="line">	<span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">	<span class="comment">// with stack shrinking.</span></span><br><span class="line">	lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-1-参数意义"><a href="#2-1-1-参数意义" class="headerlink" title="2.1.1 参数意义"></a>2.1.1 参数意义</h3><p>qcount   uint // 表示channel中元素的个数<br>dataqsiz uint // 表示channel的大小长度<br>buf      unsafe.Pointer // 存储元素的环形队列头指针<br>elemsize uint16 // 表示此channel能存储元素的大小<br>closed   uint32 // channel是否关闭了<br>elemtype *_type // 表示此channel能存储元素的类型<br>sendx    uint // 表示发送操作对应buf的下标，超过dataqsiz之后清0（因为是循环队列嘛）<br>recvx    uint // 表示接收操作对应buf的下标<br>recvq    waitq // 等待接收操作的goroutine队列<br>sendq    waitq // 等待发送操作的goroutine队列</p>
<p>lock mutex // channel的锁</p>
<h2 id="2-2-waitq"><a href="#2-2-waitq" class="headerlink" title="2.2 waitq"></a>2.2 waitq</h2><p>用来表示等待发送或者接受的goroutine队列（用sudog表示队列一个节点）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type waitq struct &#123;</span><br><span class="line">	first *sudog</span><br><span class="line">	last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-1-参数意义"><a href="#2-2-1-参数意义" class="headerlink" title="2.2.1 参数意义"></a>2.2.1 参数意义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first goroutine指针，队首指针</span><br><span class="line">last  goroutine指针，队尾指针</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-函数"><a href="#2-2-2-函数" class="headerlink" title="2.2.2 函数"></a>2.2.2 函数</h3><h4 id="2-2-2-1-enqueue"><a href="#2-2-2-1-enqueue" class="headerlink" title="2.2.2.1 enqueue"></a>2.2.2.1 enqueue</h4><p>两种情况：</p>
<ol>
<li>队列为空，将元素放入队尾将first指针和last指针赋好值</li>
<li>队列不为空，直接将元素放入队尾</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func (q *waitq) enqueue(sgp *sudog) &#123;</span><br><span class="line">	&#x2F;&#x2F; 将goroutine的next置为空</span><br><span class="line">	sgp.next &#x3D; nil</span><br><span class="line">	x :&#x3D; q.last</span><br><span class="line">	if x &#x3D;&#x3D; nil &#123; &#x2F;&#x2F; 如果尾指针为空，说明队列为空，就把这个goroutine放进去</span><br><span class="line">		sgp.prev &#x3D; nil</span><br><span class="line">		q.first &#x3D; sgp</span><br><span class="line">		q.last &#x3D; sgp</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; 直接入队列</span><br><span class="line">	sgp.prev &#x3D; x</span><br><span class="line">	x.next &#x3D; sgp</span><br><span class="line">	q.last &#x3D; sgp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-2-dequeue"><a href="#2-2-2-2-dequeue" class="headerlink" title="2.2.2.2 dequeue"></a>2.2.2.2 dequeue</h4><p>从队列头开始遍历</p>
<ol>
<li>first指针为空，说明队列为空，则直接返回空</li>
<li>如果队列只有一个元素了，将元素取出，并且清空first指针和last指针</li>
<li>队列还有很多元素，直接将first指针对应的元素去除</li>
<li>最后判断如果这个元素(sudog——在channel中用来表示等待接收或者发送的goroutine的)在select结构中并且select结构有其他接口，就跳过，继续遍历下一个节点。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">func (q *waitq) dequeue() *sudog &#123;</span><br><span class="line">	for &#123;</span><br><span class="line">		sgp :&#x3D; q.first</span><br><span class="line">		if sgp &#x3D;&#x3D; nil &#123; &#x2F;&#x2F; 头指针为空，说明队列为空，直接返回</span><br><span class="line">			return nil</span><br><span class="line">		&#125;</span><br><span class="line">		y :&#x3D; sgp.next</span><br><span class="line">		if y &#x3D;&#x3D; nil &#123; &#x2F;&#x2F; 如果next指针为空，说明队列就一个元素了，取出这个就空了，就将队列置空</span><br><span class="line">			q.first &#x3D; nil</span><br><span class="line">			q.last &#x3D; nil</span><br><span class="line">		&#125; else &#123; &#x2F;&#x2F; next不为空，就将next作为队首，将原来的队首返回</span><br><span class="line">			y.prev &#x3D; nil</span><br><span class="line">			q.first &#x3D; y</span><br><span class="line">			sgp.next &#x3D; nil &#x2F;&#x2F; mark as removed (see dequeueSudog)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; if a gogoroutine was put on this queue because of a</span><br><span class="line">		&#x2F;&#x2F; select, there is a small window between the gogoroutine</span><br><span class="line">		&#x2F;&#x2F; being woken up by a different case and it grabbing the</span><br><span class="line">		&#x2F;&#x2F; channel locks. Once it has the lock</span><br><span class="line">		&#x2F;&#x2F; it removes itself from the queue, so we won&#39;t see it after that.</span><br><span class="line">		&#x2F;&#x2F; We use a flag in the G struct to tell us when someone</span><br><span class="line">		&#x2F;&#x2F; else has won the race to signal this gogoroutine but the gogoroutine</span><br><span class="line">		&#x2F;&#x2F; hasn&#39;t removed itself from the queue yet.</span><br><span class="line">		&#x2F;&#x2F; 如果goroutine处于select结构中并且select有其他出口就跳过这个</span><br><span class="line">		if sgp.isSelect &amp;&amp; !atomic.Cas(&amp;sgp.g.selectDone, 0, 1) &#123;</span><br><span class="line">			continue</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return sgp</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-sudog"><a href="#2-3-sudog" class="headerlink" title="2.3 sudog"></a>2.3 sudog</h2><p>sudog是在等待对channel发送或者接受的goroutine</p>
<p><strong>为什么有了goroutine还要有一个sudog？</strong></p>
<ol>
<li>因为goroutine和等待的channel是多对多的关系，一个goroutine可能在等待多个channel，一个channel也可能有很多goroutine在等待，所以用sudog表示这个等待中的goroutine</li>
<li>sudog是channel等待或者接发送链表的一个node</li>
</ol>
<p><strong>sudog通过acquireSudog创建，releaseSudog销毁</strong></p>
<ol>
<li>在go/src/runtime/proc.go中</li>
<li>go会维护一个全局的缓存（有锁），然后每个调度器（P）有自己的缓存</li>
<li>创建sudog时会先从P的缓存中找，没有就到全局缓存中找，在没有才new一个</li>
<li>销毁sudog的时候先判断P是不是满了，如果满了就将一半缓存放到全局缓存然后再把sudog放到自己缓存</li>
<li>全局缓存的生存周期时两次GC的间隔，go/src/runtime/mgc.go 中clearpools()函数中可以看到，每次GC都会清理全局缓存</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">type sudog struct &#123;</span><br><span class="line">	&#x2F;&#x2F; sudog替哪个goroutine在等待</span><br><span class="line">	g *g</span><br><span class="line"></span><br><span class="line">	isSelect bool  &#x2F;&#x2F; 是否在select结构中(select可能取消阻塞发送或接收)</span><br><span class="line">	next     *sudog &#x2F;&#x2F; 下一个节点</span><br><span class="line">	prev     *sudog &#x2F;&#x2F; 上一个节点</span><br><span class="line">	elem     unsafe.Pointer &#x2F;&#x2F; data element (may point to stack)</span><br><span class="line"></span><br><span class="line">	acquiretime int64 &#x2F;&#x2F; 创建时间</span><br><span class="line">	releasetime int64 &#x2F;&#x2F; 释放时间</span><br><span class="line">	ticket      uint32</span><br><span class="line">	parent      *sudog &#x2F;&#x2F; semaRoot binary tree</span><br><span class="line">	waitlink    *sudog &#x2F;&#x2F; g.waiting list or semaRoot</span><br><span class="line">	waittail    *sudog &#x2F;&#x2F; semaRoot</span><br><span class="line">	c           *hchan &#x2F;&#x2F; channel 在等待哪个channel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-1-创建sudog——acquireSudog"><a href="#2-3-1-创建sudog——acquireSudog" class="headerlink" title="2.3.1 创建sudog——acquireSudog"></a>2.3.1 创建sudog——acquireSudog</h3><p>大概逻辑就是现在当前goroutine所在调度器(P)的缓存中找，如果没有就从全局缓存中找，如果还没有就new一个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">func acquireSudog() *sudog &#123;</span><br><span class="line">	&#x2F;&#x2F; 获得当前goroutine所在的线程(M)</span><br><span class="line">	mp :&#x3D; acquirem()</span><br><span class="line">	&#x2F;&#x2F; 获得当前goroutine所在调度器(P)</span><br><span class="line">	pp :&#x3D; mp.p.ptr()</span><br><span class="line">	if len(pp.sudogcache) &#x3D;&#x3D; 0 &#123; &#x2F;&#x2F; 如果调度器的sudog缓存为空，就从中央缓存找，如果再为空就new一个</span><br><span class="line">		lock(&amp;sched.sudoglock)</span><br><span class="line">		&#x2F;&#x2F; First, try to grab a batch from central cache.</span><br><span class="line">		for len(pp.sudogcache) &lt; cap(pp.sudogcache)&#x2F;2 &amp;&amp; sched.sudogcache !&#x3D; nil &#123;</span><br><span class="line">			s :&#x3D; sched.sudogcache</span><br><span class="line">			sched.sudogcache &#x3D; s.next</span><br><span class="line">			s.next &#x3D; nil</span><br><span class="line">			pp.sudogcache &#x3D; append(pp.sudogcache, s)</span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;sched.sudoglock)</span><br><span class="line">		&#x2F;&#x2F; If the central cache is empty, allocate a new one.</span><br><span class="line">		if len(pp.sudogcache) &#x3D;&#x3D; 0 &#123;</span><br><span class="line">			pp.sudogcache &#x3D; append(pp.sudogcache, new(sudog))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	n :&#x3D; len(pp.sudogcache)</span><br><span class="line">	s :&#x3D; pp.sudogcache[n-1]</span><br><span class="line">	pp.sudogcache[n-1] &#x3D; nil</span><br><span class="line">	pp.sudogcache &#x3D; pp.sudogcache[:n-1]</span><br><span class="line">	if s.elem !&#x3D; nil &#123;</span><br><span class="line">		throw(&quot;acquireSudog: found s.elem !&#x3D; nil in cache&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	releasem(mp)</span><br><span class="line">	return s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-销毁sudog——releaseSudog"><a href="#2-3-2-销毁sudog——releaseSudog" class="headerlink" title="2.3.2 销毁sudog——releaseSudog"></a>2.3.2 销毁sudog——releaseSudog</h3><p>大概逻辑就是如果当前goroutine所在调度器(P)的缓存满了，就将调度器(P)的缓存一半放入全局缓存，然后在把sudog放入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">func releaseSudog(s *sudog) &#123;</span><br><span class="line">	&#x2F;&#x2F; 这部分都是check sudog 是否合法</span><br><span class="line">	if s.elem !&#x3D; nil &#123;</span><br><span class="line">		throw(&quot;runtime: sudog with non-nil elem&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	if s.isSelect &#123;</span><br><span class="line">		throw(&quot;runtime: sudog with non-false isSelect&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	if s.next !&#x3D; nil &#123;</span><br><span class="line">		throw(&quot;runtime: sudog with non-nil next&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	if s.prev !&#x3D; nil &#123;</span><br><span class="line">		throw(&quot;runtime: sudog with non-nil prev&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	if s.waitlink !&#x3D; nil &#123;</span><br><span class="line">		throw(&quot;runtime: sudog with non-nil waitlink&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	if s.c !&#x3D; nil &#123;</span><br><span class="line">		throw(&quot;runtime: sudog with non-nil c&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	gp :&#x3D; getg()</span><br><span class="line">	if gp.param !&#x3D; nil &#123;</span><br><span class="line">		throw(&quot;runtime: releaseSudog with non-nil gp.param&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	mp :&#x3D; acquirem() &#x2F;&#x2F; avoid rescheduling to another P</span><br><span class="line">	pp :&#x3D; mp.p.ptr()</span><br><span class="line">	&#x2F;&#x2F; 如果当前调度器的缓存满了，就将一半放入中央缓存</span><br><span class="line">	if len(pp.sudogcache) &#x3D;&#x3D; cap(pp.sudogcache) &#123;</span><br><span class="line">		&#x2F;&#x2F; Transfer half of local cache to the central cache.</span><br><span class="line">		var first, last *sudog</span><br><span class="line">		for len(pp.sudogcache) &gt; cap(pp.sudogcache)&#x2F;2 &#123;</span><br><span class="line">			n :&#x3D; len(pp.sudogcache)</span><br><span class="line">			p :&#x3D; pp.sudogcache[n-1]</span><br><span class="line">			pp.sudogcache[n-1] &#x3D; nil</span><br><span class="line">			pp.sudogcache &#x3D; pp.sudogcache[:n-1]</span><br><span class="line">			if first &#x3D;&#x3D; nil &#123;</span><br><span class="line">				first &#x3D; p</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				last.next &#x3D; p</span><br><span class="line">			&#125;</span><br><span class="line">			last &#x3D; p</span><br><span class="line">		&#125;</span><br><span class="line">		lock(&amp;sched.sudoglock)</span><br><span class="line">		last.next &#x3D; sched.sudogcache</span><br><span class="line">		sched.sudogcache &#x3D; first</span><br><span class="line">		unlock(&amp;sched.sudoglock)</span><br><span class="line">	&#125;</span><br><span class="line">	pp.sudogcache &#x3D; append(pp.sudogcache, s)</span><br><span class="line">	releasem(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-实现细节"><a href="#3-实现细节" class="headerlink" title="3. 实现细节"></a>3. 实现细节</h1><h2 id="3-1-创建channel"><a href="#3-1-创建channel" class="headerlink" title="3.1 创建channel"></a>3.1 创建channel</h2><p><em>go中所有的channel的创建都会使用make关键字，make(arg1, arg2)函数最终会调用到runtime.makechan和runtime.makechan64，下面讲解go在编译时期是如何做这些事情的</em></p>
<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.13.8/src/cmd/compile/internal/gc/typecheck.go">typecheck.go</a><br>编译器会将make(arg1, arg2)转化成OMAKE类型的节点，并在类型检查阶段将OMAKE类型的节点按照arg1的类型转化为OMAKECHAN，OMAKEMAP，OMAKESLICE等类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func typecheck1(n *Node, top int) (res *Node) &#123;</span><br><span class="line">    ...</span><br><span class="line">    switch n.Op &#123;</span><br><span class="line">    ...</span><br><span class="line">    case OMAKE:</span><br><span class="line">        ... </span><br><span class="line">        switch t.Etype &#123;</span><br><span class="line">        ...</span><br><span class="line">        case TCHAN:</span><br><span class="line">            l &#x3D; nil</span><br><span class="line">            if i &lt; len(args) &#123;</span><br><span class="line">                ....</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                n.Left &#x3D; nodintconst(0)</span><br><span class="line">            &#125;</span><br><span class="line">            n.Op &#x3D; OMAKECHAN &#x2F;&#x2F; 节点类型转化为OMAKECHAN</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/go1.13.8/src/cmd/compile/internal/gc/walk.go">walk.go</a><br>OMAKECHAN类型的节点最终会在SSA中间代码生成之前被转化成runtime.makechan或者runtime.makechan64</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func walkexpr(n *Node, init *Nodes) *Node &#123;</span><br><span class="line">    ...</span><br><span class="line">    switch n.Op &#123;</span><br><span class="line">    ...</span><br><span class="line">    case OMAKECHAN:</span><br><span class="line">        &#x2F;&#x2F; When size fits into int, use makechan instead of</span><br><span class="line">        &#x2F;&#x2F; makechan64, which is faster and shorter on 32 bit platforms.</span><br><span class="line">        size :&#x3D; n.Left</span><br><span class="line">        fnname :&#x3D; &quot;makechan64&quot;</span><br><span class="line">        argtype :&#x3D; types.Types[TINT64]</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Type checking guarantees that TIDEAL size is positive and fits in an int.</span><br><span class="line">        &#x2F;&#x2F; The case of size overflow when converting TUINT or TUINTPTR to TINT</span><br><span class="line">        &#x2F;&#x2F; will be handled by the negative range checks in makechan during runtime.</span><br><span class="line">        if size.Type.IsKind(TIDEAL) || maxintval[size.Type.Etype].Cmp(maxintval[TUINT]) &lt;&#x3D; 0 &#123;</span><br><span class="line">            fnname &#x3D; &quot;makechan&quot;</span><br><span class="line">            argtype &#x3D; types.Types[TINT]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        n &#x3D; mkcall1(chanfn(fnname, 1, n.Type), n.Type, init, typename(n.Type), conv(size, argtype))</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-1-makechan64"><a href="#3-1-1-makechan64" class="headerlink" title="3.1.1 makechan64"></a>3.1.1 makechan64</h3><p>check一下size是否是int，然后就执行makechan了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func makechan64(t *chantype, size int64) *hchan &#123;</span><br><span class="line">	if int64(int(size)) !&#x3D; size &#123;</span><br><span class="line">		panic(plainError(&quot;makechan: size out of range&quot;))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return makechan(t, int(size))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-2-makechan"><a href="#3-1-2-makechan" class="headerlink" title="3.1.2 makechan"></a>3.1.2 makechan</h3><ol>
<li>安全检查: channel能存的元素类型大小是否超过2^16</li>
<li>判断<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuwangchuxin0924/p/12735129.html">hchanSize</a>是否关于maxAlign对齐，判断元素对齐是否maxAlign小，如果大maxAlign就没用了，这里hchanSize设计十分巧妙，位运算神操作优化，可以看另一篇文章<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuwangchuxin0924/p/12735129.html">关于2的n次幂对齐</a></li>
<li>判断申请的空间大小是否uint64大，判断所需空间是否超过最大可申请空间，判断size是否小于0(非法)</li>
<li>然后就是给hchan申请内存空间了<ol>
<li>无缓冲的size=0的，只需要给hchan申请hchansize大小的内存空间即可</li>
<li>有缓冲，但是元素是非指针类型的，就申请hchanSize+mem大小的连续内存空间, 并将hchanSize之后的首地址赋值给buf</li>
<li>有缓冲，并且元素类型是指针的，hchan和底层buf内存就可以分开申请不用连续</li>
</ol>
</li>
<li>给其他变量赋值</li>
<li>返回hchan指针，<strong>注意这里返回的是指针，所以channel在各函数之间传递时，就不是值传递了</strong></li>
</ol>
<p><strong>为什么元素类型是非指针hchan和buf要在一段地址连续的内存中，而指针类型的则可以分开</strong><br>这是源码注释的原话:<br>Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.<br>buf points into the same allocation, elemtype is persistent.<br>SudoG’s are referenced from their owning thread so they can’t be collected.<br>TODO(dvyukov,rlh): Rethink when collector can move allocated objects.<br><strong>猜想:</strong><br>大概意思是，当channel中元素类型不包含指针时，gc时需要回收这段空间的，当channel中元素类型包含指针时，这些指针被自己所在线程引用gc是不能回收，所以当元素不包含指针时申请一段连续的空间可以减小gc的压力</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">func makechan(t *chantype, size int) *hchan &#123;</span><br><span class="line">	elem :&#x3D; t.elem</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; compiler checks this but be safe.</span><br><span class="line">	if elem.size &gt;&#x3D; 1&lt;&lt;16 &#123;</span><br><span class="line">		throw(&quot;makechan: invalid channel element type&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	if hchanSize%maxAlign !&#x3D; 0 || elem.align &gt; maxAlign &#123;</span><br><span class="line">		throw(&quot;makechan: bad alignment&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 计算大小需要多少空间，check是否</span><br><span class="line">	&#x2F;&#x2F; 	math.MulUintptr(a, b)函数返回a * b，以及结果是否超过uintptr的最大值</span><br><span class="line">	&#x2F;&#x2F; 判断所需空间是否比uint64大，判断所需空间是否超过最大可申请空间，判断size是否小于0(非法)</span><br><span class="line">	mem, overflow :&#x3D; math.MulUintptr(elem.size, uintptr(size))</span><br><span class="line">	if overflow || mem &gt; maxAlloc-hchanSize || size &lt; 0 &#123;</span><br><span class="line">		panic(plainError(&quot;makechan: size out of range&quot;))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	var c *hchan</span><br><span class="line">	switch &#123;</span><br><span class="line">	case mem &#x3D;&#x3D; 0:</span><br><span class="line">		&#x2F;&#x2F; 就是无缓冲channel，只需要申请hchan需要的大小就行</span><br><span class="line">		c &#x3D; (*hchan)(mallocgc(hchanSize, nil, true))</span><br><span class="line">		c.buf &#x3D; c.raceaddr()</span><br><span class="line">	case elem.ptrdata &#x3D;&#x3D; 0:</span><br><span class="line">		&#x2F;&#x2F; 有缓冲队列channel，但是存放元素不是指针类型的，就要申请hchanSize+这些元素大小的内存空间，然后把申请下来空间首地址赋给buf</span><br><span class="line">		c &#x3D; (*hchan)(mallocgc(hchanSize+mem, nil, true))</span><br><span class="line">		c.buf &#x3D; add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">	default:</span><br><span class="line">		&#x2F;&#x2F; 默认除了给hchan申请内存空间之外还需要申请size个元素大小的内存空间，并且把首地址赋给c.buf</span><br><span class="line">		c &#x3D; new(hchan)</span><br><span class="line">		c.buf &#x3D; mallocgc(mem, elem, true)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.elemsize &#x3D; uint16(elem.size)</span><br><span class="line">	c.elemtype &#x3D; elem</span><br><span class="line">	c.dataqsiz &#x3D; uint(size)</span><br><span class="line"></span><br><span class="line">	if debugChan &#123;</span><br><span class="line">		print(&quot;makechan: chan&#x3D;&quot;, c, &quot;; elemsize&#x3D;&quot;, elem.size, &quot;; elemalg&#x3D;&quot;, elem.alg, &quot;; dataqsiz&#x3D;&quot;, size, &quot;\n&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	return c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-2-发送"><a href="#3-2-发送" class="headerlink" title="3.2 发送"></a>3.2 发送</h2><p><strong>具体编译时做的转换可参考makechan，代码都在类似的地方</strong></p>
<h3 id="3-2-1-chansend"><a href="#3-2-1-chansend" class="headerlink" title="3.2.1 chansend"></a>3.2.1 chansend</h3><ol>
<li>首先检测channel是否为空, 如果为空直接报错</li>
<li>check是否开启了竞争检测，golang的竞争检测通过ThreadSanitizer库(C++)做的</li>
<li>然后kill掉一些不用加锁就可以判断的情况，如果是非阻塞并且channel未关闭，size = 0或者channel满了, 直接返回false(发送失败)</li>
<li>如果已经有goroutine在等待了，就直接调send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int)发给那个goroutine</li>
<li>如果没有goroutine在等待.</li>
<li>如果channel是非阻塞并且还地方，就放入buffer中，如果没地方了就直接返回false</li>
<li>如果channel是阻塞并且不在select中或者在select中且没有其他出口的，就将创建一个sudog，将sudog初始化并且放入待发送队列(sendq), 并且调用goparkunlock(&amp;c.lock, waitReasonChanSend, traceEvGoBlockSend, 3)使当前goroutine陷入沉睡直到被唤醒(已经发出去了)</li>
<li>清理这个过程的垃圾数据</li>
</ol>
<p><strong>第四步中如果有goroutine在等待就直接发送，会影响非阻塞channel数据的顺序吗？</strong><br>不会，channel的数据由唯一全局锁保护，读写互斥，假设一个goroutine来读channel，只有两种情况:</p>
<ol>
<li>channel buffer中有数据，这时goroutine会直接读取数据，不会被阻塞。</li>
<li>channel buffer中没有数据，这时goroutine会被阻塞。</li>
</ol>
<p>只有当buffer中有数据且有goroutine被阻塞时，顺序才会被打乱，但这两个条件是互斥的，有数据就不可能阻塞，阻塞就不可能有数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; entry point for c &lt;- x from compiled code</span><br><span class="line">&#x2F;&#x2F;go:nosplit</span><br><span class="line">func chansend1(c *hchan, elem unsafe.Pointer) &#123;</span><br><span class="line">	chansend(c, elem, true, getcallerpc())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool &#123;</span><br><span class="line">	&#x2F;&#x2F; 如果c为空</span><br><span class="line">	if c &#x3D;&#x3D; nil &#123;</span><br><span class="line">		&#x2F;&#x2F; 如果是非阻塞的，就是那种有容量的，就返回false写channel失败</span><br><span class="line">		if !block &#123;</span><br><span class="line">			return false</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; 如果是非阻塞的就让当前goroutine停止(这里写个小程序就能看效果，这个goroutine的defer不会执行)</span><br><span class="line">		gopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2)</span><br><span class="line">		throw(&quot;unreachable&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if debugChan &#123;</span><br><span class="line">		print(&quot;chansend: chan&#x3D;&quot;, c, &quot;\n&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if raceenabled &#123; &#x2F;&#x2F; 开启竞争检测</span><br><span class="line">		racereadpc(c.raceaddr(), callerpc, funcPC(chansend))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 先不加锁判断非阻塞channel且没关闭</span><br><span class="line">	&#x2F;&#x2F; 如果size &#x3D; 0或者channel满了, 直接返回false(发送失败)</span><br><span class="line">	if !block &amp;&amp; c.closed &#x3D;&#x3D; 0 &amp;&amp; ((c.dataqsiz &#x3D;&#x3D; 0 &amp;&amp; c.recvq.first &#x3D;&#x3D; nil) ||</span><br><span class="line">		(c.dataqsiz &gt; 0 &amp;&amp; c.qcount &#x3D;&#x3D; c.dataqsiz)) &#123;</span><br><span class="line">		return false</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	var t0 int64</span><br><span class="line">	if blockprofilerate &gt; 0 &#123;</span><br><span class="line">		t0 &#x3D; cputicks()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; channel加锁</span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 如果channel关闭了，就返回panic</span><br><span class="line">	if c.closed !&#x3D; 0 &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		panic(plainError(&quot;send on closed channel&quot;))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 等receive队列的队首中取出一个接收者，如果这个接收者不是nil就绕过buffer直接把ep发给他，并且释放锁</span><br><span class="line">	if sg :&#x3D; c.recvq.dequeue(); sg !&#x3D; nil &#123;</span><br><span class="line">		&#x2F;&#x2F; Found a waiting receiver. We pass the value we want to send</span><br><span class="line">		&#x2F;&#x2F; directly to the receiver, bypassing the channel buffer (if any).</span><br><span class="line">		send(c, sg, ep, func() &#123; unlock(&amp;c.lock) &#125;, 3)</span><br><span class="line">		return true</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; channel还没满就将元素放入buffer</span><br><span class="line">	if c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">		&#x2F;&#x2F; Space is available in the channel buffer. Enqueue the element to send.</span><br><span class="line">		&#x2F;&#x2F; 获取一下发送数据的位置</span><br><span class="line">		qp :&#x3D; chanbuf(c, c.sendx)</span><br><span class="line">		if raceenabled &#123;</span><br><span class="line">			raceacquire(qp)</span><br><span class="line">			racerelease(qp)</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; 将元素拷贝进buffer</span><br><span class="line">		typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">		c.sendx++</span><br><span class="line">		if c.sendx &#x3D;&#x3D; c.dataqsiz &#123; &#x2F;&#x2F; 循环一下</span><br><span class="line">			c.sendx &#x3D; 0</span><br><span class="line">		&#125;</span><br><span class="line">		c.qcount++</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		return true</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 如果是非阻塞channel满了就返回false</span><br><span class="line">	if !block &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		return false</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Block on the channel. Some receiver will complete our operation for us.</span><br><span class="line">	&#x2F;&#x2F; 获取当前goroutine</span><br><span class="line">	gp :&#x3D; getg()</span><br><span class="line">	&#x2F;&#x2F; 创建sudog</span><br><span class="line">	mysg :&#x3D; acquireSudog()</span><br><span class="line">	mysg.releasetime &#x3D; 0</span><br><span class="line">	if t0 !&#x3D; 0 &#123;</span><br><span class="line">		mysg.releasetime &#x3D; -1</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; No stack splits between assigning elem and enqueuing mysg</span><br><span class="line">	&#x2F;&#x2F; on gp.waiting where copystack can find it.</span><br><span class="line">	&#x2F;&#x2F; 完善sudog的信息</span><br><span class="line">	mysg.elem &#x3D; ep</span><br><span class="line">	mysg.waitlink &#x3D; nil</span><br><span class="line">	mysg.g &#x3D; gp</span><br><span class="line">	mysg.isSelect &#x3D; false</span><br><span class="line">	mysg.c &#x3D; c</span><br><span class="line">	gp.waiting &#x3D; mysg</span><br><span class="line">	gp.param &#x3D; nil</span><br><span class="line">	&#x2F;&#x2F; 放入发送列表中</span><br><span class="line">	c.sendq.enqueue(mysg)</span><br><span class="line">	&#x2F;&#x2F; 将当前goroutine陷入沉睡</span><br><span class="line">	goparkunlock(&amp;c.lock, waitReasonChanSend, traceEvGoBlockSend, 3)</span><br><span class="line">	KeepAlive(ep)</span><br><span class="line">	&#x2F;&#x2F; 再次唤醒的时候说明元素已经发送完毕了</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; someone woke us up.</span><br><span class="line">	if mysg !&#x3D; gp.waiting &#123;</span><br><span class="line">		throw(&quot;G waiting list is corrupted&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	gp.waiting &#x3D; nil</span><br><span class="line">	if gp.param &#x3D;&#x3D; nil &#123;</span><br><span class="line">		if c.closed &#x3D;&#x3D; 0 &#123;</span><br><span class="line">			throw(&quot;chansend: spurious wakeup&quot;)</span><br><span class="line">		&#125;</span><br><span class="line">		panic(plainError(&quot;send on closed channel&quot;))</span><br><span class="line">	&#125;</span><br><span class="line">	gp.param &#x3D; nil</span><br><span class="line">	if mysg.releasetime &gt; 0 &#123;</span><br><span class="line">		blockevent(mysg.releasetime-t0, 2)</span><br><span class="line">	&#125;</span><br><span class="line">	mysg.c &#x3D; nil</span><br><span class="line">	releaseSudog(mysg)</span><br><span class="line">	return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-1-1-racereadpc"><a href="#3-2-1-1-racereadpc" class="headerlink" title="3.2.1.1 racereadpc"></a>3.2.1.1 racereadpc</h4><p>go/src/runtime/race_amd64.s</p>
<p>PC: 指令计数器寄存器<br>FP: 函数的帧指针，引用函数的参数。使用形如 symbol+offset(FP) 的方式，引用函数的输入参数。例如 arg0+0(FP)，arg1+8(FP)，使用 FP 不加 symbol 时，无法通过编译，在汇编层面来讲，symbol 并没有什么用，加 symbol 主要是为了提升代码可读性。<br>SP: 当前函数栈帧的底部<br>SB: 全局静态基指针，一般用来声明函数或全局变量<br>参数0放在DI通用寄存器<br>参数1放在SI通用寄存器<br>参数2放在DX通用寄存器<br>参数3放在CX通用寄存器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#define RARG0 DI</span><br><span class="line">#define RARG1 SI</span><br><span class="line">#define RARG2 DX</span><br><span class="line">#define RARG3 CX</span><br><span class="line">&#x2F;&#x2F; void runtime·racereadpc(void *addr, void *callpc, void *pc)</span><br><span class="line">TEXT    runtime·racereadpc(SB), NOSPLIT, $0-24</span><br><span class="line">        MOVQ    addr+0(FP), RARG1</span><br><span class="line">        MOVQ    callpc+8(FP), RARG2</span><br><span class="line">        MOVQ    pc+16(FP), RARG3</span><br><span class="line">        ADDQ    $1, RARG3 &#x2F;&#x2F; pc is function start, tsan wants return address</span><br><span class="line">        &#x2F;&#x2F; void __tsan_read_pc(ThreadState *thr, void *addr, void *callpc, void *pc);</span><br><span class="line"></span><br><span class="line">        MOVQ    $__tsan_read_pc(SB), AX</span><br><span class="line">        JMP     racecalladdr&lt;&gt;(SB)</span><br></pre></td></tr></table></figure>

<h4 id="3-2-1-2-send"><a href="#3-2-1-2-send" class="headerlink" title="3.2.1.2 send"></a>3.2.1.2 send</h4><p>用于给goroutine直接发送数据</p>
<ol>
<li>如果数据没问题就直接将数据拷贝到x := &lt;- c表达式x的内存地址上</li>
<li>然后将该goroutine放到处理器(P)的runnext上面等待执行，这里不是直接让goroutine执行，而是等下一次调度的时候直接调这个goroutine</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">func send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) &#123;</span><br><span class="line">	if raceenabled &#123;</span><br><span class="line">		if c.dataqsiz &#x3D;&#x3D; 0 &#123;</span><br><span class="line">			racesync(c, sg)</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			qp :&#x3D; chanbuf(c, c.recvx)</span><br><span class="line">			raceacquire(qp)</span><br><span class="line">			racerelease(qp)</span><br><span class="line">			raceacquireg(sg.g, qp)</span><br><span class="line">			racereleaseg(sg.g, qp)</span><br><span class="line">			c.recvx++</span><br><span class="line">			if c.recvx &#x3D;&#x3D; c.dataqsiz &#123;</span><br><span class="line">				c.recvx &#x3D; 0</span><br><span class="line">			&#125;</span><br><span class="line">			c.sendx &#x3D; c.recvx &#x2F;&#x2F; c.sendx &#x3D; (c.sendx+1) % c.dataqsiz</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if sg.elem !&#x3D; nil &#123; &#x2F;&#x2F; 如果元素没问题就将发送的数据拷贝到x :&#x3D; &lt;- c表达式x所在内存地址上</span><br><span class="line">		sendDirect(c.elemtype, sg, ep)</span><br><span class="line">		sg.elem &#x3D; nil</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; 然后将将该goroutine放到处理器(P)的runnext上面等待执行，这里不是直接让goroutine执行，而是等下一次调度的时候直接调这个goroutine</span><br><span class="line">	gp :&#x3D; sg.g</span><br><span class="line">	unlockf()</span><br><span class="line">	gp.param &#x3D; unsafe.Pointer(sg)</span><br><span class="line">	if sg.releasetime !&#x3D; 0 &#123;</span><br><span class="line">		sg.releasetime &#x3D; cputicks()</span><br><span class="line">	&#125;</span><br><span class="line">	goready(gp, skip+1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-接收"><a href="#3-3-接收" class="headerlink" title="3.3 接收"></a>3.3 接收</h2><p><strong>具体编译时做的转换可参考makechan，代码都在类似的地方</strong></p>
<h3 id="3-3-1-chanrecv"><a href="#3-3-1-chanrecv" class="headerlink" title="3.3.1 chanrecv"></a>3.3.1 chanrecv</h3><p>两种接收方式：<br>chanrecv1是丢弃channel出来的元素，类似 &lt;- c这中表达式<br>chanrecv2是使用channel出来的元素，类似 elem := &lt;- c<br>最终都会调用到chanrecv</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; entry points for &lt;- c from compiled code</span><br><span class="line">&#x2F;&#x2F;go:nosplit</span><br><span class="line">func chanrecv1(c *hchan, elem unsafe.Pointer) &#123;</span><br><span class="line">	chanrecv(c, elem, true)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;go:nosplit</span><br><span class="line">func chanrecv2(c *hchan, elem unsafe.Pointer) (received bool) &#123;</span><br><span class="line">	_, received &#x3D; chanrecv(c, elem, true)</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>判断chan是否为nil，如果是直接报错</li>
<li>kill掉一些不用枷锁就可以判断的情况，如果是非阻塞并且队列为空并且channel未关闭就返回false</li>
<li>如果channel已经关闭了，就清空ep中的数据，立即返回</li>
<li>如果已经有sendq在等待了(发送端提到过，如果没有goroutine等待接受，就加入sendq), 就直接接收这个元素</li>
<li>如果此时没有goroutine等待发送</li>
<li>如果是非阻塞且buffer中有数据直接从buffer中取出，如果没有数据直接返回false</li>
<li>如果是阻塞的且当前goroutine没在select中或者在select中但没有其他出口，就把自己加入recvq，然后调用goparkunlock(&amp;c.lock, waitReasonChanReceive, traceEvGoBlockRecv, 3)，等待被唤醒（如果被唤醒说明有有数据来了)</li>
<li>清理这个过程中的垃圾数据</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) &#123;</span><br><span class="line">	if debugChan &#123;</span><br><span class="line">		print(&quot;chanrecv: chan&#x3D;&quot;, c, &quot;\n&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; channel为空就使goroutine 停止并报错</span><br><span class="line">	if c &#x3D;&#x3D; nil &#123;</span><br><span class="line">		if !block &#123;</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">		gopark(nil, nil, waitReasonChanReceiveNilChan, traceEvGoStop, 2)</span><br><span class="line">		throw(&quot;unreachable&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 如果是非阻塞并且队列为空并且channel未关闭就返回false</span><br><span class="line">	if !block &amp;&amp; (c.dataqsiz &#x3D;&#x3D; 0 &amp;&amp; c.sendq.first &#x3D;&#x3D; nil ||</span><br><span class="line">		c.dataqsiz &gt; 0 &amp;&amp; atomic.Loaduint(&amp;c.qcount) &#x3D;&#x3D; 0) &amp;&amp;</span><br><span class="line">		atomic.Load(&amp;c.closed) &#x3D;&#x3D; 0 &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	var t0 int64</span><br><span class="line">	if blockprofilerate &gt; 0 &#123;</span><br><span class="line">		t0 &#x3D; cputicks()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 如果channel已关闭, 并且没有数据了就清除ep中的数据立刻返回</span><br><span class="line">	if c.closed !&#x3D; 0 &amp;&amp; c.qcount &#x3D;&#x3D; 0 &#123;</span><br><span class="line">		if raceenabled &#123;</span><br><span class="line">			raceacquire(c.raceaddr())</span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		if ep !&#x3D; nil &#123;</span><br><span class="line">			typedmemclr(c.elemtype, ep)</span><br><span class="line">		&#125;</span><br><span class="line">		return true, false</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 如果已经有goroutine等着了，就直接让这个goroutine recive</span><br><span class="line">	if sg :&#x3D; c.sendq.dequeue(); sg !&#x3D; nil &#123;</span><br><span class="line">		recv(c, sg, ep, func() &#123; unlock(&amp;c.lock) &#125;, 3)</span><br><span class="line">		return true, true</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; channel不为空将元素复制到ep中(ep :&#x3D; &lt;- c)</span><br><span class="line">	if c.qcount &gt; 0 &#123;</span><br><span class="line">		&#x2F;&#x2F; Receive directly from queue</span><br><span class="line">		qp :&#x3D; chanbuf(c, c.recvx)</span><br><span class="line">		if raceenabled &#123;</span><br><span class="line">			raceacquire(qp)</span><br><span class="line">			racerelease(qp)</span><br><span class="line">		&#125;</span><br><span class="line">		if ep !&#x3D; nil &#123;</span><br><span class="line">			typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">		&#125;</span><br><span class="line">		typedmemclr(c.elemtype, qp)</span><br><span class="line">		c.recvx++</span><br><span class="line">		if c.recvx &#x3D;&#x3D; c.dataqsiz &#123;</span><br><span class="line">			c.recvx &#x3D; 0</span><br><span class="line">		&#125;</span><br><span class="line">		c.qcount--</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		return true, true</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 如果是非阻塞直接返回false</span><br><span class="line">	if !block &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		return false, false</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 获取当前goroutine</span><br><span class="line">	gp :&#x3D; getg()</span><br><span class="line">	&#x2F;&#x2F; 创建sudog</span><br><span class="line">	mysg :&#x3D; acquireSudog()</span><br><span class="line">	mysg.releasetime &#x3D; 0</span><br><span class="line">	if t0 !&#x3D; 0 &#123;</span><br><span class="line">		mysg.releasetime &#x3D; -1</span><br><span class="line">	&#125;</span><br><span class="line">	mysg.elem &#x3D; ep</span><br><span class="line">	mysg.waitlink &#x3D; nil</span><br><span class="line">	gp.waiting &#x3D; mysg</span><br><span class="line">	mysg.g &#x3D; gp</span><br><span class="line">	mysg.isSelect &#x3D; false</span><br><span class="line">	mysg.c &#x3D; c</span><br><span class="line">	gp.param &#x3D; nil</span><br><span class="line">	c.recvq.enqueue(mysg)</span><br><span class="line">	goparkunlock(&amp;c.lock, waitReasonChanReceive, traceEvGoBlockRecv, 3)</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; someone woke us up</span><br><span class="line">	if mysg !&#x3D; gp.waiting &#123;</span><br><span class="line">		throw(&quot;G waiting list is corrupted&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	gp.waiting &#x3D; nil</span><br><span class="line">	if mysg.releasetime &gt; 0 &#123;</span><br><span class="line">		blockevent(mysg.releasetime-t0, 2)</span><br><span class="line">	&#125;</span><br><span class="line">	closed :&#x3D; gp.param &#x3D;&#x3D; nil</span><br><span class="line">	gp.param &#x3D; nil</span><br><span class="line">	mysg.c &#x3D; nil</span><br><span class="line">	releaseSudog(mysg)</span><br><span class="line">	return true, !closed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-关闭channel"><a href="#3-3-关闭channel" class="headerlink" title="3.3 关闭channel"></a>3.3 关闭channel</h2><p>关闭channel大概逻辑就是，将buffer中的数据都释放掉，然后close设置为0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">func closechan(c *hchan) &#123;</span><br><span class="line">	&#x2F;&#x2F; 如果为空抛出异常</span><br><span class="line">	if c &#x3D;&#x3D; nil &#123;</span><br><span class="line">		panic(plainError(&quot;close of nil channel&quot;))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line">	&#x2F;&#x2F; 如果channel已经关闭就抛出异常</span><br><span class="line">	if c.closed !&#x3D; 0 &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		panic(plainError(&quot;close of closed channel&quot;))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if raceenabled &#123;</span><br><span class="line">		callerpc :&#x3D; getcallerpc()</span><br><span class="line">		racewritepc(c.raceaddr(), callerpc, funcPC(closechan))</span><br><span class="line">		racerelease(c.raceaddr())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.closed &#x3D; 1</span><br><span class="line"></span><br><span class="line">	var glist gList</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 清理所有的数据</span><br><span class="line">	&#x2F;&#x2F; release all readers</span><br><span class="line">	for &#123;</span><br><span class="line">		sg :&#x3D; c.recvq.dequeue()</span><br><span class="line">		if sg &#x3D;&#x3D; nil &#123;</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">		if sg.elem !&#x3D; nil &#123;</span><br><span class="line">			typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">			sg.elem &#x3D; nil</span><br><span class="line">		&#125;</span><br><span class="line">		if sg.releasetime !&#x3D; 0 &#123;</span><br><span class="line">			sg.releasetime &#x3D; cputicks()</span><br><span class="line">		&#125;</span><br><span class="line">		gp :&#x3D; sg.g</span><br><span class="line">		gp.param &#x3D; nil</span><br><span class="line">		if raceenabled &#123;</span><br><span class="line">			raceacquireg(gp, c.raceaddr())</span><br><span class="line">		&#125;</span><br><span class="line">		glist.push(gp)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; release all writers (they will panic)</span><br><span class="line">	for &#123;</span><br><span class="line">		sg :&#x3D; c.sendq.dequeue()</span><br><span class="line">		if sg &#x3D;&#x3D; nil &#123;</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">		sg.elem &#x3D; nil</span><br><span class="line">		if sg.releasetime !&#x3D; 0 &#123;</span><br><span class="line">			sg.releasetime &#x3D; cputicks()</span><br><span class="line">		&#125;</span><br><span class="line">		gp :&#x3D; sg.g</span><br><span class="line">		gp.param &#x3D; nil</span><br><span class="line">		if raceenabled &#123;</span><br><span class="line">			raceacquireg(gp, c.raceaddr())</span><br><span class="line">		&#125;</span><br><span class="line">		glist.push(gp)</span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Ready all Gs now that we&#39;ve dropped the channel lock.</span><br><span class="line">	for !glist.empty() &#123;</span><br><span class="line">		gp :&#x3D; glist.pop()</span><br><span class="line">		gp.schedlink &#x3D; 0</span><br><span class="line">		goready(gp, 3)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="chan-dot"><a href="#chan-dot" class="headerlink" title="chan.dot"></a>chan.dot</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">digraph &#123;</span><br><span class="line">    bgcolor&#x3D;&quot;#C6CFD532&quot;; </span><br><span class="line"></span><br><span class="line">    node [shape&#x3D;record, fontsize&#x3D;&quot;8&quot;, margin&#x3D;&quot;0.04&quot;, height&#x3D;0.2, color&#x3D;gray] </span><br><span class="line">	edge [fontname&#x3D;&quot;Inconsolata, Consolas&quot;, fontsize&#x3D;10, arrowhead&#x3D;normal]</span><br><span class="line"></span><br><span class="line">    hchan [shape&#x3D;record,label&#x3D;&quot;&#123;qcount|dataqsiz|buf|elemsize|closed|elemtype|&lt;sendx&gt;sendx|&lt;recvx&gt;recvx|recvq|sendq|lock&#125;&quot;,xlabel&#x3D;&quot;hchan&quot;]</span><br><span class="line">    waitq[shape&#x3D;record,label&#x3D;&quot;&#123;&lt;first&gt;first|&lt;last&gt;last&#125;&quot;,xlabel&#x3D;&quot;waitq&quot;]</span><br><span class="line">    sudog[shape&#x3D;record,label&#x3D;&quot;&#123;g|isSelect|next|prev|elem|acquiretime|releasetime|ticket|parent|waitlink|waittail|c&#125;&quot;,xlabel&#x3D;&quot;sudog&quot;]</span><br><span class="line"></span><br><span class="line">    hchan:sendx -&gt; waitq [label&#x3D;&quot;发送队列&quot;]</span><br><span class="line">    hchan:recvx -&gt; waitq [label&#x3D;&quot;接收队列&quot;]</span><br><span class="line">    waitq:first -&gt; sudog</span><br><span class="line">    waitq:last -&gt; sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
	var gitalk = new Gitalk({
    		clientID: 'a60f22cd3c5d7e6aafa8',
    		clientSecret: 'db8f7c66f2e8e20275173155975b749870291c5b',
    		repo: 'journey-c.github.io',
    		owner: 'journey-c',
    		admin: ['journey-c'],
    		id: 'channel 源码阅读',
    		distractionFreeMode: true
  	});
  	gitalk.render('gitalk-container');
</script>

    
</div>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-S162K82BSE"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-S162K82BSE');
</script>

    <div class="footer" id="footer">
    <p>Copyright © 2020-<script>document.write(new Date().getFullYear())</script> <a class="flink" target="_blank" rel="noopener" href="https://github.com/journey-c">Journey-C</a>. 
    </p>
</div>


<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>


<script src="/js/js.js"></script>


<div id="totop" style="position:fixed;bottom:150px;right:50px;cursor: pointer;">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<script src="/js/totop.js"></script>

<style type="text/css">
.v * {
    color: #698fca;
}

.v .vlist .vcard .vhead .vsys {
    color: #3a3e4a;
}

.v .vlist .vcard .vh .vmeta .vat {
    color: #638fd5;
}

.v .vlist .vcard .vhead .vnick {
    color: #6ba1ff;
}

.v a {
    color: #8696b1;
}

.v .vlist .vcard .vhead .vnick:hover {
    color: #669bfc;
}
</style>

</body>

</html>
