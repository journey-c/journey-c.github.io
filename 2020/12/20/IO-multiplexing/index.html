

<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <link rel="shortcut icon" type="image/png" href="/favicon.png"/>
    
<link rel="stylesheet" href="/libs/highlight/styles/atom-one-dark.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="journey-c" type="application/atom+xml">
</head>

<title>Linux的I/O多路复用机制</title>

<body>
    <div class="hd">
    <ol class="breadcrumb">
        
            <li><a class="ba" href="/">首页</a></li>
        
            <li><a class="ba" href="/about">关于</a></li>
        
            <li><a class="ba" href="/sketch">随笔</a></li>
        
            <li><a class="ba" target="_blank" rel="noopener" href="https://github.com/journey-c">Github</a></li>
        
            <li><a class="ba" target="_blank" rel="noopener" href="https://www.cnblogs.com/wuwangchuxin0924">博客园</a></li>
        
    </ol>
    <hr class="breadcrumbhr">
</div>


<div class="toc">
    <!-- 右侧导航栏 -->
    
    	<div>
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B"><span class="toc-text">1. 文件系统简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%87%A0%E7%A7%8DI-O%E6%A8%A1%E5%9E%8B"><span class="toc-text">2. 几种I&#x2F;O模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Blocking-I-O"><span class="toc-text">2.1 Blocking I&#x2F;O</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-Nonblocking-I-O"><span class="toc-text">2.2 Nonblocking I&#x2F;O</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-Signal-Driven-I-O"><span class="toc-text">2.3 Signal Driven I&#x2F;O</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-Asynchronous-I-O"><span class="toc-text">2.4 Asynchronous I&#x2F;O</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-I-O-Multiplexing"><span class="toc-text">2.5 I&#x2F;O Multiplexing</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Select"><span class="toc-text">3. Select</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E4%BD%BF%E7%94%A8"><span class="toc-text">3.1 使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%AE%9E%E7%8E%B0"><span class="toc-text">3.2 实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%B0%8F%E7%BB%93"><span class="toc-text">3.3 小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Poll"><span class="toc-text">4. Poll</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E4%BD%BF%E7%94%A8"><span class="toc-text">4.1 使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.2 实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%B0%8F%E7%BB%93"><span class="toc-text">4.3 小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Epoll"><span class="toc-text">5. Epoll</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E4%BD%BF%E7%94%A8"><span class="toc-text">5.1 使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E5%AE%9E%E7%8E%B0"><span class="toc-text">5.2 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-epoll-create"><span class="toc-text">5.2.1 epoll_create</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-epoll-ctl"><span class="toc-text">5.2.2 epoll_ctl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3-epoll-wait"><span class="toc-text">5.2.3 epoll_wait</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E5%B0%8F%E7%BB%93"><span class="toc-text">5.3 小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-select%E3%80%81poll%E3%80%81epoll%E5%AF%B9%E6%AF%94"><span class="toc-text">6. select、poll、epoll对比</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83"><span class="toc-text">7. 事件回调</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E6%B5%81%E7%A8%8B"><span class="toc-text">7.1 流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-text">7.2 流程图</span></a></li></ol></li></ol>
    	</div>
    
</div>


<div class="hd posts">

    
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


    
    	<a href="/"><i class="fa fa-reply replay-btn" aria-hidden="true"></i></a>
    
    <div class="post-title">
        <p>
            Linux的I/O多路复用机制
        </p>
        <hr>
    </div>
    
    
   	<!-- tags 和 时间 -->
   	<div style="float: right">
   	    2020-12-20
   	</div>

   	
   	    <div>
   	         

<a class="article-tag" href="/tags/linux/">linux</a> <a class="article-tag" href="/tags/I-O多路复用/">I/O多路复用</a>

   	    </div>
   	
	<br>
    

    <div class="post-content">
        <h1 id="1-文件系统简介"><a href="#1-文件系统简介" class="headerlink" title="1. 文件系统简介"></a>1. 文件系统简介</h1><p>Linux平台万物皆文件，这句话实际是在夸Linux出色的虚拟文件系统，Linux将所有设备抽象为文件，与设备的数据交互抽象为文件的I/O。</p>
<p><img src="/images/file.png" alt="file"></p>
<p>Linux的虚拟文件系统大概分为四块：</p>
<ul>
<li>超级块</li>
</ul>
<ol>
<li>文件系统(ext3,ext4以及windows上的NTFS、FAT32、FAT16等)</li>
<li>内核结构对应<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/fs.h#L1415">super_block</a>，对应操作对象<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/fs.h#L1921">super_operations</a>。</li>
</ol>
<ul>
<li>索引节点</li>
</ul>
<ol>
<li>操作系统以块为单位对磁盘操作(块是扇区大小的整数倍)。索引节点记录了文件在磁盘上所有的物理块(文件内容)，以及其他信心(更新时间，操作时间等)。</li>
<li>内核结构对应<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/fs.h#L615">inode</a>，对应操作对象<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/fs.h#L1843">inode_operations</a>。</li>
</ol>
<ul>
<li>目录项</li>
</ul>
<ol>
<li>可以理解为文件的路径(不是目录，Linux上目录也是文件)，进程操作文件时通过目录项找到实际文件。</li>
<li>内核结构对应<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/dcache.h#L89">dentry</a>，对应操作对象<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/dcache.h#L135">dentry_operations</a>。</li>
</ol>
<ul>
<li>文件</li>
</ul>
<ol>
<li>由进程打开的文件。</li>
<li>内核结构对应<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/fs.h#L921">file</a>，对应操作对象<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/fs.h#L1801">file_operations</a></li>
</ol>
<p>通常服务里例如socket，pipe等对象的read，write实际就是file对应的file_operations的操作，而本文讲解I/O相关事情。</p>
<h1 id="2-几种I-O模型"><a href="#2-几种I-O模型" class="headerlink" title="2. 几种I/O模型"></a>2. 几种I/O模型</h1><h2 id="2-1-Blocking-I-O"><a href="#2-1-Blocking-I-O" class="headerlink" title="2.1 Blocking I/O"></a>2.1 Blocking I/O</h2><ul>
<li>传统的阻塞I/O，对一个文件描述符操作(FD)时，如果操作没有响应就会一直等待，直到内核有反馈。缺点就是单线程一次只能操作一个FD。</li>
</ul>
<p><img src="/images/io_block.jpeg" alt="io_block"></p>
<h2 id="2-2-Nonblocking-I-O"><a href="#2-2-Nonblocking-I-O" class="headerlink" title="2.2 Nonblocking I/O"></a>2.2 Nonblocking I/O</h2><ul>
<li>非阻塞I/O，对FD操作时，如果内核没反馈不会一直等待。非阻塞I/O会将所有FD放入FD set，一直轮询所有FD，直到有反馈的。缺点就是每次轮询时没有事件的FD也会被操作，浪费CPU。</li>
</ul>
<p><img src="/images/io_noblock.jpeg" alt="io_noblock"></p>
<h2 id="2-3-Signal-Driven-I-O"><a href="#2-3-Signal-Driven-I-O" class="headerlink" title="2.3 Signal Driven I/O"></a>2.3 Signal Driven I/O</h2><ul>
<li>信号驱动I/O的基本原理就是首先注册signal handler，当FD有事件到来时，内核会像进程发送信号，然后应用进程执行signal handler。缺点就是，编程难度高，信号处理起来复杂。</li>
</ul>
<p><img src="/images/io_signal.jpeg" alt="io_signal"></p>
<h2 id="2-4-Asynchronous-I-O"><a href="#2-4-Asynchronous-I-O" class="headerlink" title="2.4 Asynchronous I/O"></a>2.4 Asynchronous I/O</h2><ul>
<li>异步I/O和信号驱动I/O都是异步的，区别是:信号驱动I/O是FD满足条件时内核通知应用程序可以进行I/O了，而异步I/O是应用程序将I/O操作交给内核，当内核做完之后再通知应用程序I/O做完了。缺点是异步的并发量不好控制。</li>
</ul>
<p><img src="/images/io_async.jpeg" alt="io_async"></p>
<h2 id="2-5-I-O-Multiplexing"><a href="#2-5-I-O-Multiplexing" class="headerlink" title="2.5 I/O Multiplexing"></a>2.5 I/O Multiplexing</h2><ul>
<li>多路复用实际不是一个技术而是一个理念，在I/O多路复用之前就有通讯线路的频分复用和时分复用，大概就是合理的安排每个单位使用资源的时间和位置，看起来所有单位一起在使用原本只能允许少量单位同时使用的资源。</li>
<li>Linux的I/O多路复用机制就是本文要讲的内容了。I/O多路复用就是将所有的FD注册到内核，然后当哪个FD可用时，那个会通知应用程序可用。</li>
</ul>
<p><img src="/images/io_multi.jpeg" alt="io_multi"></p>
<p>应用程序使用Linux提供的I/O多路复用机制都是通过<a href="/2020/11/27/what-is-system-call">系统调用</a>使用的。最初Linux只提供了Select，在哪个服务端fd使用数量普遍不高的年代是够用的，后来随着网络的发展，1024个FD的限制已经不够用了，所以Linux提供了Poll，Poll只优化了存储结构，Select使用BitMap来存储FD，Poll使用数组来存储FD，不再限制数量，但是遍历时间复杂度还是$O(lg^N)$。终于在Linux 2.5.44版本，epoll闪亮登场，这是现在普遍使用的I/O多路复用机制。</p>
<h1 id="3-Select"><a href="#3-Select" class="headerlink" title="3. Select"></a>3. Select</h1><h2 id="3-1-使用"><a href="#3-1-使用" class="headerlink" title="3.1 使用"></a>3.1 使用</h2><p>Select是Linux最初提供的I/O多路复用函数。下面是libc库使用select的调用接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</span><br><span class="line">void FD_SET(int fd, fd_set *set);</span><br><span class="line">void FD_CLR(int fd, fd_set *set);</span><br><span class="line">int  FD_ISSET(int fd, fd_set *set);</span><br><span class="line">void FD_ZERO(fd_set *set);</span><br></pre></td></tr></table></figure>
<p>Select总共三部分参数</p>
<ol>
<li>传入FD(文件描述符)最大的+1</li>
<li>传入的FD，分三类<ul>
<li>1). 监听读</li>
<li>2). 监听写</li>
<li>3). 监听异常</li>
</ul>
</li>
<li>如果一直没有满足条件的fd，最多等多久(超时时间)</li>
</ol>
<p>select用一个<code>__FD_SETSIZE</code>位的BitMap表示输入参数，<code>__FD_SETSIZE</code>默认为1024。因为没有1024位那么长的数，所以用一个数组表示，因为数组元素地址连续，所以实际就是一个1024位的数，比如第1位为1，表示这次输入有fd1(标准输出fd)。这个地方也限制了<code>select最多支持1024个fd，并且fd的号码不能大于等于1024。</code></p>
<p><img src="/images/fd_set.png" alt="fd_set"></p>
<p>解释完fd_set的构造，FD_SET、FD_CLR等操作也就明白了，FD_SET(d, s)就是d是几号fd就将s的第几位置1，其他的类似。</p>
<h2 id="3-2-实现"><a href="#3-2-实现" class="headerlink" title="3.2 实现"></a>3.2 实现</h2><p>Linux的select函数是通过系统调用的机制提供给用户，我们来一起看一下Select的流程:</p>
<ol>
<li>系统调用函数入口在<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L722">SYSCALL_DEFINE5</a>，可能是历史原因想保留这个接口，所以这个函数没做事情直接调用了<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L700">kern_select</a>。</li>
<li>Select传入的时间是一个相对时间，<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L700">kern_select</a>判断如果时间参数不为空的话，就调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L273">poll_select_set_timeout</a>将相对时间转化为绝对时间(准确的几点几分几秒)，然后就调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L621">core_sys_select</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L621">core_sys_select</a>主要的工作就是为Select工作分配资源空间。<ul>
<li>1 获取<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Read-copy-update">rcu锁</a>，check一下第一个参数n是不是比进程最大可打开文件描述符数还大，如果还大的话修正n为最大可打开文件描述符数。释放<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Read-copy-update">rcu锁</a>，rcu实际就是延迟更新，读操作不需要获取锁，只需要标记一下还有用户在读。写操作时拷贝一份数据，更新副本，当所有没有读者读旧数据的时候再将副本数据更新到原始数据上。</li>
<li>2 接下来就是给输入的三个变量fds.in, fds.out, fds.ex，保存结果的三个变量(fds.res_in, fds.res_out, fds.res_ex)分配存储空间，先从<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L630">栈</a>分配，栈空间不够时从<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L658">堆</a>分配。</li>
<li>3 资源分配结束后就调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L476">do_select</a>开始真正的检查每个FD是否可用。</li>
<li>4 <a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L476">do_select</a>是select的核心，流程如下: <ul>
<li><ol>
<li>首先调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L419">max_select_fd</a>找出传入FD的最大值+1，比较一下参数n是不是比最大FD+1还大，如果是就修正n为最大FD+1(<code>这里之所以总是将n修正为最大值+1，是因为do_select遍历范围是[0,n)</code>)，顺便检查下，传入的FD是不是有已关闭或者未打开的，如果有就报错<code>EBADF</code>:<ul>
<li><ol>
<li>传入fd_set是long的数组，openfiles也是long的数组，因为之前n根据线程最大打开文件数修正过，所以通过(n/(long的位数))可以最高位可以比较的数组下表，然后fd_set数组的那一位根据(n % (long的位数))来去掉不满足条件的FD</li>
</ol>
</li>
<li><ol start="2">
<li>然后就从最高位开始fd_set和open_file做AND操作，第一个匹配的就是最大FD。</li>
</ol>
</li>
<li><ol start="3">
<li><img src="/images/max_select_fd.png" alt="max_select_fd"></li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L121">poll_initwait</a>初始化<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L103">poll_wqueues</a>(维护select/poll任务的主要struct)，并且将<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L221">__pollwait</a>注册为<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L43">poll_table</a>的proc函数，file_operations-&gt;poll会调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L48">poll_wait</a>将此时所在线程(task)放入队列，poll_wait对调用__poll_wait，这个_poll_wait此时注册的函数。主要作用就是将任务放入队列，以及做一些其他任务。</li>
</ol>
</li>
<li><ol start="3">
<li>如果timeout不为空，调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L236">poll_schedule_timeout</a>设置超时时间。</li>
</ol>
</li>
<li><ol start="4">
<li>重复遍历所有fd_set:<ul>
<li><ol>
<li>这个循环是个死循环，跳出条件为:<ul>
<li><ol>
<li>超时时间到(如果设置了超时时间)。</li>
</ol>
</li>
<li><ol start="2">
<li>线程被唤醒。</li>
</ol>
</li>
<li><ol start="3">
<li>当前线程被信号唤醒。</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/file.h#L63">fdget</a>获取fd对应的file结构体。</li>
</ol>
</li>
<li><ol start="3">
<li>调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L86">vfs_poll</a>，获取file的事件mask，如果有in，out，ex就放入对应结果的fd_set中。<ul>
<li><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L86">vfs_poll</a>最终会调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/fs.h#L1801">file_operations</a>的poll函数获取FD的事件状态mask，vfs_poll会调用file_operations-&gt;poll函数检查FD的事件，如果没有就调用poll_wait将线程放入等待队列。</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><ol start="4">
<li>调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/file.h#L43">fdput</a>释放fd对应file结构体。</li>
</ol>
</li>
<li><ol start="5">
<li>如果本次遍历一个有事件的FD也没有就调用cond_resched出让CPU，并且把线程状态设为INTERRUPTIBLE(睡眠可打断状态)，休眠直到被唤醒。</li>
</ol>
</li>
<li><ol start="6">
<li>等到有<a href="#event_callback">事件回调</a>，就会重新遍历FD集合这次肯定有事件了，如果超时或者被信号唤醒也有相应操作。</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>5 <a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L476">do_select</a>将可用FD返回之后，调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L688">set_fd_set</a>拷贝回用户空间。</li>
<li>6 如果传入参数的BitsMap一开始是分配在堆上的就释放调。</li>
</ul>
</li>
<li>调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L297">poll_select_finish</a>将剩余时间拷贝回用户空间。</li>
</ol>
<h2 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3 小结"></a>3.3 小结</h2><p>select的流程简单来讲就是，将FD通过BitsMap传入内核，轮询所有的FD通过调用file-&gt;poll函数查询是否有对应事件，没有就将task加入FD对应file的待唤醒队列，等待事件来临被唤醒。(例如网卡来数据了)</p>
<p><img src="/images/select_process.png" alt="select_process"></p>
<ol>
<li>select使用BitsMap来传入和接受FD，每次调用都会在用户空间和内核空间之间拷贝。</li>
<li>select的BitsMap限制只能监听FD 0~1023。</li>
<li>轮询的方式监听所有FD，$O(n)$的复杂度</li>
</ol>
<h1 id="4-Poll"><a href="#4-Poll" class="headerlink" title="4. Poll"></a>4. Poll</h1><h2 id="4-1-使用"><a href="#4-1-使用" class="headerlink" title="4.1 使用"></a>4.1 使用</h2><p>随着互联网的发展Select 1024个FD的限制已经不满足众多服务了，于是出现了Poll，不再用BitsMap来传入FD，取而代之用动态数组传入FD，但获取事件状态的方式还是轮询。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int poll(struct pollfd *fds, nfds_t nfds, int timeout);</span><br><span class="line">struct pollfd &#123;</span><br><span class="line">    int   fd;         &#x2F;* file descriptor *&#x2F;</span><br><span class="line">    short events;     &#x2F;* requested events *&#x2F;</span><br><span class="line">    short revents;    &#x2F;* returned events *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>1.fds: 传入fd集合，由pollfd构成<ul>
<li><ol>
<li>fd: 文件描述符</li>
</ol>
</li>
<li><ol start="2">
<li>events: 监听事件</li>
</ol>
</li>
<li><ol start="3">
<li>revents: 返回FD是因为什么事件返回的</li>
</ol>
</li>
</ul>
</li>
<li>2.nfds: fds的长度</li>
<li>3.timeout: 超时时间，单位毫秒</li>
</ul>
<h2 id="4-2-实现"><a href="#4-2-实现" class="headerlink" title="4.2 实现"></a>4.2 实现</h2><p>Poll和Select的入口都在<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c">fs/select.c</a>中，下面我们来看一下Poll内核实现的流程:</p>
<ol>
<li>Poll的入口在<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L1057">SYSCALL_DEFINE3</a>，<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L1057">SYSCALL_DEFINE3</a>的主要工作是将timeout由相对时间转化为绝对时间。然后调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L970">do_sys_poll</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L970">do_sys_poll</a>流程:<ul>
<li><ol>
<li>检查nfds是否超过进程最大可打开文件数，如果是就报错-EINVAL。</li>
</ol>
</li>
<li><ol start="2">
<li>给输入参数分配空间再从用户空间拷贝过来，先试图在栈上分配，如果不够再从堆上分配。</li>
</ol>
</li>
<li><ol start="3">
<li>调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L121">poll_initwait</a>初始化poll_wqueues(和select一样)，然后调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L881">do_poll</a>，do_poll主要流程为:<ul>
<li><ol>
<li>调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L75">select_estimate_accuracy</a>设置过期时间。</li>
</ol>
</li>
<li><ol start="2">
<li>然后就轮训所有的FD，调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L851">do_pollfd</a>检查FD的事件。do_pollfd也是调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L86">vfs_poll</a>来检测FD事件的，如果没有就将线程放入对应FD的等待队列等待被激活，自己休眠。(和select一样)</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><ol start="4">
<li>调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/select.c#L138">poll_freewait</a>释放刚刚初始化的poll_wqueues。</li>
</ol>
</li>
<li><ol start="5">
<li>调用<code>__put_user</code>将结果拷贝回用户空间。</li>
</ol>
</li>
<li><ol start="6">
<li>如果最开始参数是在堆上分配的，就释放内存。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="4-3-小结"><a href="#4-3-小结" class="headerlink" title="4.3 小结"></a>4.3 小结</h2><p>poll和select差不多，区别就是BitsMap换成了链表，FD数量只受poll可用内核内存大小限制。</p>
<p><img src="/images/poll_process.png" alt="poll_process"></p>
<ol>
<li>poll监听FD数量不再有限制(除线程本身限制外)，但是每次调用poll还是要将FD集合拷贝到内核态，完成后再拷贝回来。</li>
<li>监听所有FD的方式还是轮训，$O(n)$的复杂度。</li>
</ol>
<h1 id="5-Epoll"><a href="#5-Epoll" class="headerlink" title="5. Epoll"></a>5. Epoll</h1><h2 id="5-1-使用"><a href="#5-1-使用" class="headerlink" title="5.1 使用"></a>5.1 使用</h2><p>正因为select和poll有着各自的缺点，所以linux 2.5.44版本提供了新的I/O复用机制Epoll，在后续的版本中继续做了很多优化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct epoll_event &#123;</span><br><span class="line">    uint32_t     events;      &#x2F;* Epoll events *&#x2F;</span><br><span class="line">    epoll_data_t data;        &#x2F;* User data variable *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line">typedef union epoll_data &#123;</span><br><span class="line">    void        *ptr;</span><br><span class="line">    int          fd;</span><br><span class="line">    uint32_t     u32;</span><br><span class="line">    uint64_t     u64;</span><br><span class="line">&#125; epoll_data_t;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建用于epoll工作的FD</span><br><span class="line">int epoll_create(int size);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对事件操作：增、删等</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等待事件</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);  </span><br></pre></td></tr></table></figure>
<ul>
<li><p>epoll_create</p>
<ul>
<li>size: 监听fd的数量，Linux 2.6.8就去掉了这个参数，因为要兼容，所以留着这个参数，但实际内核没用。</li>
</ul>
</li>
<li><p>epoll_ctl</p>
<ul>
<li>epfd: epoll对应的FD</li>
<li>op: 操作码，增(EPOLL_CTL_ADD),删(EPOLL_CTL_DEL),改(EPOLL_CTL_MOD)</li>
<li>fd: 对epoll操作的源FD，例如要添加删除修改的FD</li>
<li>event: 要监听的事件</li>
</ul>
</li>
<li><p>epoll_wait</p>
<ul>
<li>epfd: epoll对应的FD</li>
<li>events: 要等待的事件数组</li>
<li>maxevents: 监听事件数量</li>
<li>timeout: 超时时间，单位毫秒</li>
</ul>
</li>
</ul>
<h2 id="5-2-实现"><a href="#5-2-实现" class="headerlink" title="5.2 实现"></a>5.2 实现</h2><h3 id="5-2-1-epoll-create"><a href="#5-2-1-epoll-create" class="headerlink" title="5.2.1 epoll_create"></a>5.2.1 epoll_create</h3><ol>
<li>epoll_create的入口在<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L2088">SYSCALL_DEFINE1</a>，这个函数只是简单的检查了一下size是否为0，epoll_create的size参数随便填只要大于0即可，不使用的。然后调用了<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L2040">do_epoll_create</a>对epoll_create操作统一处理。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L2040">do_epoll_create</a>流程如下:<ul>
<li><ol>
<li>检查一下flags除了EPOLL_CLOEXEC，还有没有其他的flag</li>
</ol>
</li>
<li><ol start="2">
<li>调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1006">ep_alloc</a>申请一个<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L181">eventpoll</a>结构，这是存储epoll所有数据的数据结构。</li>
</ol>
</li>
<li><ol start="3">
<li>调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/file.c#L561">get_unused_fd_flags</a>根据flags申请一个本进程最小未使用的fd。</li>
</ol>
</li>
<li><ol start="4">
<li>调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/anon_inodes.c#L74">anon_inode_getfile</a>创建一个对应匿名inode的file，file的私有数据存的是eventpoll结构体。inode在VFS中对应一个文件，记录了此文件在磁盘那些块以及文件各种信息，匿名inode就是将此文件的dentry(目录项)删掉了，在文件系统中一般是通过dentry(目录项)来查找使用文件，这样其他进程就用不了这个文件。相当于创建一个临时文件。</li>
</ol>
</li>
<li><img src="/images/anonymous_inode.png" alt="anonymous_inode"></li>
<li><ol start="5">
<li>现在file(由进程打开的文件)有了，fd有了，把file和fd的关系放入本进程的open_files中，就相当于本进程打开了这个文件。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="5-2-2-epoll-ctl"><a href="#5-2-2-epoll-ctl" class="headerlink" title="5.2.2 epoll_ctl"></a>5.2.2 epoll_ctl</h3><ol>
<li>epoll_ctl的入口在<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L2272">SYSCALL_DEFINE4</a>，首先根据op选择要不要从用户空间拷贝参数(只要不是DEL都需要拷贝)，之后就调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L2108">do_epoll_ctl</a>做主要的工作了。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L2108">do_epoll_ctl</a>主要流程如下:<ul>
<li><ol>
<li>参数获取:<ul>
<li><ol>
<li>调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/file.h#L63">fdget</a>根据epfd获得epoll对应的file(epoll_create时创建的)，根据参数传入的fd获取对应的file。</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li>参数检查:<ul>
<li><ol>
<li>调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L81">file_can_poll</a>判断该文件支不支持poll函数，实际就是判断该文件对应的file_operation的poll函数为不为空。</li>
</ol>
</li>
<li><ol start="2">
<li>判断系统支不支持autosleep功能，如果支持且用户也传入了EPOLLWAKEUP标志，就调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/uapi/linux/eventpoll.h#L83">ep_take_care_of_epollwakeup</a>将标志加到事件中，否则就将EPOLLWAKEUP事件丢弃。</li>
</ol>
</li>
<li><ol start="3">
<li>check一下要操作的fd是不是epfd(操作自己epoll的fd)和epfd是不是一个epoll fd。</li>
</ol>
</li>
<li><ol start="4">
<li>EPOLLEXCLUSIVE(since Linux 3.5)是一个FD被多个epoll监听时，当这个FD事件来临只有一个epoll会被唤起(避免惊群效应)。而epoll只允许add的时传入不允许mod时传入，这里就是check一下这种情况。</li>
</ol>
</li>
<li><ol start="5">
<li>处理一种Epoll A包含Epoll B的FD，Epoll B也包含Epoll A的FD的情况，这时候如果其中一个FD有了事件，那么两个Epoll会循环被唤醒。</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>接下来就是核心操作:<ul>
<li><ol>
<li>根据file地址和fd大小 调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1041">ep_find</a> 查找传入fd是否在eventpoll结构体中的rbtree(存储所有监听的fd)已存在。rbtree的key就是<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L107">epoll_filefd</a>，比较规则，先比较file的地址，相同的话在比较fd的大小。</li>
</ol>
</li>
<li><ol start="2">
<li>如果是ADD就调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1490">ep_insert</a>:<ul>
<li><ol>
<li>当前用用户的epoll_watch和<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1502">max_user_watches</a>检查是否还有可用空间，内核给每个用户的epoll可以用空间限制为syscall可使用空间的$1/25$。</li>
</ol>
</li>
<li><ol start="2">
<li>从缓存中创建一个新的epitem(<a href="/2020/10/22/red-black-tree">红黑树</a>的value)。</li>
</ol>
</li>
<li><ol start="3">
<li>初始化rdllink(满足事件链表)，fllink(链接fd对应的file链表)，pwqlist(poll等待队列)。</li>
</ol>
</li>
<li><ol start="4">
<li>初始化epitem的参数，调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L322">ep_set_ffd</a>根据file，fd生成<a href="/2020/10/22/red-black-tree">红黑树</a>的key(struct epoll_filefd)等。</li>
</ol>
</li>
<li><ol start="5">
<li>向插入fd对应file的epoll事件链表(f_ep_links)中新增事件。</li>
</ol>
</li>
<li><ol start="6">
<li>将epitem插入<a href="/2020/10/22/red-black-tree">红黑树</a>。</li>
</ol>
</li>
<li><ol start="7">
<li>调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L75">init_poll_funcptr</a>注册poll回调函数<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1309">ep_ptable_queue_proc</a>。在前select一节有描述。这里回调函数<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1309">ep_ptable_queue_proc</a>除了将task放入FD对应file的等待队列之外，事件来临还会调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1204">ep_poll_callback</a>函数。</li>
</ol>
</li>
<li><ol start="8">
<li>调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L877">ep_item_poll</a></li>
</ol>
<ul>
<li><ol>
<li>如果不是epoll的FD就调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L86">vfs_poll</a>-&gt;file_operations.poll查询FD事件如果有就返回，没有就插入等待队列。</li>
</ol>
</li>
<li><ol start="2">
<li>如果是epoll的FD，就调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L677">ep_scan_ready_list</a>将epoll的rdllist(已就绪的FD)传入用户空间。</li>
</ol>
</li>
</ul>
</li>
<li><ol start="9">
<li>如果有事件的话并且之前不在就绪链表rdllist，就放入就绪链表</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>如果是DEL就调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L767">ep_remove</a>:<ul>
<li><ol>
<li>调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L618">ep_unregister_pollwait</a>注销epoll_add时注册的file对应的poll_wait函数。</li>
</ol>
</li>
<li><ol start="2">
<li>从各链表中删除。</li>
</ol>
</li>
<li><ol start="3">
<li>从<a href="/2020/10/22/red-black-tree">红黑树</a>中删除。</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><ol start="4">
<li>如果是MOD就调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1622">ep_modify</a>:<ul>
<li><ol>
<li>修改FD事件。</li>
</ol>
</li>
<li><ol start="2">
<li>调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L877">ep_item_poll</a>查询是否修改后有事件，有的话就放入rdllist就绪链表。</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="5-2-3-epoll-wait"><a href="#5-2-3-epoll-wait" class="headerlink" title="5.2.3 epoll_wait"></a>5.2.3 epoll_wait</h3><ol>
<li>epoll_wait入口在<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L2330">SYSCALL_DEFINE4</a>，之后调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L2288">do_epoll_wait</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L2288">do_epoll_wait</a>主要流程:<ul>
<li><ol>
<li>检查参数，参数是否正确，返回结果地址是否正确，要操作的epollfd是否正确。</li>
</ol>
</li>
<li><ol start="2">
<li>调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1818">ep_poll</a><ul>
<li><ol>
<li>如果有timeout不为零，就将时间转化为绝对时间，如果为0就检查一下当前就绪队列是否为空，如果有事件直接返回，没有事件就返回空。</li>
</ol>
</li>
<li><ol start="2">
<li>调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L375">ep_events_available</a>检查当前有无就绪FD，有就直接返回，或者当前file_operations-&gt;poll函数正忙就等等，看工作完有没有。</li>
</ol>
</li>
<li><ol start="3">
<li>如果没有就进入死循环，和select一样，将task设为TASK_INTERRUPTIBLE，等待被唤醒或被信号唤醒或超时。</li>
</ol>
</li>
<li><ol start="4">
<li>直到被唤醒依然调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L375">ep_events_available</a>检查有没有就绪FD，有的话就调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1778">ep_send_events</a>将结果传回用户空间。<ul>
<li><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1778">ep_send_events</a>调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L677">ep_scan_ready_list</a>扫描rdllist链表并且调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/fs/eventpoll.c#L1694">ep_send_events_proc</a>将事件发回用户空间，如果FD的使用的epoll的模式为EPOLLET(水平触发)发送完之后重新被加入rdllist链表，等待下次epoll_wait时，如果fd在rdllink中且已经不可读了就不再加入rdllist中了。</li>
</ol>
</li>
<li><ol start="2">
<li>发送会用户空间之后，将因为rdllist发送时加锁而没加入的事件(放入了ovflist)加入rdllist。</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="5-3-小结"><a href="#5-3-小结" class="headerlink" title="5.3 小结"></a>5.3 小结</h2><p>select和poll的模式都是，一次将参数拷贝到内核空间，等有结果了再一次拷贝出去，类似无状态服务。而epoll则只是在epoll_ctl(ADD)时将数据拷入，epoll_wait时在将数据拷出，多次复用没有其他数据拷贝，大大节省了数据拷贝。epoll采用<a href="/2020/10/22/red-black-tree">红黑树</a>存储所有被监听的FD是的查找删除时间复杂度由$O(N)$缩短为$O(log^N)$。</p>
<p><img src="/images/epoll_process.png" alt="epoll_process"></p>
<ol>
<li>epoll_create创建eventpoll结构。</li>
<li>epoll_ctl:<ul>
<li><ol>
<li>ADD检查FD事件，有就加入rdllist队列，没有就将task放入FD对应file的待唤醒列表，将FD加入<a href="/2020/10/22/red-black-tree">红黑树</a>维护。</li>
</ol>
</li>
<li><ol start="2">
<li>DEL从eventpoll的各个资源中删除。</li>
</ol>
</li>
<li><ol start="3">
<li>MOD修改事件，并再次检查FD事件，有就加入rdllist队列，没有就将task放入FD对应file的待唤醒列表并且注册事件回调函数——有事件来临就加入rdllist。</li>
</ol>
</li>
</ul>
</li>
<li>epoll_wait检查rdllist有没有已经就绪的FD，没有就等待时间来临唤醒，有事件就返回用户空间，并且清空rdllist链表，如果FD是EPOLLLET模式的就重新加入rdllist链表中，等待下次epoll_wait看情况清理。</li>
</ol>
<h1 id="6-select、poll、epoll对比"><a href="#6-select、poll、epoll对比" class="headerlink" title="6. select、poll、epoll对比"></a>6. select、poll、epoll对比</h1><table>
<thead>
<tr>
<th>名称</th>
<th>监听FD数量</th>
<th>数据拷贝</th>
<th>操作复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>select</td>
<td>1024</td>
<td>每次操作从用户空间拷入内核空间然后拷出</td>
<td>$O(N)$</td>
</tr>
<tr>
<td>poll</td>
<td>内核限制sys内存大小</td>
<td>每次操作从用户空间拷入内核空间然后拷出</td>
<td>$O(N)$</td>
</tr>
<tr>
<td>epoll</td>
<td>内核限制sys内存大小</td>
<td>ADD时拷贝一次，epoll_wait时利用MMAP和用户共享空间，直接拷贝数据到用户控件</td>
<td>$O(1)$</td>
</tr>
</tbody></table>
<p><span id = "event_callback"></span></p>
<h1 id="7-事件回调"><a href="#7-事件回调" class="headerlink" title="7. 事件回调"></a>7. 事件回调</h1><p>select/poll/epoll最后都会调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L86">vfs_poll</a>，检查FD是否有相应事件。<br><a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/poll.h#L86">vfs_poll</a>的核心流程就是:</p>
<ul>
<li>先检查FD对应的file目前是否已有事件，如果没有则将当前task(linux中线程进程都是task)加入到file的wait_queue，然后就让出CPU，等待被激活。</li>
<li>当file对应的设备有事件来临时，会激活file的wait_queue中所有等待的task(将task从等待态变为运行态，重新加入到调度列表中)。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CPU1                CPU2</span><br><span class="line">sys_select          receive packet</span><br><span class="line">...                 ...</span><br><span class="line">__add_wait_queue    update tp-&gt;rcv_nxt</span><br><span class="line">...                 ...</span><br><span class="line">tp-&gt;rcv_nxt check   sock_def_readable</span><br><span class="line">...                 &#123;</span><br><span class="line">schedule               rcu_read_lock();</span><br><span class="line">                       wq &#x3D; rcu_dereference(sk-&gt;sk_wq);</span><br><span class="line">                       if (wq &amp;&amp; waitqueue_active(&amp;wq-&gt;wait))</span><br><span class="line">                           wake_up_interruptible(&amp;wq-&gt;wait)</span><br><span class="line">                       ...</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="7-1-流程"><a href="#7-1-流程" class="headerlink" title="7.1 流程"></a>7.1 流程</h2><p>下面我们以socket为例，分析一下事件是如何回调的。</p>
<p>设备驱动层主要做的事情是，网卡作为一个硬件，当收到网络包的时候如何通知操作系统。没错，是硬件中断，硬件和操作系统打交道的方式基本都是硬件中断。而网卡与内核交互采用了硬件中断+下半部（主要是拷贝数据太耗时，放在中断处理程序中不妥）</p>
<ul>
<li>设备给中断控制器引脚发送信号。</li>
<li>中断控制器收到后给CPU发送信号。</li>
<li>CPU收到信号后产生中断，根据中断号在中断向量表中执行内核实现的中断处理程序。(执行程序实际就是已经与内核通讯了)<br><img src="/images/event_driver.png" alt="event_driver"></li>
</ul>
<p>以intel的ixgb网卡为例。</p>
<ol>
<li>网卡程序初始化时调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L116">ixgb_init_module</a>注册驱动<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L92">ixgb_driver</a>，并且调用驱动的probe函数<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L359">ixgb_probe</a>。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L359">ixgb_probe</a>中与本文相关的有:<ul>
<li><ol>
<li>创建一个<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/linux/netdevice.h#L1863">struct net_device</a>表示网络设备。</li>
</ol>
</li>
<li><ol start="2">
<li>设置网卡的相关操作<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L331">ixgb_netdev_ops</a>，其中ndo_open函数是网卡激活时执行的函数，对应ixgb网卡的<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L593">ixgb_open</a>函数。调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L6600">netif_napi_add</a>为这个网络设备注册一个轮询 poll 函数 <a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L1752">ixgb_clean</a>，将来一旦出现网络包的时候，就是要通过它来轮询了。</li>
</ol>
</li>
<li><ol start="3">
<li><a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L593">ixgb_open</a>中调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L171">ixgb_up</a>注册硬件中断，类型为IRQF_SHARED，中断设备名字ixgb，并且中断处理程序为<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L1721">ixgb_intr</a></li>
</ol>
</li>
</ul>
</li>
<li>当网卡有数据来临时，网卡给中断控制器发送信号，中断控制器给CPU发送信号，CPU执行对应的中断处理函数<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L1721">ixgb_intr</a><ul>
<li><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L1721">ixgb_intr</a>中调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L6281">__napi_schedule</a>和<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L4240">___napi_schedule</a>将设备标记，触发软件中断NET_RX_SOFTIRQ，软件中断号对应的中断处理函数为<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L6735">net_rx_action</a></li>
</ol>
</li>
<li><ol start="2">
<li><a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L6735">net_rx_action</a>调用napi_poll轮询所有的网络设备，napi_poll调用网卡注册是注册的poll函数<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L1752">ixgb_clean</a></li>
</ol>
</li>
<li><ol start="3">
<li><a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L1752">ixgb_clean</a>调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/drivers/net/ethernet/intel/ixgb/ixgb_main.c#L1929">ixgb_clean_rx_irq</a>读取数据并将数据存放到struct sk_buff中，然后调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L5553">netif_receive_skb</a>处理二层的数据。</li>
</ol>
</li>
</ul>
</li>
<li>从<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L5553">netif_receive_skb</a>开始处理二层的数据，调用链<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L5478">netif_receive_skb_internal</a>-&gt;<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L5380">__netif_receive_skb</a>-&gt;<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L5079">__netif_receive_skb_core</a><ul>
<li><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/dev.c#L5079">__netif_receive_skb_core</a>中根据协议头将数据交给三层对应的协议栈。</li>
</ol>
</li>
</ul>
</li>
<li>现在就开始处理三层的数据里，假如当前的包是一个IPv4的包，数据就会流向<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/ip_input.c#L530">ip_rcv</a><ul>
<li><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/ip_input.c#L530">ip_rcv</a>中得到IP的报头，然后调用NF_HOOK判断路由，不是本机的包就发走，是本机的包就调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/ip_input.c#L414">ip_rcv_finish</a></li>
</ol>
</li>
<li><ol start="2">
<li><a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/ip_input.c#L414">ip_rcv_finish</a>调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/ip_input.c#L314">ip_rcv_finish_core</a>然后根据IP报头中的协议把数据交给四层的协议栈。</li>
</ol>
</li>
</ul>
</li>
<li>千辛万苦数据终于来到了四层，假如当前是一个TCP包的话。会调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/tcp_ipv4.c#L1886">tcp_v4_rcv</a><ul>
<li><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/tcp_ipv4.c#L1886">tcp_v4_rcv</a>根据IP以及tcp报头内容在<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/tcp_ipv4.c#L91">tcp_hashinfo</a> (<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/include/net/inet_hashtables.h#L124">inet_hashinfo</a>)找到对应socket</li>
</ol>
</li>
<li><ol start="2">
<li>接下来根据socket的不同状态进行处理，socket根据情况进入三个不同队列，这一步主要是先将包找个地方放一下，赶紧离开中断状态。<ul>
<li><ol>
<li>backlog 当前没有用户在读数据，就将socket 放入backlog中，离开软件中断状态(到之前为止一直在软件中断中)</li>
</ol>
</li>
<li><ol start="2">
<li>prequeue 如果当前有用户在读数据，且一个窗口的包还没收集完就放入prequeue</li>
</ol>
</li>
<li><ol start="3">
<li>sk_receive_queue 当一个窗口的包准确收集完了，就放入sk_receive_queue中，用户可读取了。</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>当一个窗口的包准确收集完之后，就会调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/tcp_input.c#L4849">tcp_data_queue</a>将数据放入sk_receive_queue，然后调用<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/tcp_input.c#L4837">tcp_data_ready</a>，在调用sock的sk_data_ready函数<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/sock.c#L2901">sock_def_readable</a>，<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/core/sock.c#L2901">sock_def_readable</a>会唤醒之前因为调用file_operations.poll为阻塞的进程或线程。</li>
</ol>
</li>
</ul>
</li>
<li>这就到了咱们最关心的问题了，<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/bbf5c979011a099af5dc76498918ed7df445635b/net/ipv4/tcp_input.c#L4837">tcp_data_ready</a>唤醒的是哪些task。</li>
</ol>
<h2 id="7-2-流程图"><a href="#7-2-流程图" class="headerlink" title="7.2 流程图"></a>7.2 流程图</h2><p><img src="/images/net_callback.png" alt="net_callback"></p>

    </div>

    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
	var gitalk = new Gitalk({
    		clientID: 'a60f22cd3c5d7e6aafa8',
    		clientSecret: 'db8f7c66f2e8e20275173155975b749870291c5b',
    		repo: 'journey-c.github.io',
    		owner: 'journey-c',
    		admin: ['journey-c'],
    		id: 'Linux的I/O多路复用机制',
    		distractionFreeMode: true
  	});
  	gitalk.render('gitalk-container');
</script>

    
</div>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-S162K82BSE"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-S162K82BSE');
</script>

    <div class="footer" id="footer">
    <p>Copyright © 2020-<script>document.write(new Date().getFullYear())</script> <a class="flink" target="_blank" rel="noopener" href="https://github.com/journey-c">Journey-C</a>. 
    </p>
</div>


<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>


<script src="/js/js.js"></script>


<div id="totop" style="position:fixed;bottom:150px;right:50px;cursor: pointer;">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<script src="/js/totop.js"></script>

<style type="text/css">
.v * {
    color: #698fca;
}

.v .vlist .vcard .vhead .vsys {
    color: #3a3e4a;
}

.v .vlist .vcard .vh .vmeta .vat {
    color: #638fd5;
}

.v .vlist .vcard .vhead .vnick {
    color: #6ba1ff;
}

.v a {
    color: #8696b1;
}

.v .vlist .vcard .vhead .vnick:hover {
    color: #669bfc;
}
</style>

</body>

</html>
